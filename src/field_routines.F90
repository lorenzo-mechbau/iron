!> \file
!> \author Chris Bradley
!> \brief This module handles all field related routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all field related routines.
MODULE FIELD_ROUTINES

  USE BaseRoutines
  USE BasisRoutines
  USE BasisAccessRoutines
  USE ComputationEnvironment
  USE COORDINATE_ROUTINES
  USE CmissMPI
  USE DistributedMatrixVector
  USE DOMAIN_MAPPINGS
  USE FieldAccessRoutines
  USE HashRoutines
  USE Kinds
  USE INPUT_OUTPUT
  USE ISO_VARYING_STRING
  USE Lists
  USE Maths
#ifndef NOMPIMOD
  USE MPI
#endif
  USE MESH_ROUTINES
  USE MeshAccessRoutines
  USE Strings
  USE Types

#include "macros.h"

  IMPLICIT NONE

#ifdef NOMPIMOD
#include "mpif.h"
#endif

  PRIVATE

  !Module parameters

  !> \addtogroup FIELD_ROUTINES_DependentTypes FIELD_ROUTINES::DependentTypes
  !> \brief Depedent field parameter types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDependentTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_INDEPENDENT_TYPE=1 !<Independent field type \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEPENDENT_TYPE=2 !<Dependent field type \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_DimensionTypes FIELD_ROUTINES::DimensionTypes
  !> \brief Field dimension parameter types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDimensionTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_SCALAR_DIMENSION_TYPE=1 !<Scalar field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_VECTOR_DIMENSION_TYPE=2 !<Vector field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_TENSOR_DIMENSION_TYPE=3 !<Tensor field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_FieldTypes FIELD_ROUTINES::FieldTypes
  !> \brief Field type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_TYPE=1 !<Geometric field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_FIBRE_TYPE=2 !<Fibre field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GENERAL_TYPE=3 !<General field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MATERIAL_TYPE=4 !<Material field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_GENERAL_TYPE=5 !<Geometric general field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_InterpolationTypes FIELD_ROUTINES::InterpolationTypes
  !> \brief Field interpolation parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldInterpolationTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_CONSTANT_INTERPOLATION=1 !<Constant interpolation. One parameter for the field \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_BASED_INTERPOLATION=2 !<Element based interpolation. Parameters are different in each element \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_FACE_BASED_INTERPOLATION=3 !<Face based interpolation. Parameters are different in each face \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_LINE_BASED_INTERPOLATION=4 !<Line based interpolation. Parameters are different in each Line \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NODE_BASED_INTERPOLATION=5 !<Node based interpolation. Parameters are nodal based and a basis function is used \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GRID_POINT_BASED_INTERPOLATION=6 !<Grid point based interpolation. Parameters are different at each grid point \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GAUSS_POINT_BASED_INTERPOLATION=7 !<Gauss point based interpolation. Parameters are different at each Gauss point \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DATA_POINT_BASED_INTERPOLATION=8 !<data point based interpolation. Parameters are different at each data point \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION=9 !<Element and external boundary face based interpolation. Parameters are different in each element with seperate values for boundary faces \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION=10 !<Element and external boundary line based interpolation. Parameters are different in each element with seperate values for boundary lines \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  !>@}

!> \addtogroup FIELD_ROUTINES_DofTypes FIELD_ROUTINES::DofTypes
  !> \brief Field dof type parameters
  !> \see FIELD_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_CONSTANT_DOF_TYPE=1 !<The dof is from a field variable component with constant interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_DOF_TYPE=2 !<The dof is from a field variable component with element based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_FACE_DOF_TYPE=3 !<The dof is from a field variable component with element based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_LINE_DOF_TYPE=4 !<The dof is from a field variable component with element based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NODE_DOF_TYPE=5 !<The dof is from a field variable component with node based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GRID_POINT_DOF_TYPE=6 !<The dof is from a field variable component with grid point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GAUSS_POINT_DOF_TYPE=7 !<The dof is from a field variable component with Gauss point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DATA_POINT_DOF_TYPE=8 !<The dof is from a field variable component with Gauss point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_DataTypes FIELD_ROUTINES::DataTypes
  !> \brief Field data types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDataTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_INTG_TYPE=1 !<Integer field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_SP_TYPE=2 !<Single precision real field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DP_TYPE=3 !<Double precision real field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_L_TYPE=4 !<Logical field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_DOFOrderTypes FIELD_ROUTINES::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDOFOrderTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_SEPARATED_COMPONENT_DOF_ORDER=1 !<Field variable component dofs are not contiguous \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER=2 !<Field variable component dofs are contiguous \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_ScalingTypes FIELD_ROUTINES::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldScalingTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_NO_SCALING=0 !<The field is not scaled \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_UNIT_SCALING=1 !<The field has unit scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ARC_LENGTH_SCALING=2 !<The field has arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ARITHMETIC_MEAN_SCALING=3 !<The field has arithmetic mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_MEAN_SCALING=4 !<The field has geometric mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_HARMONIC_MEAN_SCALING=5 !<The field has harmonic mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_InterpolationComponentsTypes FIELD_ROUTINES::InterpolationComponentsTypes
  !> \brief Field interpolation components types
  !> \see FIELD_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_ALL_COMPONENTS_TYPE=1 !<The field is interpolated for all components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_COMPONENTS_TYPE=2 !<The field is interpolated for geometric components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NONGEOMETRIC_COMPONENTS_TYPE=3 !<The field is interpolated for non-geometric components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces

  INTERFACE Field_ComponentInterpolationCheck
    MODULE PROCEDURE FIELD_COMPONENT_INTERPOLATION_CHECK
  END INTERFACE Field_ComponentInterpolationCheck

  INTERFACE Field_ComponentInterpolationSet
    MODULE PROCEDURE FIELD_COMPONENT_INTERPOLATION_SET
  END INTERFACE Field_ComponentInterpolationSet

  INTERFACE Field_ComponentInterpolationSetAndLock
    MODULE PROCEDURE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK
  END INTERFACE Field_ComponentInterpolationSetAndLock

 !>Gets the label for a field variable component.
  INTERFACE FIELD_COMPONENT_LABEL_GET
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_VS
  END INTERFACE FIELD_COMPONENT_LABEL_GET

  !>Gets the label for a field variable component.
  INTERFACE Field_ComponentLabelGet
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_VS
  END INTERFACE Field_ComponentLabelGet

  !>Sets/changes the label for a field variable component.
  INTERFACE FIELD_COMPONENT_LABEL_SET
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_VS
  END INTERFACE FIELD_COMPONENT_LABEL_SET

  !>Sets/changes the label for a field variable component.
  INTERFACE Field_ComponentLabelSet
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_VS
  END INTERFACE Field_ComponentLabelSet

  !>Sets/changes the label for a field variable component and locks so that no further changes can be made.
  INTERFACE FIELD_COMPONENT_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS
  END INTERFACE FIELD_COMPONENT_LABEL_SET_AND_LOCK

  !>Sets/changes the label for a field variable component and locks so that no further changes can be made.
  INTERFACE Field_ComponentLabelSetAndLock
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS
  END INTERFACE Field_ComponentLabelSetAndLock

  INTERFACE Field_ComponentMeshComponentCheck
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_CHECK
  END INTERFACE Field_ComponentMeshComponentCheck

  INTERFACE Field_ComponentMeshComponentGet
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_GET
  END INTERFACE Field_ComponentMeshComponentGet

  INTERFACE Field_ComponentMeshComponentSet
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_SET
  END INTERFACE Field_ComponentMeshComponentSet

  INTERFACE Field_ComponentMeshComponentSetAndLock
    MODULE PROCEDURE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK
  END INTERFACE Field_ComponentMeshComponentSetAndLock

  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE FIELD_COMPONENT_VALUES_INITIALISE
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_INTG
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_SP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_DP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_L
  END INTERFACE FIELD_COMPONENT_VALUES_INITIALISE

  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE Field_ComponentValuesInitialise
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_INTG
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_SP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_DP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_L
  END INTERFACE Field_ComponentValuesInitialise

  INTERFACE Field_CreateFinish
    MODULE PROCEDURE FIELD_CREATE_FINISH
  END INTERFACE Field_CreateFinish

  !>Starts the process of creating a field
  INTERFACE FIELD_CREATE_START
    MODULE PROCEDURE FIELD_CREATE_START_INTERFACE
    MODULE PROCEDURE FIELD_CREATE_START_REGION
  END INTERFACE FIELD_CREATE_START

  !>Starts the process of creating a field
  INTERFACE Field_CreateStart
    MODULE PROCEDURE FIELD_CREATE_START_INTERFACE
    MODULE PROCEDURE FIELD_CREATE_START_REGION
  END INTERFACE Field_CreateStart

  INTERFACE Field_Destroy
    MODULE PROCEDURE FIELD_DESTROY
  END INTERFACE Field_Destroy

  INTERFACE Field_DataTypeCheck
    MODULE PROCEDURE FIELD_DATA_TYPE_CHECK
  END INTERFACE Field_DataTypeCheck

  INTERFACE Field_DataTypeGet
    MODULE PROCEDURE FIELD_DATA_TYPE_GET
  END INTERFACE Field_DataTypeGet

  INTERFACE Field_DataTypeSet
    MODULE PROCEDURE FIELD_DATA_TYPE_SET
  END INTERFACE Field_DataTypeSet

  INTERFACE Field_DataTypeSetAndLock
    MODULE PROCEDURE FIELD_DATA_TYPE_SET_AND_LOCK
  END INTERFACE Field_DataTypeSetAndLock

  INTERFACE Field_DependentTypeCheck
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_CHECK
  END INTERFACE Field_DependentTypeCheck

  INTERFACE Field_DependentTypeGet
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_GET
  END INTERFACE Field_DependentTypeGet

  INTERFACE Field_DependentTypeSet
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_SET
  END INTERFACE Field_DependentTypeSet

  INTERFACE Field_DependentTypeSetAndLock
    MODULE PROCEDURE FIELD_DEPENDENT_TYPE_SET_AND_LOCK
  END INTERFACE Field_DependentTypeSetAndLock

  INTERFACE Field_DimensionCheck
    MODULE PROCEDURE FIELD_DIMENSION_CHECK
  END INTERFACE Field_DimensionCheck

  INTERFACE Field_DimensionGet
    MODULE PROCEDURE FIELD_DIMENSION_GET
  END INTERFACE Field_DimensionGet

  INTERFACE Field_DimensionSet
    MODULE PROCEDURE FIELD_DIMENSION_SET
  END INTERFACE Field_DimensionSet

  INTERFACE Field_DimensionSetAndLock
    MODULE PROCEDURE FIELD_DIMENSION_SET_AND_LOCK
  END INTERFACE Field_DimensionSetAndLock

  INTERFACE Field_DOFOrderTypeCheck
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_CHECK
  END INTERFACE Field_DOFOrderTypeCheck

  INTERFACE Field_DOFOrderTypeGet
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_GET
  END INTERFACE Field_DOFOrderTypeGet

  INTERFACE Field_DOFOrderTypeSet
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_SET
  END INTERFACE Field_DOFOrderTypeSet

  INTERFACE Field_DOFOrderTypeSetAndLock
    MODULE PROCEDURE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK
  END INTERFACE Field_DOFOrderTypeSetAndLock

  INTERFACE Field_GeometricFieldGet
    MODULE PROCEDURE FIELD_GEOMETRIC_FIELD_GET
  END INTERFACE Field_GeometricFieldGet

  INTERFACE Field_GeometricFieldSet
    MODULE PROCEDURE FIELD_GEOMETRIC_FIELD_SET
  END INTERFACE Field_GeometricFieldSet

  INTERFACE Field_GeometricFieldSetAndLock
    MODULE PROCEDURE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK
  END INTERFACE Field_GeometricFieldSetAndLock

  INTERFACE Field_InterpolateGauss
    MODULE PROCEDURE FIELD_INTERPOLATE_GAUSS
  END INTERFACE Field_InterpolateGauss

  INTERFACE Field_InterpolateXi
    MODULE PROCEDURE FIELD_INTERPOLATE_XI
  END INTERFACE Field_InterpolateXi

  INTERFACE Field_InterpolateNode
    MODULE PROCEDURE FIELD_INTERPOLATE_NODE
  END INTERFACE Field_InterpolateNode

  INTERFACE Field_InterpolateFieldNode
    MODULE PROCEDURE FIELD_INTERPOLATE_FIELD_NODE
  END INTERFACE Field_InterpolateFieldNode

  INTERFACE Field_InterpolateLocalFaceGauss
    MODULE PROCEDURE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS
  END INTERFACE Field_InterpolateLocalFaceGauss

  INTERFACE Field_InterpolatedPointMetricsCalculate
    MODULE PROCEDURE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE
  END INTERFACE Field_InterpolatedPointMetricsCalculate

  INTERFACE Field_InterpolatedPointsFinalise
    MODULE PROCEDURE FIELD_INTERPOLATED_POINTS_FINALISE
  END INTERFACE Field_InterpolatedPointsFinalise

  INTERFACE Field_InterpolatedPointsInitialise
    MODULE PROCEDURE FIELD_INTERPOLATED_POINTS_INITIALISE
  END INTERFACE Field_InterpolatedPointsInitialise

  INTERFACE Field_InterpolationParametersElementGet
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET
  END INTERFACE Field_InterpolationParametersElementGet

  INTERFACE Field_InterpolationParametersFinalise
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_FINALISE
  END INTERFACE Field_InterpolationParametersFinalise

  INTERFACE Field_InterpolationParametersInitialise
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_INITIALISE
  END INTERFACE Field_InterpolationParametersInitialise

  INTERFACE Field_InterpolationParametersFaceGet
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_FACE_GET
  END INTERFACE Field_InterpolationParametersFaceGet

  INTERFACE Field_InterpolationParametersLineGet
    MODULE PROCEDURE FIELD_INTERPOLATION_PARAMETERS_LINE_GET
  END INTERFACE Field_InterpolationParametersLineGet

  !>Gets the label for a field.
  INTERFACE FIELD_LABEL_GET
    MODULE PROCEDURE FIELD_LABEL_GET_C
    MODULE PROCEDURE FIELD_LABEL_GET_VS
  END INTERFACE FIELD_LABEL_GET

  !>Gets the label for a field.
  INTERFACE Field_LabelGet
    MODULE PROCEDURE FIELD_LABEL_GET_C
    MODULE PROCEDURE FIELD_LABEL_GET_VS
  END INTERFACE Field_LabelGet

  !>Sets/changes the label for a field.
  INTERFACE FIELD_LABEL_SET
    MODULE PROCEDURE FIELD_LABEL_SET_C
    MODULE PROCEDURE FIELD_LABEL_SET_VS
  END INTERFACE FIELD_LABEL_SET

  !>Sets/changes the label for a field.
  INTERFACE Field_LabelSet
    MODULE PROCEDURE FIELD_LABEL_SET_C
    MODULE PROCEDURE FIELD_LABEL_SET_VS
  END INTERFACE Field_LabelSet

  !>Sets/changes the label for a field and locks so that no further changes can be made.
  INTERFACE FIELD_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_VS
  END INTERFACE FIELD_LABEL_SET_AND_LOCK

  !>Sets/changes the label for a field and locks so that no further changes can be made.
  INTERFACE Field_LabelSetAndLock
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_VS
  END INTERFACE Field_LabelSetAndLock

  INTERFACE Field_MeshDecompositionGet
    MODULE PROCEDURE FIELD_MESH_DECOMPOSITION_GET
  END INTERFACE Field_MeshDecompositionGet

  INTERFACE Field_MeshDecompositionSet
    MODULE PROCEDURE FIELD_MESH_DECOMPOSITION_SET
  END INTERFACE Field_MeshDecompositionSet

  INTERFACE Field_MeshDecompositionSetAndLock
    MODULE PROCEDURE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK
  END INTERFACE Field_MeshDecompositionSetAndLock

  INTERFACE FIELD_NUMBER_OF_COMPONENTS_CHECK
    MODULE PROCEDURE Field_NumberOfComponentsCheck
  END INTERFACE FIELD_NUMBER_OF_COMPONENTS_CHECK

  INTERFACE FIELD_NUMBER_OF_COMPONENTS_GET
    MODULE PROCEDURE Field_NumberOfComponentsGet
  END INTERFACE FIELD_NUMBER_OF_COMPONENTS_GET

  INTERFACE Field_NumberOfComponentsSet
    MODULE PROCEDURE FIELD_NUMBER_OF_COMPONENTS_SET
  END INTERFACE Field_NumberOfComponentsSet

  INTERFACE Field_NumberOfComponentsSetAndLock
    MODULE PROCEDURE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK
  END INTERFACE Field_NumberOfComponentsSetAndLock

  INTERFACE Field_NumberOfVariablesCheck
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_CHECK
  END INTERFACE Field_NumberOfVariablesCheck

  INTERFACE Field_NumberOfVariablesGet
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_GET
  END INTERFACE Field_NumberOfVariablesGet

  INTERFACE Field_NumberOfVariablesSet
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_SET
  END INTERFACE Field_NumberOfVariablesSet

  INTERFACE Field_NumberOfVariablesSetAndLock
    MODULE PROCEDURE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK
  END INTERFACE Field_NumberOfVariablesSetAndLock

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE FIELD_PARAMETER_SETS_ADD
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP1
  END INTERFACE FIELD_PARAMETER_SETS_ADD

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE Field_ParameterSetsAdd
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP1
  END INTERFACE Field_ParameterSetsAdd

  INTERFACE FIELD_PARAMETER_SETS_COPY
    MODULE PROCEDURE Field_ParameterSetsCopy
  END INTERFACE FIELD_PARAMETER_SETS_COPY

  INTERFACE Field_ParameterSetDestroy
    MODULE PROCEDURE FIELD_PARAMETER_SET_DESTROY
  END INTERFACE Field_ParameterSetDestroy

  INTERFACE FIELD_PARAMETER_SET_GET
    MODULE PROCEDURE Field_ParameterSetGet
  END INTERFACE FIELD_PARAMETER_SET_GET

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_CONSTANT

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE Field_ParameterSetAddConstant
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_L
  END INTERFACE Field_ParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_DOF

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetAddLocalDOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L
  END INTERFACE Field_ParameterSetAddLocalDOF

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_ELEMENT

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE Field_ParameterSetAddElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_L
  END INTERFACE Field_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular Gauss point of a user element of the field variable component.
  INTERFACE Field_ParameterSetAddGaussPoint
    MODULE PROCEDURE Field_ParameterSetAddGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetAddGaussPointSP
    MODULE PROCEDURE Field_ParameterSetAddGaussPointDP
    MODULE PROCEDURE Field_ParameterSetAddGaussPointL
  END INTERFACE Field_ParameterSetAddGaussPoint

  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT

  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE Field_ParameterSetAddLocalElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L
  END INTERFACE Field_ParameterSetAddLocalElement

  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_NODE

  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetAddNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_L
  END INTERFACE Field_ParameterSetAddNode

  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_NODE

  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetAddLocalNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L
  END INTERFACE Field_ParameterSetAddLocalNode

  INTERFACE Field_ParameterSetCreate
    MODULE PROCEDURE FIELD_PARAMETER_SET_CREATE
  END INTERFACE Field_ParameterSetCreate

  INTERFACE Field_ParameterSetCreated
    MODULE PROCEDURE FIELD_PARAMETER_SET_CREATED
  END INTERFACE Field_ParameterSetCreated

  !>Returns a pointer to the specified field parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_PARAMETER_SET_UPDATE call must be used to change any values.
  INTERFACE FIELD_PARAMETER_SET_DATA_GET
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_L
  END INTERFACE FIELD_PARAMETER_SET_DATA_GET

  !>Returns a pointer to the specified field parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_PARAMETER_SET_UPDATE call must be used to change any values.
  INTERFACE Field_ParameterSetDataGet
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_L
  END INTERFACE Field_ParameterSetDataGet

  !>Restores the specified field variable parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET.
  INTERFACE FIELD_PARAMETER_SET_DATA_RESTORE
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_L
  END INTERFACE FIELD_PARAMETER_SET_DATA_RESTORE

  !>Restores the specified field variable parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET.
  INTERFACE Field_ParameterSetDataRestore
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_L
  END INTERFACE Field_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_L
  END INTERFACE FIELD_PARAMETER_SET_GET_CONSTANT

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE Field_ParameterSetGetConstant
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_L
  END INTERFACE Field_ParameterSetGetConstant

  !>Returns from the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetGetDataPoint
    MODULE PROCEDURE Field_ParameterSetGetDataPointIntg
    MODULE PROCEDURE Field_ParameterSetGetDataPointSp
    MODULE PROCEDURE Field_ParameterSetGetDataPointDp
    MODULE PROCEDURE Field_ParameterSetGetDataPointL
  END INTERFACE Field_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_GET_ELEMENT

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE Field_ParameterSetGetElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_L
  END INTERFACE Field_ParameterSetGetElement

  !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_GET_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L
  END INTERFACE FIELD_PARAMETER_SET_GET_LOCAL_DOF

  !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetGetLocalDOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L
  END INTERFACE Field_ParameterSetGetLocalDOF

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_GET_NODE

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_L
  END INTERFACE Field_ParameterSetGetNode

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalNode
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_Intg
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_Sp
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_Dp
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_L
  END INTERFACE Field_ParameterSetGetLocalNode

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalElement
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_Intg
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_Sp
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_Dp
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_L
  END INTERFACE Field_ParameterSetGetLocalElement

  !>Returns from the given parameter set a value for the specified Face, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalFace
    MODULE PROCEDURE Field_ParameterSetGetLocalFace_Intg
    MODULE PROCEDURE Field_ParameterSetGetLocalFace_Sp
    MODULE PROCEDURE Field_ParameterSetGetLocalFace_Dp
    MODULE PROCEDURE Field_ParameterSetGetLocalFace_L
  END INTERFACE Field_ParameterSetGetLocalFace

  !>Returns from the given parameter set a value for the specified Line, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalLine
    MODULE PROCEDURE Field_ParameterSetGetLocalLine_Intg
    MODULE PROCEDURE Field_ParameterSetGetLocalLine_Sp
    MODULE PROCEDURE Field_ParameterSetGetLocalLine_Dp
    MODULE PROCEDURE Field_ParameterSetGetLocalLine_L
  END INTERFACE Field_ParameterSetGetLocalLine

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE Field_ParameterSetGetGaussPoint
    MODULE PROCEDURE Field_ParameterSetGetGaussPointDP
  END INTERFACE Field_ParameterSetGetGaussPoint

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE FIELD_PARAMETER_SET_GET_GAUSS_POINT
    MODULE PROCEDURE Field_ParameterSetGetGaussPointDP
  END INTERFACE FIELD_PARAMETER_SET_GET_GAUSS_POINT

  !>Returns from the given parameter set a value for the specified local element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE Field_ParameterSetGetLocalGaussPoint
    MODULE PROCEDURE Field_ParameterSetGetLocalGaussPointDP
  END INTERFACE Field_ParameterSetGetLocalGaussPoint

  INTERFACE Field_ParameterSetOutput
    MODULE PROCEDURE FIELD_PARAMETER_SET_OUTPUT
  END INTERFACE Field_ParameterSetOutput

  INTERFACE Field_ParameterSetUpdateFinish
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_FINISH
  END INTERFACE Field_ParameterSetUpdateFinish

  INTERFACE Field_ParameterSetUpdateStart
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_START
  END INTERFACE Field_ParameterSetUpdateStart

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TOD  !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_CONSTANT

  !>Returns from the given parameter set a value for the specified user element and Gauss point of a field variable component.  TOD  !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE Field_ParameterSetUpdateConstant
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L
  END INTERFACE Field_ParameterSetUpdateConstant

  !>Updates the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointL
  END INTERFACE Field_ParameterSetUpdateDataPoint

  !>Updates the given parameter set a value for the specified local data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateLocalDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateLocalDataPointL
  END INTERFACE Field_ParameterSetUpdateLocalDataPoint

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE Field_ParameterSetUpdateLocalDOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L
  END INTERFACE Field_ParameterSetUpdateLocalDOF

  !>Updates the given parameter set with the given values for all local dofs of the field variable.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS

  !>Updates the given parameter set with the given values for all local dofs of the field variable.
  INTERFACE Field_ParameterSetUpdateLocalDOFS
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP
  END INTERFACE Field_ParameterSetUpdateLocalDOFS

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_ELEMENT

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE Field_ParameterSetUpdateElement
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L
  END INTERFACE Field_ParameterSetUpdateElement

  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementIntg
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT

  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalElement
    MODULE PROCEDURE Field_ParameterSetUpdateLocalElementIntg
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L
  END INTERFACE Field_ParameterSetUpdateLocalElement

  !>Updates the given parameter set with the given value for a particular face with user element number and xi direction of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_FACE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_FACE_INTG
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_FACE

  !>Updates the given parameter set with the given value for a particular face with user element number and xi direction of the field variable component.
  INTERFACE Field_ParameterSetUpdateFace
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_FACE_INTG
  END INTERFACE Field_ParameterSetUpdateFace

  !>Updates the given parameter set with the given value for a particular line with user element number and xi direction of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LINE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LINE_INTG
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LINE

  !>Updates the given parameter set with the given value for a particular line with user element number and xi direction of the field variable component.
  INTERFACE Field_ParameterSetUpdateLine
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LINE_INTG
  END INTERFACE Field_ParameterSetUpdateLine

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_NODE

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetUpdateNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_L
  END INTERFACE Field_ParameterSetUpdateNode

  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE

  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalNode
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L
  END INTERFACE Field_ParameterSetUpdateLocalNode

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component.
  INTERFACE Field_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointL
  END INTERFACE Field_ParameterSetUpdateGaussPoint

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointSP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointDP
    MODULE PROCEDURE Field_ParameterSetUpdateGaussPointL
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT

  !>Updates the given parameter set with the given value for a particular local element and gauss point of the field variable component.
  INTERFACE Field_ParameterSetUpdateLocalGaussPoint
    MODULE PROCEDURE Field_ParameterSetUpdateLocalGaussPointDP
  END INTERFACE Field_ParameterSetUpdateLocalGaussPoint

  !>Updates the given parameter set with the given value for a particular element and data point of the field variable component. TODO: sp/int/l versions
  INTERFACE Field_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointDP
  END INTERFACE Field_ParameterSetUpdateElementDataPoint

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI
    MODULE PROCEDURE Field_ParameterSetInterpolateSingleXiDP
  END INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE Field_ParameterSetInterpolateSingleXi
    MODULE PROCEDURE Field_ParameterSetInterpolateSingleXiDP
  END INTERFACE Field_ParameterSetInterpolateSingleXi

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI
    MODULE PROCEDURE Field_ParameterSetInterpolateMultipleXiDP
  END INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE Field_ParameterSetInterpolateMultipleXi
    MODULE PROCEDURE Field_ParameterSetInterpolateMultipleXiDP
  END INTERFACE Field_ParameterSetInterpolateMultipleXi

  !>Interpolates the given parameter set at the specified gauss point number for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS
    MODULE PROCEDURE Field_ParameterSetInterpolateSingleGaussDP
  END INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS

  !>Interpolates the given parameter set at the specified gauss point number for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE Field_ParameterSetInterpolateSingleGauss
    MODULE PROCEDURE Field_ParameterSetInterpolateSingleGaussDP
  END INTERFACE Field_ParameterSetInterpolateSingleGauss

  !>Interpolates the given parameter set at the specified gauss point numbers for the specified element and derviative. If no Gauss points are specified then all Gauss points are interpolated. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS
    MODULE PROCEDURE Field_ParameterSetInterpolateMultipleGaussDP
  END INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS

  !>Interpolates the given parameter set at the specified gauss point numbers for the specified element and derviative. If no Gauss points are specified then all Gauss points are interpolated. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE Field_ParameterSetInterpoalteMultipleGauss
    MODULE PROCEDURE Field_ParameterSetInterpolateMultipleGaussDP
  END INTERFACE Field_ParameterSetInterpoalteMultipleGauss

  INTERFACE Field_ParameterSetVectorGet
    MODULE PROCEDURE FIELD_PARAMETER_SET_VECTOR_GET
  END INTERFACE Field_ParameterSetVectorGet

  INTERFACE Field_PhysicalPointsFinalise
    MODULE PROCEDURE FIELD_PHYSICAL_POINTS_FINALISE
  END INTERFACE Field_PhysicalPointsFinalise

  INTERFACE Field_PhysicalPointsInitialise
    MODULE PROCEDURE FIELD_PHYSICAL_POINTS_INITIALISE
  END INTERFACE Field_PhysicalPointsInitialise

  INTERFACE Field_ScalingTypeCheck
    MODULE PROCEDURE FIELD_SCALING_TYPE_CHECK
  END INTERFACE Field_ScalingTypeCheck

  INTERFACE Field_ScalingTypeGet
    MODULE PROCEDURE FIELD_SCALING_TYPE_GET
  END INTERFACE Field_ScalingTypeGet

  INTERFACE Field_ScalingTypeSet
    MODULE PROCEDURE FIELD_SCALING_TYPE_SET
  END INTERFACE Field_ScalingTypeSet

  INTERFACE Field_ScalingTypeSetAndLock
    MODULE PROCEDURE FIELD_SCALING_TYPE_SET_AND_LOCK
  END INTERFACE Field_ScalingTypeSetAndLock

  INTERFACE Field_TypeCheck
    MODULE PROCEDURE FIELD_TYPE_CHECK
  END INTERFACE Field_TypeCheck

  INTERFACE Field_TypeGet
    MODULE PROCEDURE FIELD_TYPE_GET
  END INTERFACE Field_TypeGet

  INTERFACE Field_TypeSet
    MODULE PROCEDURE FIELD_TYPE_SET
  END INTERFACE Field_TypeSet

  INTERFACE Field_TypeSetAndLock
    MODULE PROCEDURE FIELD_TYPE_SET_AND_LOCK
  END INTERFACE Field_TypeSetAndLock

  !>Gets the label for a field variable type.
  INTERFACE FIELD_VARIABLE_LABEL_GET
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_VS
  END INTERFACE FIELD_VARIABLE_LABEL_GET

  !>Gets the label for a field variable type.
  INTERFACE Field_VariableLabelGet
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_VS
  END INTERFACE Field_VariableLabelGet

  !>Sets/changes the label for a field variable type.
  INTERFACE FIELD_VARIABLE_LABEL_SET
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_VS
  END INTERFACE FIELD_VARIABLE_LABEL_SET

  !>Sets/changes the label for a field variable type.
  INTERFACE Field_VariableLabelSet
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_VS
  END INTERFACE Field_VariableLabelSet

  !>Sets/changes the label for a field variable type and locks so that no further changes can be made.
  INTERFACE FIELD_VARIABLE_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS
  END INTERFACE FIELD_VARIABLE_LABEL_SET_AND_LOCK

  !>Sets/changes the label for a field variable type and locks so that no further changes can be made.
  INTERFACE Field_VariableLabelSetAndLock
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS
  END INTERFACE Field_VariableLabelSetAndLock

  INTERFACE Field_VariableTypeCheck
    MODULE PROCEDURE FIELD_VARIABLE_TYPE_CHECK
  END INTERFACE Field_VariableTypeCheck

  INTERFACE Field_VariableTypesCheck
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_CHECK
  END INTERFACE Field_VariableTypesCheck

  INTERFACE Field_VariableTypesGet
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_GET
  END INTERFACE Field_VariableTypesGet

  INTERFACE Field_VariableTypesSet
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_SET
  END INTERFACE Field_VariableTypesSet

  INTERFACE Field_VariableTypesSetAndLock
    MODULE PROCEDURE FIELD_VARIABLE_TYPES_SET_AND_LOCK
  END INTERFACE Field_VariableTypesSetAndLock

  !>Initialises the fields.
  INTERFACE Fields_Initialise
    MODULE PROCEDURE FIELDS_INITIALISE_INTERFACE
    MODULE PROCEDURE FIELDS_INITIALISE_REGION
  END INTERFACE Fields_Initialise

  PUBLIC FIELD_INDEPENDENT_TYPE,FIELD_DEPENDENT_TYPE

  PUBLIC FIELD_SCALAR_DIMENSION_TYPE,FIELD_VECTOR_DIMENSION_TYPE,FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE

  PUBLIC FIELD_CONSTANT_INTERPOLATION,FIELD_ELEMENT_BASED_INTERPOLATION,FIELD_NODE_BASED_INTERPOLATION, &
    & FIELD_GRID_POINT_BASED_INTERPOLATION,FIELD_GAUSS_POINT_BASED_INTERPOLATION,FIELD_DATA_POINT_BASED_INTERPOLATION, &
    & FIELD_FACE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION, FIELD_LINE_BASED_INTERPOLATION, &
    & FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION

  PUBLIC FIELD_CONSTANT_DOF_TYPE,FIELD_ELEMENT_DOF_TYPE,FIELD_NODE_DOF_TYPE,FIELD_GRID_POINT_DOF_TYPE,FIELD_GAUSS_POINT_DOF_TYPE, &
    & FIELD_DATA_POINT_DOF_TYPE, FIELD_FACE_DOF_TYPE, FIELD_LINE_DOF_TYPE

  PUBLIC FIELD_INTG_TYPE,FIELD_SP_TYPE,FIELD_DP_TYPE,FIELD_L_TYPE

  PUBLIC FIELD_SEPARATED_COMPONENT_DOF_ORDER,FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC FIELD_NO_SCALING,FIELD_UNIT_SCALING,FIELD_ARC_LENGTH_SCALING,FIELD_HARMONIC_MEAN_SCALING,FIELD_ARITHMETIC_MEAN_SCALING, &
    & FIELD_GEOMETRIC_MEAN_SCALING

  PUBLIC FIELD_ALL_COMPONENTS_TYPE,FIELD_GEOMETRIC_COMPONENTS_TYPE,FIELD_NONGEOMETRIC_COMPONENTS_TYPE

  PUBLIC FIELD_COMPONENT_DOF_GET_CONSTANT,FIELD_COMPONENT_DOF_GET_USER_ELEMENT,FIELD_COMPONENT_DOF_GET_USER_NODE, &
    & Field_componentDofGetUserDataPoint, FIELD_COMPONENT_DOF_GET_USER_FACE, FIELD_COMPONENT_DOF_GET_USER_LINE

  PUBLIC FIELD_COMPONENT_INTERPOLATION_CHECK,FIELD_COMPONENT_INTERPOLATION_SET,FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK

  PUBLIC Field_ComponentInterpolationCheck,Field_ComponentInterpolationSet,Field_ComponentInterpolationSetAndLock

  PUBLIC FIELD_COMPONENT_LABEL_GET,FIELD_COMPONENT_LABEL_SET,FIELD_COMPONENT_LABEL_SET_AND_LOCK

  PUBLIC Field_ComponentLabelGet,Field_ComponentLabelSet,Field_ComponentLabelSetAndLock

  PUBLIC FIELD_COMPONENT_MESH_COMPONENT_CHECK,FIELD_COMPONENT_MESH_COMPONENT_GET,FIELD_COMPONENT_MESH_COMPONENT_SET, &
    & FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK

  PUBLIC Field_ComponentMeshComponentCheck,Field_ComponentMeshComponentGet,Field_ComponentMeshComponentSet, &
    & Field_ComponentMeshComponentSetAndLock

  PUBLIC FIELD_COMPONENT_VALUES_INITIALISE

  PUBLIC Field_ComponentValuesInitialise

  PUBLIC FIELD_CREATE_FINISH,FIELD_CREATE_START

  PUBLIC Field_CreateFinish,Field_CreateStart

  PUBLIC Field_DataProjectionSet

  PUBLIC FIELD_DATA_TYPE_CHECK,FIELD_DATA_TYPE_GET,FIELD_DATA_TYPE_SET,FIELD_DATA_TYPE_SET_AND_LOCK

  PUBLIC Field_DataTypeCheck,Field_DataTypeGet,Field_DataTypeSet,Field_DataTypeSetAndLock

  PUBLIC Field_Destroy

  PUBLIC FIELD_DEPENDENT_TYPE_CHECK,FIELD_DEPENDENT_TYPE_GET,FIELD_DEPENDENT_TYPE_SET,FIELD_DEPENDENT_TYPE_SET_AND_LOCK

  PUBLIC Field_DependentTypeCheck,Field_DependentTypeGet,Field_DependentTypeSet,Field_DependentTypeSetAndLock

  PUBLIC FIELD_DIMENSION_CHECK,FIELD_DIMENSION_GET,FIELD_DIMENSION_SET,FIELD_DIMENSION_SET_AND_LOCK

  PUBLIC Field_DimensionCheck,Field_DimensionGet,Field_DimensionSet,Field_DimensionSetAndLock

  PUBLIC FIELD_DOF_ORDER_TYPE_CHECK,FIELD_DOF_ORDER_TYPE_GET,FIELD_DOF_ORDER_TYPE_SET,FIELD_DOF_ORDER_TYPE_SET_AND_LOCK

  PUBLIC Field_DOFOrderTypeCheck,Field_DOFOrderTypeGet,Field_DOFOrderTypeSet,Field_DOFOrderTypeSetAndLock

  PUBLIC Field_GeometricGeneralFieldGet

  PUBLIC FIELD_GEOMETRIC_FIELD_GET,FIELD_GEOMETRIC_FIELD_SET,FIELD_GEOMETRIC_FIELD_SET_AND_LOCK

  PUBLIC Field_GeometricFieldGet,Field_GeometricFieldSet,Field_GeometricFieldSetAndLock

  PUBLIC Field_GeometricParametersElementLineLengthGet, Field_GeometricParametersElementVolumeGet

  PUBLIC FIELD_INTERPOLATE_GAUSS,FIELD_INTERPOLATE_XI,FIELD_INTERPOLATE_NODE,FIELD_INTERPOLATE_FIELD_NODE, &
    & FIELD_INTERPOLATE_LOCAL_FACE_GAUSS

  PUBLIC Field_InterpolateGauss,Field_InterpolateXi,Field_InterpolateNode,Field_InterpolateFieldNode,Field_InterpolateLocalFaceGauss

  PUBLIC Field_PositionNormalTangentsCalculateIntPtMetric,Field_PositionNormalTangentsCalculateNode

  PUBLIC FIELD_INTERPOLATED_POINT_METRICS_CALCULATE

  PUBLIC Field_InterpolatedPointMetricsCalculate,Field_InterpolatedPointsMetricsFinalise,Field_InterpolatedPointsMetricsInitialise

  PUBLIC FIELD_INTERPOLATED_POINTS_FINALISE,FIELD_INTERPOLATED_POINTS_INITIALISE

  PUBLIC Field_InterpolatedPointsFinalise,Field_InterpolatedPointsInitialise

  PUBLIC FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET,FIELD_INTERPOLATION_PARAMETERS_FINALISE, &
    & FIELD_INTERPOLATION_PARAMETERS_INITIALISE,FIELD_INTERPOLATION_PARAMETERS_LINE_GET, &
    & FIELD_INTERPOLATION_PARAMETERS_FACE_GET

  PUBLIC Field_InterpolationParametersFinalise,Field_InterpolationParametersInitialise

  PUBLIC Field_InterpolationParametersElementGet,Field_InterpolationParametersFaceGet,Field_InterpolationParametersLineGet

  PUBLIC Field_InterpolationParametersScaleFactorsElementGet,Field_InterpolationParametersScaleFactorsLineGet, &
    & Field_InterpolationParametersScaleFactorsFaceGet

  PUBLIC FIELD_LABEL_GET,FIELD_LABEL_SET,FIELD_LABEL_SET_AND_LOCK

  PUBLIC Field_LabelGet,Field_LabelSet,Field_LabelSetAndLock

  PUBLIC FIELD_MESH_DECOMPOSITION_GET,FIELD_MESH_DECOMPOSITION_SET,FIELD_MESH_DECOMPOSITION_SET_AND_LOCK

  PUBLIC Field_MeshDecompositionGet,Field_MeshDecompositionSet,Field_MeshDecompositionSetAndLock

  PUBLIC FIELD_NUMBER_OF_COMPONENTS_CHECK,FIELD_NUMBER_OF_COMPONENTS_GET,FIELD_NUMBER_OF_COMPONENTS_SET, &
    & FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK

  PUBLIC Field_NumberOfComponentsCheck,Field_NumberOfComponentsGet,Field_NumberOfComponentsSet,Field_NumberOfComponentsSetAndLock

  PUBLIC FIELD_NUMBER_OF_VARIABLES_CHECK,FIELD_NUMBER_OF_VARIABLES_GET,FIELD_NUMBER_OF_VARIABLES_SET, &
    & FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK

  PUBLIC Field_NumberOfVariablesCheck,Field_NumberOfVariablesGet,Field_NumberOfVariablesSet,Field_NumberOfVariablesSetAndLock

  PUBLIC FIELD_PARAMETER_SETS_ADD

  PUBLIC Field_ParameterSetsAdd

  PUBLIC FIELD_PARAMETER_SETS_COPY

  PUBLIC Field_ParameterSetsCopy

  PUBLIC Field_ParameterSetsCopyIfExists

  PUBLIC FIELD_PARAMETER_SET_DESTROY

  PUBLIC Field_ParameterSetDestroy

  PUBLIC Field_ParametersToFieldParametersCopy

  PUBLIC FIELD_PARAMETER_SET_GET

  PUBLIC Field_ParameterSetGet

  PUBLIC FIELD_PARAMETER_SET_ADD_CONSTANT,FIELD_PARAMETER_SET_ADD_LOCAL_DOF,FIELD_PARAMETER_SET_ADD_ELEMENT, &
    & FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT,FIELD_PARAMETER_SET_ADD_NODE,FIELD_PARAMETER_SET_ADD_LOCAL_NODE

  PUBLIC Field_ParameterSetAddConstant,Field_ParameterSetAddLocalDOF,Field_ParameterSetAddElement, &
    & Field_ParameterSetAddGaussPoint,Field_ParameterSetAddLocalElement,Field_ParameterSetAddNode, &
    & Field_ParameterSetAddLocalNode

  PUBLIC FIELD_PARAMETER_SET_CREATE

  PUBLIC Field_ParameterSetCreate

  PUBLIC FIELD_PARAMETER_SET_CREATED

  PUBLIC Field_ParameterSetEnsureCreated,Field_ParameterSetCreated

  PUBLIC FIELD_PARAMETER_SET_DATA_GET,FIELD_PARAMETER_SET_DATA_RESTORE

  PUBLIC Field_ParameterSetDataGet,Field_ParameterSetDataRestore

  PUBLIC FIELD_PARAMETER_SET_GET_CONSTANT,FIELD_PARAMETER_SET_GET_ELEMENT, &
    & FIELD_PARAMETER_SET_GET_LOCAL_DOF,FIELD_PARAMETER_SET_GET_NODE, &
    & FIELD_PARAMETER_SET_GET_GAUSS_POINT

  PUBLIC Field_ParameterSetGetConstant,Field_ParameterSetGetDataPoint,Field_ParameterSetGetElement, &
    & Field_ParameterSetGetLocalElement,Field_ParameterSetGetLocalDOF,Field_ParameterSetGetNode, &
    & Field_ParameterSetGetLocalNode,Field_ParameterSetGetGaussPoint,Field_ParameterSetGetLocalGaussPoint, &
    & Field_ParameterSetGetLocalFace, Field_ParameterSetGetLocalLine

  PUBLIC FIELD_PARAMETER_SET_OUTPUT

  PUBLIC Field_ParameterSetOutput

  PUBLIC FIELD_PARAMETER_SET_UPDATE_FINISH,FIELD_PARAMETER_SET_UPDATE_START

  PUBLIC Field_ParameterSetUpdateFinish,Field_ParameterSetUpdateStart

  PUBLIC FIELD_PARAMETER_SET_UPDATE_CONSTANT,FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF,FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS, &
    & FIELD_PARAMETER_SET_UPDATE_ELEMENT,FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT,FIELD_PARAMETER_SET_UPDATE_NODE, &
    & FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE,FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT, FIELD_PARAMETER_SET_UPDATE_LINE, &
    & FIELD_PARAMETER_SET_UPDATE_FACE

  PUBLIC Field_ParameterSetUpdateConstant, &
    & Field_ParameterSetUpdateDataPoint,Field_ParameterSetUpdateLocalDataPoint, &
    & Field_ParameterSetUpdateElement,Field_ParameterSetUpdateLocalElement,Field_ParameterSetUpdateElementDataPoint, &
    & Field_ParameterSetUpdateGaussPoint,Field_ParameterSetUpdateLocalGaussPoint, &
    & Field_ParameterSetUpdateLocalDOF,Field_ParameterSetUpdateLocalDOFS, &
    & Field_ParameterSetUpdateNode,Field_ParameterSetUpdateLocalNode,Field_ParameterSetUpdateLine, &
    & Field_ParameterSetUpdateFace

  PUBLIC Field_ParameterSetNodeScaleFactorGet,Field_ParameterSetNodeScaleFactorSet, &
    & Field_ParameterSetNodeScaleFactorsGet,Field_ParameterSetNodeScaleFactorsSet, &
    & Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI, FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI

  PUBLIC Field_ParameterSetInterpolateSingleXi,Field_ParameterSetInterpolateMultipleXi

  PUBLIC FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS, FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS

  PUBLIC Field_ParameterSetInterpolateSingleGauss,Field_ParameterSetInterpoalteMultipleGauss

  PUBLIC FIELD_PARAMETER_SET_VECTOR_GET

  PUBLIC Field_ParameterSetVectorGet

  PUBLIC FIELD_PHYSICAL_POINTS_FINALISE,FIELD_PHYSICAL_POINTS_INITIALISE

  PUBLIC Field_PhysicalPointsFinalise,Field_PhysicalPointsInitialise

  PUBLIC FIELD_SCALING_TYPE_CHECK,FIELD_SCALING_TYPE_GET,FIELD_SCALING_TYPE_SET,FIELD_SCALING_TYPE_SET_AND_LOCK

  PUBLIC Field_ScalingTypeCheck,Field_ScalingTypeGet,Field_ScalingTypeSet,Field_ScalingTypeSetAndLock

  PUBLIC FIELD_TYPE_CHECK,FIELD_TYPE_GET,FIELD_TYPE_SET,FIELD_TYPE_SET_AND_LOCK

  PUBLIC Field_TypeCheck,Field_TypeGet,Field_TypeSet,Field_TypeSetAndLock

  PUBLIC FIELD_VARIABLE_LABEL_GET,FIELD_VARIABLE_LABEL_SET,FIELD_VARIABLE_LABEL_SET_AND_LOCK

  PUBLIC Field_VariableLabelGet,Field_VariableLabelSet,Field_VariableLabelSetAndLock

  PUBLIC FIELD_VARIABLE_TYPE_CHECK

  PUBLIC Field_VariableTypeCheck

  PUBLIC FIELD_VARIABLE_TYPES_CHECK,FIELD_VARIABLE_TYPES_GET,FIELD_VARIABLE_TYPES_SET,FIELD_VARIABLE_TYPES_SET_AND_LOCK

  PUBLIC Field_VariableTypesCheck,Field_VariableTypesGet,Field_VariableTypesSet,Field_VariableTypesSetAndLock

  PUBLIC FieldVariable_ParameterSetsCopy

  PUBLIC FieldVariable_ParameterSetsCopyIfExists

  PUBLIC FieldVariable_ParameterSetGet

  PUBLIC Fields_Finalise,Fields_Initialise

  PUBLIC MESH_EMBEDDING_PUSH_DATA, MESH_EMBEDDING_PULL_GAUSS_POINT_DATA, FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD

CONTAINS

  !
  !================================================================================================================================
  !

  !>Checks the interpolation type for a field variable component.
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_CHECK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to check
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type of the field variable component to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_INTERPOLATION_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_CONSTANT_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not constant interpolation."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_ELEMENT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not element based interpolation."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_NODE_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not node based interpolation."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_GRID_POINT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not grid point based interpolation."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_GAUSS_POINT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not Gauss point based interpolation."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_DATA_POINT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not data point based interpolation."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="The specified interpolation type of "//TRIM(NumberToVString(INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_INTERPOLATION_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_INTERPOLATION_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_CHECK

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component. \see OpenCMISS::Iron::cmfe_FieldComponentInterpolationSet
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type to set \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_INTERPOLATION_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                IF(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                  LOCAL_ERROR="The interpolation type has been locked for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ELSE
                  SELECT CASE(INTERPOLATION_TYPE)
                  CASE(FIELD_CONSTANT_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_FACE_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_LINE_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE DEFAULT
                    LOCAL_ERROR="The specified interpolation type of "// &
                      & TRIM(NumberToVString(INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                ENDIF
              ELSE
                LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                  & TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                  & " components."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_INTERPOLATION_SET")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_INTERPOLATION_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type to set \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field variable component that corresponds to the specified constant
  SUBROUTINE FIELD_COMPONENT_DOF_GET_CONSTANT(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the constant
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the constant
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_DOF_GET_CONSTANT",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                  LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                  GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                ELSE
                  LOCAL_ERROR="The field variable domain mapping is not associated for variable type "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_DOF_GET_CONSTANT")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_CONSTANT",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_CONSTANT

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field component that corresponds to the specified user data point.
  SUBROUTINE Field_componentDofGetUserDataPoint(field,variableType,userDataPointNumber,componentNumber,localDof, &
    & globalDof,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The user data point number to get the dof for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: localDof !<On exit, the local dof corresponding to the user data point
    INTEGER(INTG), INTENT(OUT) :: globalDof !<On exit, the global dof corresponding to the user data point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostDataPoint,userDataPointExists
    INTEGER(INTG) :: decompositionLocalDataPointNumber
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_componentDofGetUserDataPoint",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>FIELD%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                CALL FLAG_error(localError,err,error,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                CALL FlagError(localError,err,error,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                decomposition=>fieldVariable%COMPONENTS(componentNumber)%DOMAIN%DECOMPOSITION
                IF(ASSOCIATED(decomposition)) THEN
                  decompositionTopology=>decomposition%TOPOLOGY
                  userDataPointExists=.TRUE.
                  IF(ASSOCIATED(decompositionTopology)) THEN
                    CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber,userDataPointExists, &
                      & decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                    IF(userDataPointExists) THEN
                      localDof=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                        & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                      globalDof=fieldVariable%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(localDof)
                    ELSE
                      localError="The specified user data point number of "// &
                        & TRIM(NumberToVString(userDataPointNumber,"*",err,error))// &
                        & " does not exist in the domain for field component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Decomposition topology is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Decomposition is not associated.",err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                  & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                  & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                  & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              END SELECT
            ELSE
              localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has "// &
                & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                & " components."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_componentDofGetUserDataPoint")
    RETURN
999 ERRORSEXITS("Field_componentDofGetUserDataPoint",err,error)
    RETURN 1
  END SUBROUTINE Field_componentDofGetUserDataPoint

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field component that corresponds to the specified user element.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_ELEMENT(FIELD,VARIABLE_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,LOCAL_DOF, &
    & GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to get the dof for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                DECOMPOSITION=>FIELD%DECOMPOSITION
                IF(ASSOCIATED(DECOMPOSITION)) THEN
                  DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                  CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                    & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                  IF(USER_ELEMENT_EXISTS) THEN
                    IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                      LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                        & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                      GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                    ELSE
                      CALL FlagError("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The specified user element number of "// &
                      & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " does not exist in the decomposition for field component number "// &
                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_ELEMENT

  !
  !================================================================================================================================
  !


  !>Returns the dof numbers for a field component that corresponds to the specified user element.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_FACE(FIELD,VARIABLE_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & userElementNumber, userXiDir,COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the dof for
    INTEGER(INTG), INTENT(IN) :: userXiDir !<The user xi direction to get the face for, from this element
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER, faceLocalNo, myComputationalNodeNumber, faceBasisLocalNo,faceGlobalNo, &
      & lineLocalNo, lineBasisLocalNo,lineGlobalNo
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: DOMAIN_ELEMENT
    TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: DECOMPOSITION_ELEMENT
    TYPE(BASIS_TYPE), POINTER :: ELEMENT_BASIS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_DOF_GET_USER_FACE",ERR,ERROR,*999)


    myComputationalNodeNumber=ComputationalEnvironment_NodeNumberGet(ERR,ERROR)
    IF(ERR/=0) GOTO 999

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ! CASE(FIELD_FACE_BASED_INTERPOLATION)
              !   LOCAL_ERROR="Can not get the dof by user element for component number "// &
              !     & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
              !     & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
              !     & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has face based interpolation."
              !   CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has line based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION, FIELD_FACE_BASED_INTERPOLATION)
                DECOMPOSITION=>FIELD%DECOMPOSITION
                IF(.NOT. ASSOCIATED(DECOMPOSITION)) CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)

                DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,userElementNumber, &
                  & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)

                IF(USER_ELEMENT_EXISTS) THEN
                  !Here we must find the local face number from the local element number and the xi direction.
                  !We do this using basis%xiNormalLocalFace
                  DECOMPOSITION_ELEMENT=>DECOMPOSITION_TOPOLOGY%ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                  IF(.NOT. ASSOCIATED(DECOMPOSITION_ELEMENT)) CALL FlagError("decomposition element is not associated.", &
                    & ERR,ERROR,*999)
                  DOMAIN=>DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
                  IF(.NOT. ASSOCIATED(DOMAIN)) CALL FlagError("domain is not associated.",ERR,ERROR,*999)
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  IF(.NOT. ASSOCIATED(DOMAIN_TOPOLOGY)) CALL FlagError("domain topology is not associated.",ERR,ERROR,*999)
                  DOMAIN_ELEMENT=>DOMAIN_TOPOLOGY%ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                  IF(.NOT. ASSOCIATED(DOMAIN_ELEMENT)) CALL FlagError("domain element is not associated.",ERR,ERROR,*999)
                  ELEMENT_BASIS=>DOMAIN_ELEMENT%BASIS
                  IF(.NOT. ASSOCIATED(ELEMENT_BASIS)) CALL FlagError("element basis is not associated.",ERR,ERROR,*999)

                  !FIXTHIS, get faces should probably have its own subroutine
                  faceBasisLocalNo=ELEMENT_BASIS%xiNormalLocalFace(userXiDir)

                  IF(DECOMPOSITION%numberOfDimensions==3) THEN
                    faceLocalNo=DECOMPOSITION_ELEMENT%ELEMENT_FACES(faceBasisLocalNo)
                  ELSE
                    CALL FlagError("number of dimensions must = 3 for faces",ERR,ERROR,*999)
                  ENDIF
                  !FIXTHIS should include a check here for the face being a boundary face!!!!!
                  faceGlobalNo=DOMAIN%MAPPINGS%FACES%LOCAL_TO_GLOBAL_MAP(faceLocalNo)
                  IF(DECOMPOSITION_TOPOLOGY%faces%faces(faceLocalNo)%BOUNDARY_FACE) THEN
                    !do nothing
                  ELSE
                    LOCAL_ERROR="The external face with global number of " // &
                      & TRIM(NumberToVString(faceGlobalNo,"*",ERR,ERROR)) // " is not a boundary face"
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                  !Now find the local dof number from the face local number

                  IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                    LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                      & FACE_PARAM2DOF_MAP%FACES(faceLocalNo)%DERIVATIVES(DERIVATIVE_NUMBER)%VERSIONS(VERSION_NUMBER)
                    GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                  ELSE
                    CALL FlagError("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The specified user element number of "// &
                    & TRIM(NumberToVString(userElementNumber,"*",ERR,ERROR))// &
                    & " does not exist in the decomposition for field component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                DECOMPOSITION=>FIELD%DECOMPOSITION
                IF(.NOT. ASSOCIATED(DECOMPOSITION)) CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)

                DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,userElementNumber, &
                  & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)

                IF(USER_ELEMENT_EXISTS) THEN
                  !Here we must find the local line number from the local element number and the xi direction.
                  !We do this using basis%xiNormalsLocalLine
                  DECOMPOSITION_ELEMENT=>DECOMPOSITION_TOPOLOGY%ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                  IF(.NOT. ASSOCIATED(DECOMPOSITION_ELEMENT)) CALL FlagError("decomposition element is not associated.", &
                    & ERR,ERROR,*999)
                  DOMAIN=>DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
                  IF(.NOT. ASSOCIATED(DOMAIN)) CALL FlagError("domain is not associated.",ERR,ERROR,*999)
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  IF(.NOT. ASSOCIATED(DOMAIN_TOPOLOGY)) CALL FlagError("domain topology is not associated.",ERR,ERROR,*999)
                  DOMAIN_ELEMENT=>DOMAIN_TOPOLOGY%ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                  IF(.NOT. ASSOCIATED(DOMAIN_ELEMENT)) CALL FlagError("domain element is not associated.",ERR,ERROR,*999)
                  ELEMENT_BASIS=>DOMAIN_ELEMENT%BASIS
                  IF(.NOT. ASSOCIATED(ELEMENT_BASIS)) CALL FlagError("element basis is not associated.",ERR,ERROR,*999)

                  !FIXTHIS, get lines should probably have its own subroutine
                  lineBasisLocalNo=ELEMENT_BASIS%xiNormalsLocalLine(userXiDir,1)

                  IF(DECOMPOSITION%numberOfDimensions==2) THEN
                    lineLocalNo=DECOMPOSITION_ELEMENT%ELEMENT_LINES(lineBasisLocalNo)
                  ELSE
                    CALL FlagError("number of dimensions must = 2 for lines",ERR,ERROR,*999)
                  ENDIF
                  !FIXTHIS should include a check here for the line being a boundary line!!!!!
                  lineGlobalNo=DOMAIN%MAPPINGS%LINES%LOCAL_TO_GLOBAL_MAP(lineLocalNo)
                  IF(DECOMPOSITION_TOPOLOGY%lines%lines(lineLocalNo)%BOUNDARY_LINE) THEN
                    !do nothing
                  ELSE
                    LOCAL_ERROR="The external line with global number of " // &
                      & TRIM(NumberToVString(lineGlobalNo,"*",ERR,ERROR)) // " is not a boundary line"
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                  !Now find the local dof number from the line local number

                  IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                    LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                      & LINE_PARAM2DOF_MAP%LINES(lineLocalNo)%DERIVATIVES(DERIVATIVE_NUMBER)%VERSIONS(VERSION_NUMBER)
                    GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                  ELSE
                    CALL FlagError("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The specified user element number of "// &
                    & TRIM(NumberToVString(userElementNumber,"*",ERR,ERROR))// &
                    & " does not exist in the decomposition for field component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_DOF_GET_USER_FACE")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_USER_FACE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_FACE

  !
  !================================================================================================================================
  !


  !>Returns the dof numbers for a field component that corresponds to the specified user element.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_LINE(FIELD,VARIABLE_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & userElementNumber, userXiDir,COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the dof for
    INTEGER(INTG), INTENT(IN) :: userXiDir !<The user xi direction to get the face for, from this element
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER, lineLocalNo, myComputationalNodeNumber, lineBasisLocalNo,lineGlobalNo
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: DOMAIN_ELEMENT
    TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: DECOMPOSITION_ELEMENT
    TYPE(BASIS_TYPE), POINTER :: ELEMENT_BASIS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_DOF_GET_USER_LINE",ERR,ERROR,*999)


    myComputationalNodeNumber=ComputationalEnvironment_NodeNumberGet(ERR,ERROR)
    IF(ERR/=0) GOTO 999

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has face based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ! CASE(FIELD_LINE_BASED_INTERPOLATION)
              !   !!!!!
              !   CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !   !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element and ext face based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION, FIELD_LINE_BASED_INTERPOLATION)
                DECOMPOSITION=>FIELD%DECOMPOSITION
                IF(.NOT. ASSOCIATED(DECOMPOSITION)) CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)

                DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,userElementNumber, &
                  & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)

                IF(USER_ELEMENT_EXISTS) THEN
                  !Here we must find the local line number from the local element number and the xi direction.
                  !We do this using basis%xiNormalLocalLine
                  DECOMPOSITION_ELEMENT=>DECOMPOSITION_TOPOLOGY%ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                  IF(.NOT. ASSOCIATED(DECOMPOSITION_ELEMENT)) CALL FlagError("decomposition element is not associated.", &
                    & ERR,ERROR,*999)
                  DOMAIN=>DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
                  IF(.NOT. ASSOCIATED(DOMAIN)) CALL FlagError("domain is not associated.",ERR,ERROR,*999)
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  IF(.NOT. ASSOCIATED(DOMAIN_TOPOLOGY)) CALL FlagError("domain topology is not associated.",ERR,ERROR,*999)
                  DOMAIN_ELEMENT=>DOMAIN_TOPOLOGY%ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                  IF(.NOT. ASSOCIATED(DOMAIN_ELEMENT)) CALL FlagError("domain element is not associated.",ERR,ERROR,*999)
                  ELEMENT_BASIS=>DOMAIN_ELEMENT%BASIS
                  IF(.NOT. ASSOCIATED(ELEMENT_BASIS)) CALL FlagError("element basis is not associated.",ERR,ERROR,*999)

                  lineBasisLocalNo=ELEMENT_BASIS%xiNormalsLocalLine(userXiDir,1)

                  lineLocalNo=DECOMPOSITION_ELEMENT%ELEMENT_LINES(lineBasisLocalNo)

                  !FIXTHIS should include a check here for the line being a boundary line!!!!!
                  lineGlobalNo=DOMAIN%MAPPINGS%LINES%LOCAL_TO_GLOBAL_MAP(lineLocalNo)
                  IF(DECOMPOSITION_TOPOLOGY%lines%lines(lineLocalNo)%BOUNDARY_LINE) THEN
                    !do nothing
                  ELSE
                    LOCAL_ERROR="The external line with global number of " // &
                      & TRIM(NumberToVString(lineGlobalNo,"*",ERR,ERROR)) // " is not a boundary line"
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                  !Now find the local dof number from the line local number

                  IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                    LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                      & LINE_PARAM2DOF_MAP%LINES(lineLocalNo)%DERIVATIVES(DERIVATIVE_NUMBER)%VERSIONS(VERSION_NUMBER)
                    GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                  ELSE
                    CALL FlagError("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The specified user element number of "// &
                    & TRIM(NumberToVString(userElementNumber,"*",ERR,ERROR))// &
                    & " does not exist in the decomposition for field component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_DOF_GET_USER_LINE")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_USER_LINE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_LINE
  !
  !================================================================================================================================
  !


  !>Returns the dof numbers for a field component that corresponds to the specified user node and derivative.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_NODE(FIELD,VARIABLE_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER, &
    & COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The version number to get the dof for
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number to get the dof for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to get the dof for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user node
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user node
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_DOF_GET_USER_NODE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has face based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has elem and ext face based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has line based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has elem and ext line based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                    & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                  IF(USER_NODE_EXISTS) THEN
                    IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                      IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%NUMBER_OF_DERIVATIVES) &
                        & THEN
                        LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                          & VERSIONS(VERSION_NUMBER)
                        GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                      ELSE
                        LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for user node number "// &
                          & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                          & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                          & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%NUMBER_OF_DERIVATIVES, &
                          & "*",ERR,ERROR))//" derivatives."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The specified user node number of "// &
                      & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                      & " does not exist in the domain for field component number "// &
                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Field variable component domain is not associated.",ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_DOF_GET_USER_NODE")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_DOF_GET_USER_NODE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_NODE

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable component for character labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelGet
  SUBROUTINE FIELD_COMPONENT_LABEL_GET_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_LABEL_GET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              C_LENGTH=LEN(LABEL)
              VS_LENGTH=LEN_TRIM(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL)
              IF(C_LENGTH>VS_LENGTH) THEN
                LABEL=CHAR(LEN_TRIM(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL))
              ELSE
                LABEL=CHAR(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL,C_LENGTH)
              ENDIF
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_GET_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable component for varying string labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelGet
  SUBROUTINE FIELD_COMPONENT_LABEL_GET_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_LABEL_GET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              LABEL=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_GET_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for character labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelSet
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_LABEL_SET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                IF(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                  LOCAL_ERROR="The component label has been locked for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ELSE
                  FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(COMPONENT_NUMBER,VARIABLE_TYPE)=LABEL
                ENDIF
              ELSE
                LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                  & TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                  & " components."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for varying string labels. \see OpenCMISS::Iron::cmfe_FieldComponentLabelSet
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_LABEL_SET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                IF(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                  LOCAL_ERROR="The component label has been locked for component number "// &
                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ELSE
                  FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(COMPONENT_NUMBER,VARIABLE_TYPE)=LABEL
                ENDIF
              ELSE
                LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                  & TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                  & " components."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_LABEL_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_LABEL_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Check the mesh component number for a field variable component.
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_CHECK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check the field variable component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to check the field variable component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT !<The mesh component to check for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%MESH_COMPONENT_NUMBER/=MESH_COMPONENT) THEN
                LOCAL_ERROR="Invalid mesh component number. The mesh component number for component number "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " which is does correspond to the specified mesh component number of "// &
                  & TRIM(NumberToVString(MESH_COMPONENT,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be > 1 and <= "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_MESH_COMPONENT_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the mesh component number for a field variable component. \see cmfe_Field_ComponentMeshComponentGet
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the field variable component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the field variable component for
    INTEGER(INTG), INTENT(OUT) :: MESH_COMPONENT !<On return, the mesh component to get for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              MESH_COMPONENT=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%MESH_COMPONENT_NUMBER
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be > 1 and <= "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_GET")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_MESH_COMPONENT_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component. \see OpenCMISS::Iron::cmfe_FieldComponentMeshComponentSet
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set the mesh component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT_NUMBER !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          MESH=>DECOMPOSITION%MESH
          IF(ASSOCIATED(MESH)) THEN
            IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
              IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                    IF(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                      LOCAL_ERROR="The mesh component has been locked for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ELSE
                      SELECT CASE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE))
! Should set anyway in case user changes interpolation(?) Needed by finite elasticity / material field - Sander
!                      CASE(FIELD_CONSTANT_INTERPOLATION)
!                        LOCAL_ERROR="Can not set a mesh component for field component number "// &
!                          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
!                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
!                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
!                          & " which has constant interpolation."
!                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      CASE(FIELD_ELEMENT_BASED_INTERPOLATION,FIELD_NODE_BASED_INTERPOLATION,FIELD_GRID_POINT_BASED_INTERPOLATION, &
                        & FIELD_GAUSS_POINT_BASED_INTERPOLATION, FIELD_CONSTANT_INTERPOLATION, &
                        & FIELD_DATA_POINT_BASED_INTERPOLATION, FIELD_FACE_BASED_INTERPOLATION, &
                        & FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION, FIELD_LINE_BASED_INTERPOLATION, &
                        & FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                        IF(MESH_COMPONENT_NUMBER>0.AND.MESH_COMPONENT_NUMBER<=MESH%NUMBER_OF_COMPONENTS) THEN
                          FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(COMPONENT_NUMBER,VARIABLE_TYPE)=MESH_COMPONENT_NUMBER
                        ELSE
                          LOCAL_ERROR="Mesh component number "//TRIM(NumberToVString(MESH_COMPONENT_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid. The component number must be between 1 and "// &
                            & TRIM(NumberToVString(MESH%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                            & " for mesh number "//TRIM(NumberToVString(MESH%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      CASE DEFAULT
                        LOCAL_ERROR="The interpolation type "//TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE% &
                          & INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE),"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      END SELECT
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field variable type must be > 1 and <= "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Field create values cache is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The decomposition mesh is not associated for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The decomposition is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_MESH_COMPONENT_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component and locks it so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set the mesh component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT_NUMBER !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK")
    RETURN
999 ERRORS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK",ERR,ERROR)
    EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK")
    RETURN 1

  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant integer value. \see OpenCMISS::Iron::cmfe_FieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    INTEGER(INTG), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP, &
      & line_idx, face_idx
    INTEGER(INTG), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_LINES_TYPE), POINTER :: DOMAIN_LINES
    TYPE(DOMAIN_FACES_TYPE), POINTER :: DOMAIN_FACES
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_INTG",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DistributedVector_DataGet(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF

                          DOMAIN_FACES=>DOMAIN_TOPOLOGY%FACES
                          IF(ASSOCIATED(DOMAIN_FACES)) THEN
                            DO face_idx=1,DOMAIN_FACES%TOTAL_NUMBER_OF_FACES
                              IF(DOMAIN_TOPOLOGY%faces%FACES(face_Idx)%BOUNDARY_FACE) THEN
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & FACE_PARAM2DOF_MAP%FACES(face_idx)%DERIVATIVES(1)%VERSIONS(1)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDIF
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology faces is not associated.",ERR,ERROR,*999)
                          ENDIF

                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF

                          DOMAIN_LINES=>DOMAIN_TOPOLOGY%LINES
                          IF(ASSOCIATED(DOMAIN_LINES)) THEN
                            DO line_idx=1,DOMAIN_LINES%TOTAL_NUMBER_OF_LINES
                              IF(DOMAIN_TOPOLOGY%lines%LINES(line_Idx)%BOUNDARY_LINE) THEN
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & LINE_PARAM2DOF_MAP%LINES(line_idx)%DERIVATIVES(1)%VERSIONS(1)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDIF
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology lines is not associated.",ERR,ERROR,*999)
                          ENDIF

                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=1_INTG
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=1_INTG
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=1_INTG
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NumberToVString(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NumberToVString(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            !GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)=variable_local_ny
                            MAX_NGP=SIZE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDDO !gauss_point_idx
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set
                    CALL DistributedVector_DataRestore(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the integer data type of the specified value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE

        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_INTG

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value. \see OpenCMISS::Iron::cmfe_FieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    REAL(SP), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP
    REAL(SP), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_SP",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DistributedVector_DataGet(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=1.0_SP
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=1.0_SP
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=1.0_SP
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NumberToVString(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NumberToVString(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            !GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)=variable_local_ny
                            MAX_NGP=SIZE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDDO !gauss_point_idx
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set
                    CALL DistributedVector_DataRestore(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the single precision data type of the specified value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_SP")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_SP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value. \see OpenCMISS::Iron::cmfe_FieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    REAL(DP), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP, &
      & dataPointIdx,localDataPointNumber, faceIdx, lineIdx
    REAL(DP), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DOMAIN_MAPPINGS
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: FACE_MAPPING
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: LINE_MAPPING
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DecompositionDataPointsType), POINTER :: decompositionData
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(MeshComponentTopologyType), POINTER :: meshTopology
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_DP",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DistributedVector_DataGet(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elementIdx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !elementIdx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_MAPPINGS=>COMPONENT_DOMAIN%MAPPINGS
                        IF(ASSOCIATED(DOMAIN_MAPPINGS)) THEN
                          FACE_MAPPING=>DOMAIN_MAPPINGS%FACES
                          IF(ASSOCIATED(FACE_MAPPING)) THEN
                            DO faceIdx=1,FACE_MAPPING%TOTAL_NUMBER_OF_LOCAL
                              !Here we assume that for face the derivative number and the version number for faces is 1. We have kept the face param_to_dof_map the same as nodes incase we want face derivatives in the future
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & FACE_PARAM2DOF_MAP%FACES(faceIdx)%DERIVATIVES(1)%VERSIONS(1)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !faceIdx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        !idx of topology here is 1 because we are already in the domain of the component. FIXTHIS, make sure this is correct
                        meshTopology=>COMPONENT_DOMAIN%mesh%topology(1)%PTR
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(meshTopology)) THEN
                            IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                              DOMAIN_MAPPINGS=>COMPONENT_DOMAIN%MAPPINGS
                              IF(ASSOCIATED(DOMAIN_MAPPINGS)) THEN
                                FACE_MAPPING=>DOMAIN_MAPPINGS%FACES
                                IF(ASSOCIATED(FACE_MAPPING)) THEN
                                  DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                    field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elementIdx)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  ENDDO !elementIdx
                                  DO faceIdx=1,FACE_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                    IF(DOMAIN_TOPOLOGY%lines%LINES(faceIdx)%BOUNDARY_LINE) THEN
                                      !Here we assume that for face the derivative number and the version number for faces is 1. We have kept the face param_to_dof_map the same as nodes incase we want face derivatives in the future
                                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                        & FACE_PARAM2DOF_MAP%FACES(faceIdx)%DERIVATIVES(1)%VERSIONS(1)
                                      FIELD_PARAMETERS(field_dof)=VALUE
                                    ENDIF
                                  ENDDO !faceIdx
                                ELSE
                                  CALL FlagError("Domain mapping faces is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Domain mappings is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain mesh topology is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_MAPPINGS=>COMPONENT_DOMAIN%MAPPINGS
                        IF(ASSOCIATED(DOMAIN_MAPPINGS)) THEN
                          LINE_MAPPING=>DOMAIN_MAPPINGS%LINES
                          IF(ASSOCIATED(LINE_MAPPING)) THEN
                            DO lineIdx=1,LINE_MAPPING%TOTAL_NUMBER_OF_LOCAL
                              !Here we assume that for line the derivative number and the version number for lines is 1. We have kept the line param_to_dof_map the same as nodes incase we want line derivatives in the future
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & LINE_PARAM2DOF_MAP%LINES(lineIdx)%DERIVATIVES(1)%VERSIONS(1)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !lineIdx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        !idx of topology here is 1 because we are already in the domain of the component. FIXTHIS, make sure this is correct
                        meshTopology=>COMPONENT_DOMAIN%mesh%topology(1)%PTR
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(meshTopology)) THEN
                            IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                              DOMAIN_MAPPINGS=>COMPONENT_DOMAIN%MAPPINGS
                              IF(ASSOCIATED(DOMAIN_MAPPINGS)) THEN
                                LINE_MAPPING=>DOMAIN_MAPPINGS%LINES
                                IF(ASSOCIATED(LINE_MAPPING)) THEN
                                  DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                    field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elementIdx)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  ENDDO !elementIdx
                                  DO lineIdx=1,LINE_MAPPING%TOTAL_NUMBER_OF_LOCAL
                                    IF(DOMAIN_TOPOLOGY%lines%LINES(lineIdx)%BOUNDARY_LINE) THEN
                                      !Here we assume that for line the derivative number and the version number for lines is 1. We have kept the line param_to_dof_map the same as nodes incase we want line derivatives in the future
                                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                        & LINE_PARAM2DOF_MAP%LINES(lineIdx)%DERIVATIVES(1)%VERSIONS(1)
                                      FIELD_PARAMETERS(field_dof)=VALUE
                                    ENDIF
                                  ENDDO !lineIdx
                                ELSE
                                  CALL FlagError("Domain mapping lines is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                CALL FlagError("Domain mappings is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain mesh topology is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=1.0_DP
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=1.0_DP
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=1.0_DP
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NumberToVString(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NumberToVString(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            !GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,elementIdx)=variable_local_ny
                            MAX_NGP=SIZE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                            DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,elementIdx)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDDO !gauss_point_idx
                            ENDDO !elementIdx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            decompositionData=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN%DECOMPOSITION%TOPOLOGY%dataPoints
                            IF(ASSOCIATED(decompositionData)) THEN
                              DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                DO dataPointIdx=1,decompositionData%elementDataPoint(elementIdx)%numberOfProjectedData
                                  localDataPointNumber=decompositionData%elementDataPoint(elementIdx)%dataIndices(dataPointIdx)% &
                                    & localNumber
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(localDataPointNumber)
                                  FIELD_PARAMETERS(field_dof)=VALUE
                                ENDDO !dataPointIdx
                              ENDDO !elementIdx
                            ELSE
                              CALL FlagError("Decomposition data point topology is not associated.",ERR,ERROR,*999)
                            ENDIF

                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set
                    CALL DistributedVector_DataRestore(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the double precision data type of the specified value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_DP")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_DP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value. \see OpenCMISS::Iron::cmfe_FieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    LOGICAL, INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx
    LOGICAL, POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_L",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DistributedVector_DataGet(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=.TRUE.
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=.TRUE.
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=.TRUE.
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NumberToVString(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NumberToVString(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set
                    CALL DistributedVector_DataRestore(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the logical data type of the specified value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_COMPONENT_VALUES_INITIALISE_L")
    RETURN
999 ERRORSEXITS("FIELD_COMPONENT_VALUES_INITIALISE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_L

  !
  !================================================================================================================================
  !

  !>Checks the data type for a field variable.
  SUBROUTINE FIELD_DATA_TYPE_CHECK(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the data type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type of the field variable to check \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DATA_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            SELECT CASE(DATA_TYPE)
            CASE(FIELD_INTG_TYPE)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_INTG_TYPE) THEN
                LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not an integer data type."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_SP_TYPE)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_SP_TYPE) THEN
                LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a single precision data type."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)




              ENDIF
            CASE(FIELD_DP_TYPE)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_DP_TYPE) THEN
                LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a double precision data type."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
             CASE(FIELD_L_TYPE)
               IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_L_TYPE) THEN
                 LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a logical data type."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="The specified data type of "//TRIM(NumberToVString(DATA_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DATA_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the data type for a field variable. \see OpenCMISS::Iron::cmfe_FieldDataTypeGet
  SUBROUTINE FIELD_DATA_TYPE_GET(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the data type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DATA_TYPE !<On return, the data type of the field variable \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DATA_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            DATA_TYPE=FIELD_VARIABLE%DATA_TYPE
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DATA_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable. \see OpenCMISS::Iron::cmfe_FieldDataTypeSet
  SUBROUTINE FIELD_DATA_TYPE_SET(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type to set \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DATA_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The data type has been locked for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(DATA_TYPE)
                CASE(FIELD_INTG_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_INTG_TYPE
                CASE(FIELD_SP_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_SP_TYPE
                CASE(FIELD_DP_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_DP_TYPE
                CASE(FIELD_L_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_L_TYPE
                CASE DEFAULT
                  LOCAL_ERROR="The specified data type of "//TRIM(NumberToVString(DATA_TYPE,"*",ERR,ERROR))// &
                    & " is invalid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Field create values cache is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DATA_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE FIELD_DATA_TYPE_SET_AND_LOCK(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type to set \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DATA_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DATA_TYPE_SET(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DATA_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DATA_TYPE_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the DOF order type for a field variable.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_CHECK(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type of the field variable to check \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DOF_ORDER_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            SELECT CASE(DOF_ORDER_TYPE)
            CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
              IF(FIELD_VARIABLE%DOF_ORDER_TYPE/=FIELD_SEPARATED_COMPONENT_DOF_ORDER) THEN
                LOCAL_ERROR="Invalid DOF order type. The DOF order type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a separated component DOF order type."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
              IF(FIELD_VARIABLE%DOF_ORDER_TYPE/=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER) THEN
                LOCAL_ERROR="Invalid DOF order type. The DOF order type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a contiguous component DOF order type."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="The specified DOF order type of "//TRIM(NumberToVString(DOF_ORDER_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DOF_ORDER_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the DOF order type for a field variable. \see OpenCMISS::Iron::cmfe_FieldDOFOrderTypeGet
  SUBROUTINE FIELD_DOF_ORDER_TYPE_GET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DOF_ORDER_TYPE !<On return, the DOF order type of the field variable \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DOF_ORDER_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            DOF_ORDER_TYPE=FIELD_VARIABLE%DOF_ORDER_TYPE
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DOF_ORDER_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous component DOF ordering all the components of the field variable must have the same interpolation type.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_SET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type to set \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx
    LOGICAL :: SAME_INTERPOLATION,SAME_MESH_COMPONENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DOF_ORDER_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The DOF order type has been locked for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(DOF_ORDER_TYPE)
                CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
                  FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(VARIABLE_TYPE)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
                CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
                  SAME_INTERPOLATION=.TRUE.
                  SAME_MESH_COMPONENT=.TRUE.
                  DO component_idx=2,FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)
                    IF(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(component_idx,VARIABLE_TYPE)/= &
                      & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1,VARIABLE_TYPE)) THEN
                      SAME_INTERPOLATION=.FALSE.
                      EXIT
                    ENDIF
                    IF(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(component_idx,VARIABLE_TYPE)/= &
                      & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1,VARIABLE_TYPE)) THEN
                      SAME_MESH_COMPONENT=.FALSE.
                      EXIT
                    ENDIF
                  ENDDO !component_idx
                  IF(SAME_INTERPOLATION.AND.SAME_MESH_COMPONENT) THEN
                    FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(VARIABLE_TYPE)=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER
                  ELSE
                    CALL FlagError("Invalid field variable component set. For continguous component DOF "// &
                      & "ordering the field variable components must have the same interpolation type and mesh components.", &
                      & ERR,ERROR,*999)
                  ENDIF
                CASE DEFAULT
                  LOCAL_ERROR="The specified DOF order type of "//TRIM(NumberToVString(DOF_ORDER_TYPE,"*",ERR,ERROR))// &
                    & " is invalid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Field create values cache is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DOF_ORDER_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the DOF order for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type to set \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK

  !

  !================================================================================================================================
  !

  !>Finalises a field variable component and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE) :: FIELD_VARIABLE_COMPONENT !<The field variable component to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_VARIABLE_COMPONENT_FINALISE",ERR,ERROR,*999)

    FIELD_VARIABLE_COMPONENT%COMPONENT_LABEL=""
    CALL FieldVariableComponent_ParameterToDofMapFinalise(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*999)

    EXITS("FIELD_VARIABLE_COMPONENT_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_COMPONENT_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_INITIALISE(FIELD_VARIABLE,COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE !<A pointer to the field variable to initialise the component for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: COMP_NUMBER,derivativeIdx,DUMMY_ERR,ne,VARIABLE_TYPE, NGP, MAXINTERP,globalElementNumber,nodeIdx,numParameters
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_COMPONENT_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
      FIELD=>FIELD_VARIABLE%FIELD
      IF(ASSOCIATED(FIELD)) THEN
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          VARIABLE_TYPE=FIELD_VARIABLE%VARIABLE_TYPE
          IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_NUMBER=COMPONENT_NUMBER
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%FIELD_VARIABLE=>FIELD_VARIABLE
              DECOMPOSITION=>FIELD%DECOMPOSITION
              IF(ASSOCIATED(DECOMPOSITION)) THEN
                MESH=>DECOMPOSITION%MESH
                IF(ASSOCIATED(MESH)) THEN
                  COMP_NUMBER=FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(COMPONENT_NUMBER,VARIABLE_TYPE)
                  IF(COMP_NUMBER>0.AND.COMP_NUMBER<=MESH%NUMBER_OF_COMPONENTS) THEN
                    FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%MESH_COMPONENT_NUMBER=COMP_NUMBER
                    FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN=>DECOMPOSITION%DOMAIN(COMP_NUMBER)%PTR
                    DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                    IF(.NOT.ASSOCIATED(DOMAIN)) THEN
                      LOCAL_ERROR="Field component "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                        & " does not have a domain associated."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The mesh component number of "//TRIM(NumberToVString(COMP_NUMBER,"*",ERR,ERROR))// &
                      & " for field component "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The component number must be between 1 and "// &
                      & TRIM(NumberToVString(MESH%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="Decomposition mesh is not associated for field number "// &
                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="Decomposition is not associated for field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL=""
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL= &
                & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(COMPONENT_NUMBER,VARIABLE_TYPE)
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE= &
                FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=0
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=0
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=-1
                DO ne=1,DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  BASIS=>DOMAIN%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%BASIS
                  IF(BASIS%NUMBER_OF_ELEMENT_PARAMETERS>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                    & maxNumberElementInterpolationParameters) FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                    & maxNumberElementInterpolationParameters=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                ENDDO !ne
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=-1
                DO nodeIdx=1,DOMAIN%TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                  numParameters=0
                  DO derivativeIdx=1,DOMAIN%TOPOLOGY%NODES%NODES(nodeIdx)%NUMBER_OF_DERIVATIVES
                    numParameters=numParameters+DOMAIN%TOPOLOGY%NODES%NODES(nodeIdx)%DERIVATIVES(derivativeIdx)%numberOfVersions
                  ENDDO !derivativeIdx
                  IF(numParameters>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters) &
                    & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=numParameters
                ENDDO !nodeIdx
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION) ! ?
                MAXINTERP = -1
                DO ne=1,DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  BASIS=>DOMAIN%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%BASIS
                  NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
                  IF(NGP > MAXINTERP) MAXINTERP = NGP
                ENDDO
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters = MAXINTERP
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters = 0
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=-1
                DO ne=1,DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  globalElementNumber=DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%GLOBAL_NUMBER
                  IF(DECOMPOSITION%TOPOLOGY%dataPoints%numberOfElementDataPoints(globalElementNumber)> &
                      & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters) THEN
                    FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters= &
                      &  DECOMPOSITION%TOPOLOGY%dataPoints%numberOfElementDataPoints(globalElementNumber)
                  ENDIF
                ENDDO
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE DEFAULT
                LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is invalid."
              END SELECT
              CALL FieldVariableComponent_ParameterToDofMapInitialise(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER), &
                & ERR,ERROR,*999)
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FlagError("Field variable components have not been allocated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FlagError("Field create values cache is not associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FlagError("Field variable field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Field variable is is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_VARIABLE_COMPONENT_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER),DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_VARIABLE_COMPONENT_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises a field variable component parameter to dof map and deallocates all memory.
  SUBROUTINE FieldVariableComponent_ParameterToDofMapFinalise(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE) :: FIELD_VARIABLE_COMPONENT !<The field variable component to finialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FieldVariableComponent_ParameterToDofMapFinalise",ERR,ERROR,*999)

    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%GRID_POINTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%GRID_POINTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS)
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS=0

    EXITS("FieldVariableComponent_ParameterToDofMapFinalise")
    RETURN
999 ERRORS("FieldVariableComponent_ParameterToDofMapFinalise",ERR,ERROR)
    EXITS("FieldVariableComponent_ParameterToDofMapFinalise")
    RETURN 1

  END SUBROUTINE FieldVariableComponent_ParameterToDofMapFinalise

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component parameter to dof map.
  SUBROUTINE FieldVariableComponent_ParameterToDofMapInitialise(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE) :: FIELD_VARIABLE_COMPONENT !<The field variable component to initialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FieldVariableComponent_ParameterToDofMapInitialise",ERR,ERROR,*999)

    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS=0

    EXITS("FieldVariableComponent_ParameterToDofMapInitialise")
    RETURN
999 ERRORS("FieldVariableComponent_ParameterToDofMapInitialise",ERR,ERROR)
    EXITS("FieldVariableComponent_ParameterToDofMapInitialise")
    RETURN 1

  END SUBROUTINE FieldVariableComponent_ParameterToDofMapInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the field variable components for a field variable and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE) :: FIELD_VARIABLE !<The field variable to finalise the field variable components for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx

    ENTERS("FIELD_VARIABLE_COMPONENTS_FINALISE",ERR,ERROR,*999)

    IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
      DO component_idx=1,SIZE(FIELD_VARIABLE%COMPONENTS,1)
        CALL FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE%COMPONENTS(component_idx),ERR,ERROR,*999)
      ENDDO !component_idx
      DEALLOCATE(FIELD_VARIABLE%COMPONENTS)
    ENDIF
    FIELD_VARIABLE%NUMBER_OF_COMPONENTS=0

    EXITS("FIELD_VARIABLE_COMPONENTS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_COMPONENTS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the field components.
  SUBROUTINE FIELD_VARIABLE_COMPONENTS_INITIALISE(FIELD,VARIABLE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the field variable components for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to initialise the field variable components for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_COMPONENTS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
              CALL FlagError("Field variable already has allocated components.",ERR,ERROR,*999)
            ELSE
              ALLOCATE(FIELD_VARIABLE%COMPONENTS(FIELD_VARIABLE%NUMBER_OF_COMPONENTS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate field variable components.",ERR,ERROR,*999)
              DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                CALL FIELD_VARIABLE_COMPONENT_INITIALISE(FIELD_VARIABLE,component_idx,ERR,ERROR,*999)
              ENDDO !component_idx
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Field create values cache is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_COMPONENTS_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_COMPONENTS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field. \see OpenCMISS::Iron::cmfe_FieldCreateFinish
  SUBROUTINE FIELD_CREATE_FINISH(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,parameterSetIdx,scalingIdx,variableIdx
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_CREATE_FINISH",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has already been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        !Check field has a decomposition associated
        IF(ASSOCIATED(FIELD%DECOMPOSITION)) THEN
          !Check for field validity
          CALL FieldVariablesCheck(field,err,error,*999)
          !Initialise the components
          CALL FIELD_VARIABLES_INITIALISE(FIELD,ERR,ERROR,*999)
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD)) THEN
            CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%CREATE_VALUES_CACHE,ERR,ERROR,*999)
            FIELD%FIELD_FINISHED=.TRUE.
            !Calculate dof mappings
            CALL FIELD_MAPPINGS_CALCULATE(FIELD,ERR,ERROR,*999)
            !Test hash table implementation
            STOP
            !Set up the geometric parameters
            CALL FIELD_GEOMETRIC_PARAMETERS_INITIALISE(FIELD,ERR,ERROR,*999)
            !Initialise the scalings
            CALL FIELD_SCALINGS_INITIALISE(FIELD,ERR,ERROR,*999)
            !Initialise the field parameter sets
            CALL FIELD_PARAMETER_SETS_INITIALISE(FIELD,ERR,ERROR,*999)
          ELSE
            CALL FlagError("Field does not have a geometric field associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Field does not have a mesh decomposition associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Field number : ",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Global number = ",FIELD%GLOBAL_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  User number = ",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Label = ",FIELD%LABEL,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Dependent type = ",FIELD%DEPENDENT_TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field type = ",FIELD%TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",FIELD%NUMBER_OF_VARIABLES,ERR,ERROR,*999)
      IF(DIAGNOSTICS2) THEN
        DO variableIdx=1,FIELD%NUMBER_OF_VARIABLES
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Variable : ",variableIdx,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Type = ",variableIdx,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Label = ",FIELD%VARIABLES(variableIdx)%VARIABLE_LABEL, &
            & ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Dimension = ",FIELD%VARIABLES(variableIdx)%DIMENSION, &
            & ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Data type = ",FIELD%VARIABLES(variableIdx)%DATA_TYPE, &
            & ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      DOF order type = ",FIELD%VARIABLES(variableIdx)%DOF_ORDER_TYPE, &
            & ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Max num element interpolation parameters = ",FIELD% &
            & VARIABLES(variableIdx)%maxNumberElementInterpolationParameters,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Max num node interpolation parameters = ",FIELD% &
            & VARIABLES(variableIdx)%maxNumberNodeInterpolationParameters,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of DOFs = ",FIELD%VARIABLES(variableIdx)% &
            & NUMBER_OF_DOFS,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Total number of DOFs = ",FIELD%VARIABLES(variableIdx)% &
            & TOTAL_NUMBER_OF_DOFS,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of global DOFs = ",FIELD%VARIABLES(variableIdx)% &
            & NUMBER_OF_GLOBAL_DOFS,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",FIELD%VARIABLES(variableIdx)% &
            & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
          IF(DIAGNOSTICS3) THEN
            DO componentIdx=1,FIELD%VARIABLES(variableIdx)%NUMBER_OF_COMPONENTS
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Component : ",componentIdx,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Component label = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%COMPONENT_LABEL,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Interpolation type = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%INTERPOLATION_TYPE,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Mesh component number = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Scaling index = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%SCALING_INDEX,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Max num element interpolation parameters = ",FIELD% &
                & VARIABLES(variableIdx)%COMPONENTS(componentIdx)%maxNumberElementInterpolationParameters,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Max num node interpolation parameters = ",FIELD% &
                & VARIABLES(variableIdx)%COMPONENTS(componentIdx)%maxNumberNodeInterpolationParameters,ERR,ERROR,*999)
            ENDDO !componentIdx
          ENDIF
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameter sets = ",FIELD%VARIABLES(variableIdx)% &
            & PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS,ERR,ERROR,*999)
          IF(DIAGNOSTICS3) THEN
            DO parameterSetIdx=1,FIELD%VARIABLES(variableIdx)%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Parameter set index : ",parameterSetIdx,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Set type : ",FIELD%VARIABLES(variableIdx)% &
                & PARAMETER_SETS%PARAMETER_SETS(parameterSetIdx)%PTR%SET_TYPE,ERR,ERROR,*999)
            ENDDO !parameterSetIdx
          ENDIF
        ENDDO !variableIdx
      ENDIF
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Scaling type = ",FIELD%SCALINGS%SCALING_TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of scaling indices = ",FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES, &
        & ERR,ERROR,*999)
      IF(DIAGNOSTICS2) THEN
        DO scalingIdx=1,FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Scaling index : ",scalingIdx,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Mesh component number : ",FIELD%SCALINGS%SCALINGS(scalingIdx)% &
            & MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
        ENDDO !scalingIdx
      ENDIF
    ENDIF

    EXITS("FIELD_CREATE_FINISH")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_FINISH",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field.
  SUBROUTINE FIELD_CREATE_START_GENERIC(FIELDS,USER_NUMBER,FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<A pointer to the fields
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field to create
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_no
    TYPE(FIELD_TYPE), POINTER :: NEW_FIELD
    TYPE(FIELD_PTR_TYPE), POINTER :: NEW_FIELDS(:)

    NULLIFY(NEW_FIELD)
    NULLIFY(NEW_FIELDS)

    ENTERS("FIELD_CREATE_START_GENERIC",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELDS)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FlagError("Field is already associated.",ERR,ERROR,*998)
      ELSE
        !Set default field properties
        CALL FIELD_INITIALISE(NEW_FIELD,ERR,ERROR,*999)
        NEW_FIELD%GLOBAL_NUMBER=FIELDS%NUMBER_OF_FIELDS+1
        NEW_FIELD%USER_NUMBER=USER_NUMBER
        NEW_FIELD%LABEL="Field "//TRIM(NumberToVString(USER_NUMBER,"*",ERR,ERROR))
        IF(ERR/=0) GOTO 999
        NEW_FIELD%FIELDS=>FIELDS
        NULLIFY(NEW_FIELD%REGION)
        NULLIFY(NEW_FIELD%INTERFACE)
        NEW_FIELD%GEOMETRIC_FIELD=>NEW_FIELD
        NEW_FIELD%NUMBER_OF_VARIABLES=1
        NEW_FIELD%SCALINGS%SCALING_TYPE=FIELD_ARITHMETIC_MEAN_SCALING
        NEW_FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES=0
        NULLIFY(NEW_FIELD%CREATE_VALUES_CACHE)
        !Add new field into list of fields
        ALLOCATE(NEW_FIELDS(FIELDS%NUMBER_OF_FIELDS+1),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate new fields.",ERR,ERROR,*999)
        DO field_no=1,FIELDS%NUMBER_OF_FIELDS
          NEW_FIELDS(field_no)%PTR=>FIELDS%FIELDS(field_no)%PTR
        ENDDO !field_no
        NEW_FIELDS(FIELDS%NUMBER_OF_FIELDS+1)%PTR=>NEW_FIELD
        IF(ASSOCIATED(FIELDS%FIELDS)) DEALLOCATE(FIELDS%FIELDS)
        FIELDS%FIELDS=>NEW_FIELDS
        FIELDS%NUMBER_OF_FIELDS=FIELDS%NUMBER_OF_FIELDS+1
        FIELD=>NEW_FIELD
      ENDIF
    ELSE
      CALL FlagError("Fields is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_CREATE_START_GENERIC")
    RETURN
999 IF(ASSOCIATED(NEW_FIELD)) DEALLOCATE(NEW_FIELD)
    IF(ASSOCIATED(NEW_FIELDS)) DEALLOCATE(NEW_FIELDS)
    NULLIFY(FIELD)
998 ERRORSEXITS("FIELD_CREATE_START_GENERIC",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_CREATE_START_GENERIC

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified interface. \see OpenCMISS::Iron::cmfe_FieldCreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%SCALING_TYPE: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in FIELD_INITIALISE
  SUBROUTINE FIELD_CREATE_START_INTERFACE(USER_NUMBER,INTERFACE,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE !<A pointer to the interface in which to create the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field being created. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_CREATE_START_INTERFACE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FlagError("Field is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(FIELD)
        CALL FIELD_USER_NUMBER_FIND(USER_NUMBER,INTERFACE,FIELD,ERR,ERROR,*999)
        IF(ASSOCIATED(FIELD)) THEN
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(USER_NUMBER,"*",ERR,ERROR))// &
            & " has already been created on interface number "//TRIM(NumberToVString(INTERFACE%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ELSE
          CALL FIELD_CREATE_START_GENERIC(INTERFACE%FIELDS,USER_NUMBER,FIELD,ERR,ERROR,*999)
          FIELD%INTERFACE=>INTERFACE
          CALL FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Interface is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_CREATE_START_INTERFACE")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_START_INTERFACE",ERR,ERROR)
    RETURN 1

  END SUBROUTINE FIELD_CREATE_START_INTERFACE

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified region. \see OpenCMISS::Iron::cmfe_FieldCreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%SCALING_TYPE: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in FIELD_INITIALISE
  SUBROUTINE FIELD_CREATE_START_REGION(USER_NUMBER,REGION,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field
    TYPE(REGION_TYPE), POINTER :: REGION !<A pointer to the region in which to create the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field being created
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_CREATE_START_REGION",ERR,ERROR,*999)

    IF(ASSOCIATED(REGION)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FlagError("Field is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(FIELD)
        CALL FIELD_USER_NUMBER_FIND(USER_NUMBER,REGION,FIELD,ERR,ERROR,*999)
        IF(ASSOCIATED(FIELD)) THEN
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(USER_NUMBER,"*",ERR,ERROR))// &
            & " has already been created on region number "//TRIM(NumberToVString(REGION%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ELSE
          CALL FIELD_CREATE_START_GENERIC(REGION%FIELDS,USER_NUMBER,FIELD,ERR,ERROR,*999)
          FIELD%REGION=>REGION
          CALL FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Region is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_CREATE_START_REGION")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_START_REGION",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_CREATE_START_REGION

  !
  !================================================================================================================================
  !

  !>Finalise the create values cache for a field.
  SUBROUTINE FIELD_CREATE_VALUES_CACHE_FINALISE(CREATE_VALUES_CACHE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER :: CREATE_VALUES_CACHE !<A pointer to the create values cache to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,variable_idx

    ENTERS("FIELD_CREATE_VALUES_CACHE_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CREATE_VALUES_CACHE)) THEN
      IF(ALLOCATED(CREATE_VALUES_CACHE%VARIABLE_TYPES)) DEALLOCATE(CREATE_VALUES_CACHE%VARIABLE_TYPES)
      IF(ALLOCATED(CREATE_VALUES_CACHE%VARIABLE_LABELS)) THEN
        DO variable_idx=1,SIZE(CREATE_VALUES_CACHE%VARIABLE_LABELS,1)
          CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)=""
        ENDDO !variable_idx
        DEALLOCATE(CREATE_VALUES_CACHE%VARIABLE_LABELS)
      ENDIF
      IF(ALLOCATED(CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DIMENSION)) DEALLOCATE(CREATE_VALUES_CACHE%DIMENSION)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DIMENSION_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DIMENSION_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DATA_TYPES)) DEALLOCATE(CREATE_VALUES_CACHE%DATA_TYPES)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DATA_TYPES_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DATA_TYPES_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DOF_ORDER_TYPES)) DEALLOCATE(CREATE_VALUES_CACHE%DOF_ORDER_TYPES)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)) DEALLOCATE(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)
      IF(ALLOCATED(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%COMPONENT_LABELS)) THEN
        DO variable_idx=1,SIZE(CREATE_VALUES_CACHE%COMPONENT_LABELS,2)
          DO component_idx=1,SIZE(CREATE_VALUES_CACHE%COMPONENT_LABELS,1)
            CREATE_VALUES_CACHE%COMPONENT_LABELS(component_idx,variable_idx)=""
          ENDDO !component_idx
        ENDDO !variable_idx
        DEALLOCATE(CREATE_VALUES_CACHE%COMPONENT_LABELS)
      ENDIF
      IF(ALLOCATED(CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%INTERPOLATION_TYPE)) DEALLOCATE(CREATE_VALUES_CACHE%INTERPOLATION_TYPE)
      IF(ALLOCATED(CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)) DEALLOCATE(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)
      IF(ALLOCATED(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)
      DEALLOCATE(CREATE_VALUES_CACHE)
    ENDIF

    EXITS("FIELD_CREATE_VALUES_CACHE_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_CREATE_VALUES_CACHE_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_CREATE_VALUES_CACHE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the create values cache for a field.
  SUBROUTINE FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the create values cache for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    INTEGER(INTG) :: DUMMY_ERR,NUMBER_OF_COMPONENTS,component_idx,variable_idx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    ENTERS("FIELD_CREATE_VALUES_CACHE_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        CALL FlagError("Create values cache is already associated.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(FIELD%CREATE_VALUES_CACHE,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate create values cache.",ERR,ERROR,*999)
        SELECT CASE(FIELD%TYPE)
        CASE(FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          NUMBER_OF_COMPONENTS=COORDINATE_SYSTEM%NUMBER_OF_DIMENSIONS
        CASE(FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE)
          NUMBER_OF_COMPONENTS=1
        CASE DEFAULT
          LOCAL_ERROR="The field type of "//TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache variable types.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache variable labels.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache variable labels locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DIMENSION(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache dimension.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache dimension locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DATA_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache data types.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache data types locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache DOF order types.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache DOF order types locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache number of components.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache number of components locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache component labels.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache component labels locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache interpolation type.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache interpolation type locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache mesh component type.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES), &
          & STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocated create values cache mesh component type locked.",ERR,ERROR,*999)
        FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DECOMPOSITION_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DEPENDENT_TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_VARIABLES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%GEOMETRIC_FIELD_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%SCALING_TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES=0
        FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS=""
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DIMENSION=0
        FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DATA_TYPES=0
        FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES=0
        FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS=0
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS=""
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE=0
        FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER=0
        FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DataProjectionLocked=.FALSE.
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(variable_idx)=variable_idx
          SELECT CASE(variable_idx)
          CASE(FIELD_U_VARIABLE_TYPE)
            SELECT CASE(FIELD%TYPE)
            CASE(FIELD_GEOMETRIC_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="Coordinate"
            CASE(FIELD_FIBRE_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="Fibre"
            CASE(FIELD_MATERIAL_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="Material"
            CASE(FIELD_GENERAL_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U"
            CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U"
            CASE DEFAULT
              LOCAL_ERROR="The field type of "//TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))// &
                & " is invalid for field number "// &
                & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          CASE(FIELD_DELUDELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U/del n"
          CASE(FIELD_DELUDELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U/del t"
          CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U/del t^2"
          CASE(FIELD_V_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="V"
          CASE(FIELD_DELVDELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del V/del n"
          CASE(FIELD_DELVDELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del V/del t"
          CASE(FIELD_DEL2VDELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 V/del t^2"
          CASE(FIELD_U1_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U1"
          CASE(FIELD_DELU1DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U1/del n"
          CASE(FIELD_DELU1DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U1/del t"
          CASE(FIELD_DEL2U1DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U1/del t^2"
          CASE(FIELD_U2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U2"
          CASE(FIELD_DELU2DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U2/del n"
          CASE(FIELD_DELU2DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U2/del t"
          CASE(FIELD_DEL2U2DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U2/del t^2"
          CASE(FIELD_U3_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U3"
          CASE(FIELD_DELU3DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U3/del n"
          CASE(FIELD_DELU3DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U3/del t"
          CASE(FIELD_DEL2U3DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U3/del t^2"
          CASE(FIELD_U4_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U4"
          CASE(FIELD_DELU4DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U4/del n"
          CASE(FIELD_DELU4DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U4/del t"
          CASE(FIELD_DEL2U4DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U4/del t^2"
          CASE(FIELD_U5_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U5"
          CASE(FIELD_DELU5DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U5/del n"
          CASE(FIELD_DELU5DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U5/del t"
          CASE(FIELD_DEL2U5DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U5/del t^2"
          CASE(FIELD_U6_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U6"
          CASE(FIELD_DELU6DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U6/del n"
          CASE(FIELD_DELU6DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U6/del t"
          CASE(FIELD_DEL2U6DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U6/del t^2"
          CASE(FIELD_U7_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U7"
          CASE(FIELD_DELU7DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U7/del n"
          CASE(FIELD_DELU7DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U7/del t"
          CASE(FIELD_DEL2U7DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U7/del t^2"
          CASE(FIELD_U8_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U8"
          CASE(FIELD_DELU8DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U8/del n"
          CASE(FIELD_DELU8DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U8/del t"
          CASE(FIELD_DEL2U8DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U8/del t^2"
          CASE(FIELD_U9_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U9"
          CASE(FIELD_DELU9DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U9/del n"
          CASE(FIELD_DELU9DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U9/del t"
          CASE(FIELD_DEL2U9DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U/9del t^2"
          CASE(FIELD_U10_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U10"
          CASE(FIELD_DELU10DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U10/del n"
          CASE(FIELD_DELU10DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U10/del t"
          CASE(FIELD_DEL2U10DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U10/del t^2"
          CASE DEFAULT
            LOCAL_ERROR="The variable type of "//TRIM(NumberToVString(variable_idx,"*",ERR,ERROR))//" is invalid."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
          FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_idx)=FIELD_VECTOR_DIMENSION_TYPE
          FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_idx)=FIELD_DP_TYPE
          FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_idx)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
          FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx)=NUMBER_OF_COMPONENTS
          DO component_idx=1,NUMBER_OF_COMPONENTS
            FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(component_idx,variable_idx)= &
              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))






            IF(ERR/=0) GOTO 999
            FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(component_idx,variable_idx)=FIELD_NODE_BASED_INTERPOLATION
            FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(component_idx,variable_idx)=1
          ENDDO !component_idx
        ENDDO !variable_idx
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_CREATE_VALUES_CACHE_INITIALISE")
    RETURN
999 CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%CREATE_VALUES_CACHE,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_CREATE_VALUES_CACHE_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_CREATE_VALUES_CACHE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets a geometric general field for a field if there is any (eg. the dependent field for a finite elasticity equation),
  !>otherwise the normal geometric field is returned if present.
  !>If no geometric field is found then an error is raised.
  SUBROUTINE Field_GeometricGeneralFieldGet(field,geometricField,generalFound,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: field !<A pointer to the field to get the geometric field for
    TYPE(FIELD_TYPE), POINTER, INTENT(OUT) :: geometricField !<On return, a pointer to the geometric field. Must not be associated on entry.
    LOGICAL, INTENT(OUT) :: generalFound !<On return, true if we found a geometric general field, otherwise false.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(FIELD_TYPE), POINTER :: otherField
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_GeometricGeneralFieldGet",err,error,*999)

    NULLIFY(geometricField)

    ! Check input parameters
    IF(ASSOCIATED(field)) THEN
      IF(field%field_finished) THEN
        IF(.NOT.ASSOCIATED(field%fields)) THEN
          CALL FlagError("Field fields are not associated.",err,error,*999)
        END IF
      ELSE
        localError="Field number "//TRIM(number_to_vstring(field%user_number,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    END IF
    IF(ASSOCIATED(geometricField)) THEN
      CALL FlagError("Geometric field is already associated.",err,error,*999)
    END IF

    generalFound=.FALSE.
    ! Find the geometric general field associated with this field
    DO fieldIdx=1,field%fields%number_of_fields
      otherField=>field%fields%fields(fieldIdx)%ptr
      IF(ASSOCIATED(otherField)) THEN
        IF(otherField%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          geometricField=>otherField
          generalFound=.TRUE.
        END IF
      ELSE
        CALL FlagError("Field number "//TRIM(number_to_vstring(fieldIdx,"*",err,error))// &
          & " is not associated.",err,error,*999)
      END IF
    END DO

    IF(.NOT.generalFound) THEN
      ! We couldn't find a geometric general field.
      ! Just return the undeformed geometric field.
      IF(ASSOCIATED(field%geometric_field)) THEN
        geometricField=>field%geometric_field
      ELSE
        CALL FlagError("Geometric general field not found and geometric field is not associated.",err,error,*999)
      END IF
    END IF

    EXITS("Field_GeometricGeneralFieldGet")
    RETURN
999 ERRORSEXITS("Field_GeometricGeneralFieldGet",err,error)
    RETURN 1
  END SUBROUTINE Field_GeometricGeneralFieldGet

  !
  !================================================================================================================================
  !

  !>Checks the dependent type for a field.
  SUBROUTINE FIELD_DEPENDENT_TYPE_CHECK(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to check \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DEPENDENT_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SELECT CASE(DEPENDENT_TYPE)
        CASE(FIELD_INDEPENDENT_TYPE)
          IF(FIELD%DEPENDENT_TYPE/=FIELD_INDEPENDENT_TYPE) THEN
            LOCAL_ERROR="Invalid dependent type. The dependent type of field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%DEPENDENT_TYPE,"*",ERR,ERROR))// &
              & " which is not an independent field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_DEPENDENT_TYPE)
          IF(FIELD%DEPENDENT_TYPE/=FIELD_DEPENDENT_TYPE) THEN
            LOCAL_ERROR="Invalid dependent type. The dependent type of field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%DEPENDENT_TYPE,"*",ERR,ERROR))// &
              & " which is not a dependent field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The specified dependent type of "//TRIM(NumberToVString(DEPENDENT_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DEPENDENT_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the dependent type for a field. \see OpenCMISS::Iron::cmfe_FieldDependentTypeGet
  SUBROUTINE FIELD_DEPENDENT_TYPE_GET(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dependent type for
    INTEGER(INTG), INTENT(OUT) :: DEPENDENT_TYPE !<On return, the dependent type to get \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DEPENDENT_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DEPENDENT_TYPE=FIELD%DEPENDENT_TYPE
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DEPENDENT_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field. \see OpenCMISS::Iron::cmfe_FieldDependentTypeSet
  SUBROUTINE FIELD_DEPENDENT_TYPE_SET(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to set/change \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DEPENDENT_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%DEPENDENT_TYPE_LOCKED) THEN
            LOCAL_ERROR="The dependent type has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            SELECT CASE(DEPENDENT_TYPE)
            CASE(FIELD_INDEPENDENT_TYPE)
              FIELD%DEPENDENT_TYPE=FIELD_INDEPENDENT_TYPE
            CASE(FIELD_DEPENDENT_TYPE)
              FIELD%DEPENDENT_TYPE=FIELD_DEPENDENT_TYPE
            CASE DEFAULT
              LOCAL_ERROR="The supplied dependent type of "//TRIM(NumberToVString(DEPENDENT_TYPE,"*",ERR,ERROR))//" is invalid."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DEPENDENT_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field and locks so that no further changes are possible.
  SUBROUTINE FIELD_DEPENDENT_TYPE_SET_AND_LOCK(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to set/change \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DEPENDENT_TYPE_SET(FIELD,DEPENDENT_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DEPENDENT_TYPE_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Destroys a field. \see OpenCMISS::Iron::cmfe_FieldDestroy
  SUBROUTINE FIELD_DESTROY(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx,field_position,field_position2
    TYPE(FIELD_TYPE), POINTER :: FIELD2,GEOMETRIC_FIELD
    TYPE(FIELDS_TYPE), POINTER :: FIELDS
    TYPE(FIELD_PTR_TYPE), POINTER :: NEW_FIELDS(:),NEW_FIELDS_USING(:)

    NULLIFY(NEW_FIELDS)
    NULLIFY(NEW_FIELDS_USING)

    ENTERS("FIELD_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELDS=>FIELD%FIELDS
      IF(ASSOCIATED(FIELDS)) THEN
        field_position=FIELD%GLOBAL_NUMBER
        GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          IF(ASSOCIATED(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN
            !Delete this field from the list of fields using the geometric field.
            field_position2=0
            DO field_idx=1,GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
              FIELD2=>GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
              IF(FIELD2%USER_NUMBER==FIELD%USER_NUMBER) THEN
                field_position2=field_idx
                EXIT
              ENDIF
            ENDDO !field_idx
            IF(field_position2/=0) THEN
              ALLOCATE(NEW_FIELDS_USING(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate new fields using.",ERR,ERROR,*999)
              DO field_idx=1,GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
                IF(field_idx<field_position2) THEN
                  NEW_FIELDS_USING(field_idx)%PTR=>GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
                ELSE IF(field_idx>field_position2) THEN
                  NEW_FIELDS_USING(field_idx-1)%PTR=>GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
                ENDIF
              ENDDO !field_idx
              GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING=GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS% &
                & NUMBER_OF_FIELDS_USING-1
              IF(ASSOCIATED(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)) &
                & DEALLOCATE(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)
              GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING=>NEW_FIELDS_USING
            ELSE
              !??? Error
            ENDIF
          ENDIF
        ENDIF
        CALL FIELD_FINALISE(FIELD,ERR,ERROR,*999)
        IF(FIELDS%NUMBER_OF_FIELDS>1) THEN
          ALLOCATE(NEW_FIELDS(FIELDS%NUMBER_OF_FIELDS-1),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate new fields.",ERR,ERROR,*999)
          DO field_idx=1,FIELDS%NUMBER_OF_FIELDS
            IF(field_idx<field_position) THEN
              NEW_FIELDS(field_idx)%PTR=>FIELDS%FIELDS(field_idx)%PTR
            ELSE IF(field_idx>field_position) THEN
              FIELDS%FIELDS(field_idx)%PTR%GLOBAL_NUMBER=FIELDS%FIELDS(field_idx)%PTR%GLOBAL_NUMBER-1
              NEW_FIELDS(field_idx-1)%PTR=>FIELDS%FIELDS(field_idx)%PTR
            ENDIF
          ENDDO !field_no
          DEALLOCATE(FIELDS%FIELDS)
          FIELDS%FIELDS=>NEW_FIELDS
          FIELDS%NUMBER_OF_FIELDS=FIELDS%NUMBER_OF_FIELDS-1
        ELSE
          DEALLOCATE(FIELDS%FIELDS)
          FIELDS%NUMBER_OF_FIELDS=0
        ENDIF
      ELSE
        CALL FlagError("Field fields is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_FIELDS)) DEALLOCATE(NEW_FIELDS)
    IF(ASSOCIATED(NEW_FIELDS_USING)) DEALLOCATE(NEW_FIELDS_USING)
    ERRORSEXITS("FIELD_DESTROY",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DESTROY

  !
  !================================================================================================================================
  !

  !>Checks the field dimension for a field variable.
  SUBROUTINE FIELD_DIMENSION_CHECK(FIELD,VARIABLE_TYPE,DIMENSION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DIMENSION_TYPE !<The field dimension to check \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DIMENSION_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            SELECT CASE(DIMENSION_TYPE)
            CASE(FIELD_SCALAR_DIMENSION_TYPE)
              IF(FIELD_VARIABLE%DIMENSION/=FIELD_SCALAR_DIMENSION_TYPE) THEN
                LOCAL_ERROR="Invalid dimension type. The dimension type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DIMENSION,"*",ERR,ERROR))// &
                  & " which is not a scalar field."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_VECTOR_DIMENSION_TYPE)
              IF(FIELD_VARIABLE%DIMENSION/=FIELD_VECTOR_DIMENSION_TYPE) THEN
                LOCAL_ERROR="Invalid dimension type. The dimension type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DIMENSION,"*",ERR,ERROR))// &
                  & " which is not a vector field."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_TENSOR_DIMENSION_TYPE)
              IF(FIELD_VARIABLE%DIMENSION/=FIELD_TENSOR_DIMENSION_TYPE) THEN
                LOCAL_ERROR="Invalid dimension type. The dimension type for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%DIMENSION,"*",ERR,ERROR))// &
                  & " which is not a tensor field."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF

           CASE DEFAULT
              LOCAL_ERROR="The specified dimension type of "//TRIM(NumberToVString(DIMENSION_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DIMENSION_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_DIMENSION_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field dimension for a field variable. \see OpenCMISS::Iron::cmfe_FieldDimensionGet
  SUBROUTINE FIELD_DIMENSION_GET(FIELD,VARIABLE_TYPE,DIMENSION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DIMENSION !<On return, the field dimension to get \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DIMENSION_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            DIMENSION=FIELD_VARIABLE%DIMENSION
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DIMENSION_GET")
    RETURN
999 ERRORSEXITS("FIELD_DIMENSION_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable.
  SUBROUTINE FIELD_DIMENSION_SET(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_DIMENSION !<The field dimension to set/change \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_COMPONENTS,NEW_NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), ALLOCATABLE :: NEW_INTERPOLATION_TYPE(:,:),NEW_MESH_COMPONENT_NUMBER(:,:)
    LOGICAL, ALLOCATABLE :: NEW_COMPONENT_LABELS_LOCKED(:,:),NEW_INTERPOLATION_TYPE_LOCKED(:,:), &
      & NEW_MESH_COMPONENT_NUMBER_LOCKED(:,:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(VARYING_STRING), ALLOCATABLE :: NEW_COMPONENT_LABELS(:,:)

    ENTERS("FIELD_DIMENSION_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The field dimension has been locked for for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(FIELD_DIMENSION)
                CASE(FIELD_SCALAR_DIMENSION_TYPE)
                  IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)/=1) THEN
                    NUMBER_OF_COMPONENTS=SIZE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE,1)
                    NEW_NUMBER_OF_COMPONENTS=1
                    !Here, new number of components always >= old_number_of_components
                    DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                      IF (FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx) > NEW_NUMBER_OF_COMPONENTS) THEN
                        IF (variable_idx /= VARIABLE_TYPE) THEN
                          NEW_NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx)
                        ENDIF
                      ENDIF
                    ENDDO
                    ALLOCATE(NEW_COMPONENT_LABELS(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate new component labels.",ERR,ERROR,*999)
                    ALLOCATE(NEW_COMPONENT_LABELS_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate new component labels locked.",ERR,ERROR,*999)
                    ALLOCATE(NEW_INTERPOLATION_TYPE(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate new interpolation type.",ERR,ERROR,*999)
                    ALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate new interpolation type locked.",ERR,ERROR,*999)
                    ALLOCATE(NEW_MESH_COMPONENT_NUMBER(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate new mesh component number.",ERR,ERROR,*999)
                    ALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate new mesh component number locked.",ERR,ERROR,*999)
                    NEW_COMPONENT_LABELS(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_COMPONENT_LABELS_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_INTERPOLATION_TYPE(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_INTERPOLATION_TYPE_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_MESH_COMPONENT_NUMBER(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_MESH_COMPONENT_NUMBER_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)

                    CALL MOVE_ALLOC(NEW_COMPONENT_LABELS,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS)
                    CALL MOVE_ALLOC(NEW_COMPONENT_LABELS_LOCKED,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)
                    CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE)
                    CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE_LOCKED,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)
                    CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)
                    CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER_LOCKED,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)

                    FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)=1
                  ENDIF
                  FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE)=FIELD_SCALAR_DIMENSION_TYPE
                CASE(FIELD_VECTOR_DIMENSION_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE)=FIELD_VECTOR_DIMENSION_TYPE
                CASE(FIELD_TENSOR_DIMENSION_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE)=FIELD_TENSOR_DIMENSION_TYPE
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The specified field dimension of "//TRIM(NumberToVString(FIELD_DIMENSION,"*",ERR,ERROR))// &
                    & " is invalid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DIMENSION_SET")
    RETURN
999 IF(ALLOCATED(NEW_COMPONENT_LABELS)) DEALLOCATE(NEW_COMPONENT_LABELS)
    IF(ALLOCATED(NEW_COMPONENT_LABELS_LOCKED)) DEALLOCATE(NEW_COMPONENT_LABELS_LOCKED)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE)) DEALLOCATE(NEW_INTERPOLATION_TYPE)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED)
    ERRORSEXITS("FIELD_DIMENSION_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable  and locks so that no further changes can be made.
  SUBROUTINE FIELD_DIMENSION_SET_AND_LOCK(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_DIMENSION !<The field dimension to set/change \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_DIMENSION_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DIMENSION_SET(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_DIMENSION_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_DIMENSION_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Finalises a field and deallocates all memory.
  SUBROUTINE FIELD_FINALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELD%LABEL=""
      CALL FIELD_SCALINGS_FINALISE(FIELD,ERR,ERROR,*999)
      CALL FIELD_VARIABLES_FINALISE(FIELD,ERR,ERROR,*999)
      CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%CREATE_VALUES_CACHE,ERR,ERROR,*999)
      CALL FIELD_GEOMETRIC_PARAMETERS_FINALISE(FIELD%GEOMETRIC_FIELD_PARAMETERS,ERR,ERROR,*999)
      IF(ALLOCATED(FIELD%VARIABLE_TYPE_MAP)) DEALLOCATE(FIELD%VARIABLE_TYPE_MAP)
      DEALLOCATE(FIELD)
    ENDIF

    EXITS("FIELD_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field
  SUBROUTINE FIELD_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the new field to initialise. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,variable_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      CALL FlagError("Field is already associated.",ERR,ERROR,*998)
    ELSE
      ALLOCATE(FIELD,STAT=ERR)
      IF(ERR/=0) CALL FlagError("Could not allocate field.",ERR,ERROR,*999)
      FIELD%GLOBAL_NUMBER=0
      FIELD%USER_NUMBER=0
      FIELD%LABEL=""
      FIELD%FIELD_FINISHED=.FALSE.
      NULLIFY(FIELD%FIELDS)
      NULLIFY(FIELD%REGION)
      FIELD%TYPE=FIELD_GEOMETRIC_TYPE
      FIELD%DEPENDENT_TYPE=FIELD_INDEPENDENT_TYPE
      NULLIFY(FIELD%DECOMPOSITION)
      FIELD%NUMBER_OF_VARIABLES=0
      NULLIFY(FIELD%GEOMETRIC_FIELD)
      NULLIFY(FIELD%GEOMETRIC_FIELD_PARAMETERS)
      NULLIFY(FIELD%CREATE_VALUES_CACHE)
      ALLOCATE(FIELD%VARIABLE_TYPE_MAP(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
      IF(ERR/=0) CALL FlagError("Could not allocate field variable type map.",ERR,ERROR,*999)
      DO variable_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
        NULLIFY(FIELD%VARIABLE_TYPE_MAP(variable_type_idx)%PTR)
      ENDDO !variable_type_idx
    ENDIF

    EXITS("FIELD_INITIALISE")
    RETURN
999 CALL FIELD_FINALISE(FIELD,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INITIALISE",ERR,ERROR)
    RETURN 1

  END SUBROUTINE FIELD_INITIALISE

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a gauss point to give an interpolated point. PARTIAL_DERIVATIVE_TYPE controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name XEXG, ZEXG
  SUBROUTINE FIELD_INTERPOLATE_GAUSS(PARTIAL_DERIVATIVE_TYPE,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATED_POINT, &
      & ERR,ERROR,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARTIAL_DERIVATIVE_TYPE !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: QUADRATURE_SCHEME !<The quadrature scheme of the Gauss points \see BASIS_ROUTINES_QuadratureSchemes,BASIS_ROUTINES
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER !<The number of the Gauss point to interpolate the field at
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu
    INTEGER(INTG) :: startComponentIdx,endComponentIdx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATE_GAUSS",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
        FIELD=>INTERPOLATION_PARAMETERS%FIELD
        IF(ASSOCIATED(FIELD)) THEN
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=-INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                  & PTR%NUMBER_OF_COMPONENTS+1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            startComponentIdx=1
            endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          SELECT CASE(PARTIAL_DERIVATIVE_TYPE)
          CASE(NO_PART_DERIV)
            DO component_idx=startComponentidx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
                  & PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(GAUSS_POINT_NUMBER, &
                  & component_idx)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                & ERR,ERROR,*999)
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=NO_PART_DERIV
          CASE(FIRST_PART_DERIV)
            DO component_idx=startComponentidx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
                  & PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
                    & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=FIRST_PART_DERIV
          CASE(SECOND_PART_DERIV)
            DO component_idx=startComponentidx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
                    & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO! nu
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=SECOND_PART_DERIV
          CASE DEFAULT
            LOCAL_ERROR="The partial derivative type of "//TRIM(NumberToVString(PARTIAL_DERIVATIVE_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FlagError("The interpolation parameters field is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolated point is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_GAUSS")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_GAUSS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATE_GAUSS

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE FIELD_INTERPOLATE_NODE(PHYSICAL_DERIVATIVE_TYPE,PARAMETER_SET_TYPE,COMPONENT_NUMBER,NODE_NUMBER, &
    & PHYSICAL_POINT,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PHYSICAL_DERIVATIVE_TYPE !<The physical derivative type of the field interpolation \see CONSTANTS_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The parameter set of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number to field that contains the node
    INTEGER(INTG), INTENT(IN) :: NODE_NUMBER !<The node number in the component to interpolate the field at
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,element,elem_idx,LOCAL_NODE_NUMBER,local_node_idx,NUMBER_OF_SURROUNDING_ELEMENTS, &
      & partial_deriv_idx,xi_idx
    REAL(DP) :: XI(3),DX_DXI(3,3),DXI_DX(3,3),DET_DX_DXI
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEM_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATE_NODE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      FIELD_INTERPOLATED_POINT=>PHYSICAL_POINT%FIELD_INTERPOLATED_POINT
      IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
        GEOMETRIC_INTERPOLATED_POINT=>PHYSICAL_POINT%GEOMETRIC_INTERPOLATED_POINT
        IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
          FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
          IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
            GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
            IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
              FIELD_VARIABLE=>FIELD_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
              IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                GEOMETRIC_VARIABLE=>GEOMETRIC_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
                IF(ASSOCIATED(GEOMETRIC_VARIABLE)) THEN
                  FIELD=>FIELD_VARIABLE%FIELD
                  IF(ASSOCIATED(FIELD)) THEN
                    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
                    IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          NODES_TOPOLOGY=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(NODES_TOPOLOGY)) THEN
                            IF(NODE_NUMBER>0.AND.NODE_NUMBER<=NODES_TOPOLOGY%NUMBER_OF_NODES) THEN
                              ELEM_TOPOLOGY=>DOMAIN_TOPOLOGY%ELEMENTS
                              IF(ASSOCIATED(ELEM_TOPOLOGY)) THEN
                                PHYSICAL_POINT%VALUES=0.0_DP
                                IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                  NUMBER_OF_SURROUNDING_ELEMENTS=1
                                ELSE
                                  NUMBER_OF_SURROUNDING_ELEMENTS=NODES_TOPOLOGY%NODES(NODE_NUMBER)% &
                                    & NUMBER_OF_SURROUNDING_ELEMENTS
                                  PHYSICAL_POINT%VALUES=0.0_DP
                                ENDIF
                                !Loop over the elements surrounding the node
                                DO elem_idx=1,NUMBER_OF_SURROUNDING_ELEMENTS
                                  element=NODES_TOPOLOGY%NODES(NODE_NUMBER)%SURROUNDING_ELEMENTS(elem_idx)
                                  CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,element, &
                                    & FIELD_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                  BASIS=>ELEM_TOPOLOGY%ELEMENTS(element)%BASIS
                                  IF(ASSOCIATED(BASIS)) THEN
                                    LOCAL_NODE_NUMBER=0
                                    DO local_node_idx=1,BASIS%NUMBER_OF_NODES
                                      IF(ELEM_TOPOLOGY%ELEMENTS(element)%ELEMENT_NODES(local_node_idx)==NODE_NUMBER) THEN
                                        LOCAL_NODE_NUMBER=local_node_idx
                                        EXIT
                                      ENDIF
                                    ENDDO
                                    IF(LOCAL_NODE_NUMBER/=0) THEN
                                      CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,LOCAL_NODE_NUMBER,XI,ERR,ERROR,*999)
                                      SELECT CASE(PHYSICAL_DERIVATIVE_TYPE)
                                      CASE(NO_PHYSICAL_DERIV)
                                        DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                          SELECT CASE(FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                          CASE(FIELD_CONSTANT_INTERPOLATION)
                                            PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                              & PARAMETERS(1,component_idx)
                                          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                            PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                              & PARAMETERS(1,component_idx)
                                          CASE(FIELD_FACE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_LINE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_NODE_BASED_INTERPOLATION)
                                            PHYSICAL_POINT%VALUES(component_idx)=BASIS_INTERPOLATE_XI( &
                                              & FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR,NO_PART_DERIV, &
                                              & XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                                            IF(ERR/=0) GOTO 999
                                          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                            CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                            CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                            CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                          CASE DEFAULT
                                            LOCAL_ERROR="The field component interpolation type of "// &
                                              & TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(component_idx)% &
                                              & INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component index "// &
                                              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
                                          END SELECT
                                        ENDDO! component_idx
                                        PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=NO_PHYSICAL_DERIV
                                      CASE(GRADIENT_PHYSICAL_DERIV)
                                        DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                          SELECT CASE(FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                          CASE(FIELD_CONSTANT_INTERPOLATION)
                                            !There is no gradient for constant interpolation
                                            PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                            !There is no graident for element interpolation
                                            PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                          CASE(FIELD_FACE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet imp here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_LINE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                            !!!!!
                                            CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet imp here", &
                                              & ERR,ERROR,*999)
                                            !!!!!
                                          CASE(FIELD_NODE_BASED_INTERPOLATION)
                                            CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                              & GEOMETRIC_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                            !Now process all the first partial derivatives
                                            DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                              partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                              !Interpolate the field
                                              FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                & BASIS_INTERPOLATE_XI(FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR, &
                                                & partial_deriv_idx,XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                & component_idx),ERR,ERROR)
                                              IF(ERR/=0) GOTO 999
                                              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx),ERR,ERROR,*999)
                                              GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                & BASIS_INTERPOLATE_XI(GEOMETRIC_INTERPOLATION_PARAMETERS%BASES(component_idx)% &
                                                & PTR,partial_deriv_idx,XI,GEOMETRIC_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                & component_idx),ERR,ERROR)
                                              IF(ERR/=0) GOTO 999
                                              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                & GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx), &
                                                & ERR,ERROR,*999)
                                              DX_DXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT% &
                                                & VALUES(component_idx,partial_deriv_idx)
                                            ENDDO !xi_idx
                                          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                            CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                            CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                            CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                          CASE DEFAULT
                                            LOCAL_ERROR="The field component interpolation type of "// &
                                              & TRIM(NumberToVString(FIELD_INTERPOLATION_PARAMETERS% &
                                              & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                              & " is invalid for component index "// &
                                              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
                                          END SELECT
                                        ENDDO! component_idx
                                        !Form the physical derivative
                                        CALL INVERT(DX_DXI,DXI_DX,DET_DX_DXI,ERR,ERROR,*999)
                                        DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                          DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                            partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                            PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)+ &
                                              & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx)* &
                                              & DXI_DX(xi_idx,component_idx)
                                          ENDDO !xi_idx
                                        ENDDO !component_idx
                                        PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=GRADIENT_PHYSICAL_DERIV
                                      CASE DEFAULT
                                        LOCAL_ERROR="The physical derivative type of "// &
                                          & TRIM(NumberToVString(PHYSICAL_DERIVATIVE_TYPE,"*",ERR,ERROR))//" is invalid."
                                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      LOCAL_ERROR="Could not find the local node for node "// &
                                        & TRIM(NumberToVString(NODE_NUMBER,"*",ERR,ERROR))//" in element number "// &
                                        & TRIM(NumberToVString(element,"*",ERR,ERROR))//"."
                                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    LOCAL_ERROR="The basis for element "//TRIM(NumberToVString(element,"*",ERR,ERROR))// &
                                      & " is not associated."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  ENDIF
                                ENDDO !elem_idx
                                IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                  !Now calculate the average of the interpolated physical point
                                  DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                    CASE(FIELD_CONSTANT_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                                      PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)/ &
                                        & REAL(NUMBER_OF_SURROUNDING_ELEMENTS,DP)
                                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                      CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                    CASE DEFAULT
                                      LOCAL_ERROR="The field component interpolation type of "// &
                                        & TRIM(NumberToVString(FIELD_INTERPOLATION_PARAMETERS% &
                                        & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                        & " is invalid for component index "// &
                                        & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
                                    END SELECT
                                  ENDDO !component_idx
                                ENDIF
                              ELSE
                                CALL FlagError("Domain element topology is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="The specified node number of "//TRIM(NumberToVString(NODE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid. The node number needs to be > 0 and <= "// &
                                & TRIM(NumberToVString(NODES_TOPOLOGY%NUMBER_OF_NODES,"*",ERR,ERROR))//"."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Nodes topology is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The specified component number of "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid. The component number must be > 0 and <= "// &
                        & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The field variable field is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The geometric interpolation parameters field variable is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("The field interpolation parameters field variable is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Geometric interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FlagError("Field interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Physical point geometric interpolated point is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Physical point field interpolated point is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Physical point is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_NODE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_NODE",ERR,ERROR)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_NODE

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node in another field. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE FIELD_INTERPOLATE_FIELD_NODE(PHYSICAL_DERIVATIVE_TYPE,PARAMETER_SET_TYPE,FIELD,VARIABLE_TYPE,COMPONENT_NUMBER, &
    & NODE_NUMBER,PHYSICAL_POINT,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PHYSICAL_DERIVATIVE_TYPE !<The physical derivative type of the field interpolation \see CONSTANTS_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The parameter set of the field to interpolate.
    TYPE(FIELD_TYPE), POINTER :: FIELD !<The field containing the node to interpolate at.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type containing the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number to field that contains the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: NODE_NUMBER !<The node number in the field variable component to interpolate the field at
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,element,elem_idx,LOCAL_NODE_NUMBER,local_node_idx,NUMBER_OF_SURROUNDING_ELEMENTS, &
      & partial_deriv_idx,xi_idx
    REAL(DP) :: XI(3),DX_DXI(3,3),DXI_DX(3,3),DET_DX_DXI
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEM_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: INTERP_FIELD
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE,INTERP_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATE_FIELD_NODE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      FIELD_INTERPOLATED_POINT=>PHYSICAL_POINT%FIELD_INTERPOLATED_POINT
      IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
        GEOMETRIC_INTERPOLATED_POINT=>PHYSICAL_POINT%GEOMETRIC_INTERPOLATED_POINT
        IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
          FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
          IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
            GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
            IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
              INTERP_VARIABLE=>FIELD_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
              IF(ASSOCIATED(INTERP_VARIABLE)) THEN
                GEOMETRIC_VARIABLE=>GEOMETRIC_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
                IF(ASSOCIATED(GEOMETRIC_VARIABLE)) THEN
                  INTERP_FIELD=>INTERP_VARIABLE%FIELD
                  IF(ASSOCIATED(INTERP_FIELD)) THEN
                    NULLIFY(COORDINATE_SYSTEM)
                    CALL FIELD_COORDINATE_SYSTEM_GET(INTERP_FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
                    IF(ASSOCIATED(FIELD)) THEN
                      NULLIFY(FIELD_VARIABLE)
                      CALL Field_VariableGet(FIELD,VARIABLE_TYPE,FIELD_VARIABLE,ERR,ERROR,*999)
                      IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                        DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                        IF(ASSOCIATED(DOMAIN)) THEN
                          DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                          IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                            NODES_TOPOLOGY=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(NODES_TOPOLOGY)) THEN
                              IF(NODE_NUMBER>0.AND.NODE_NUMBER<=NODES_TOPOLOGY%NUMBER_OF_NODES) THEN
                                ELEM_TOPOLOGY=>DOMAIN_TOPOLOGY%ELEMENTS
                                IF(ASSOCIATED(ELEM_TOPOLOGY)) THEN
                                  PHYSICAL_POINT%VALUES=0.0_DP
                                  IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                    NUMBER_OF_SURROUNDING_ELEMENTS=1
                                  ELSE
                                    NUMBER_OF_SURROUNDING_ELEMENTS=NODES_TOPOLOGY%NODES(NODE_NUMBER)% &
                                      & NUMBER_OF_SURROUNDING_ELEMENTS
                                    PHYSICAL_POINT%VALUES=0.0_DP
                                  ENDIF
                                  !Loop over the elements surrounding the node
                                  DO elem_idx=1,NUMBER_OF_SURROUNDING_ELEMENTS
                                    element=NODES_TOPOLOGY%NODES(NODE_NUMBER)%SURROUNDING_ELEMENTS(elem_idx)
                                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,element, &
                                      & FIELD_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                    BASIS=>ELEM_TOPOLOGY%ELEMENTS(element)%BASIS
                                    IF(ASSOCIATED(BASIS)) THEN
                                      LOCAL_NODE_NUMBER=0
                                      DO local_node_idx=1,BASIS%NUMBER_OF_NODES
                                        IF(ELEM_TOPOLOGY%ELEMENTS(element)%ELEMENT_NODES(local_node_idx)==NODE_NUMBER) THEN
                                          LOCAL_NODE_NUMBER=local_node_idx
                                          EXIT
                                        ENDIF
                                      ENDDO
                                      IF(LOCAL_NODE_NUMBER/=0) THEN
                                        CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,LOCAL_NODE_NUMBER,XI,ERR,ERROR,*999)
                                        SELECT CASE(PHYSICAL_DERIVATIVE_TYPE)
                                        CASE(NO_PHYSICAL_DERIV)
                                          DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                            SELECT CASE(INTERP_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                            CASE(FIELD_CONSTANT_INTERPOLATION)
                                              PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                                & PARAMETERS(1,component_idx)
                                            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                              PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                                & PARAMETERS(1,component_idx)
                                            CASE(FIELD_FACE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet imp here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_LINE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet imp here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_NODE_BASED_INTERPOLATION)
                                              PHYSICAL_POINT%VALUES(component_idx)=BASIS_INTERPOLATE_XI( &
                                                & FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR,NO_PART_DERIV, &
                                                & XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                                              IF(ERR/=0) GOTO 999
                                            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                              CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                              CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                              CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                            CASE DEFAULT
                                              LOCAL_ERROR="The field component interpolation type of "// &
                                                & TRIM(NumberToVString(INTERP_VARIABLE%COMPONENTS(component_idx)% &
                                                & INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component index "// &
                                                & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
                                            END SELECT
                                          ENDDO! component_idx
                                          PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=NO_PHYSICAL_DERIV
                                        CASE(GRADIENT_PHYSICAL_DERIV)
                                          DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                            SELECT CASE(INTERP_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                            CASE(FIELD_CONSTANT_INTERPOLATION)
                                              !There is no gradient for constant interpolation
                                              PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                              !There is no graident for element interpolation
                                              PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                            CASE(FIELD_FACE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION not yet imp here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_LINE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                              !!!!!
                                              CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION not yet imp here", &
                                                & ERR,ERROR,*999)
                                              !!!!!
                                            CASE(FIELD_NODE_BASED_INTERPOLATION)
                                              CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                                & GEOMETRIC_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                              !Now process all the first partial derivatives
                                              DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                                partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                                !Interpolate the field
                                                FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                  & BASIS_INTERPOLATE_XI(FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR, &
                                                  & partial_deriv_idx,XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                  & component_idx),ERR,ERROR)
                                                IF(ERR/=0) GOTO 999
                                                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                  & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx),ERR,ERROR,*999)
                                                GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                  & BASIS_INTERPOLATE_XI(GEOMETRIC_INTERPOLATION_PARAMETERS%BASES(component_idx)% &
                                                  & PTR,partial_deriv_idx,XI,GEOMETRIC_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                  & component_idx),ERR,ERROR)
                                                IF(ERR/=0) GOTO 999
                                                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                  & GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx), &
                                                  & ERR,ERROR,*999)
                                                DX_DXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT% &
                                                  & VALUES(component_idx,partial_deriv_idx)
                                              ENDDO !xi_idx
                                            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                              CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                              CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                              CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                            CASE DEFAULT
                                              LOCAL_ERROR="The field component interpolation type of "// &
                                                & TRIM(NumberToVString(FIELD_INTERPOLATION_PARAMETERS% &
                                                & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                                & " is invalid for component index "// &
                                                & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
                                            END SELECT
                                          ENDDO! component_idx
                                          !Form the physical derivative
                                          CALL INVERT(DX_DXI,DXI_DX,DET_DX_DXI,ERR,ERROR,*999)
                                          DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                            DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                              partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                              PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)+ &
                                                & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx)* &
                                                & DXI_DX(xi_idx,component_idx)
                                            ENDDO !xi_idx
                                          ENDDO !component_idx
                                          PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=GRADIENT_PHYSICAL_DERIV
                                        CASE DEFAULT
                                          LOCAL_ERROR="The physical derivative type of "// &
                                            & TRIM(NumberToVString(PHYSICAL_DERIVATIVE_TYPE,"*",ERR,ERROR))//" is invalid."
                                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                        END SELECT
                                      ELSE
                                        LOCAL_ERROR="Could not find the local node for node "// &
                                          & TRIM(NumberToVString(NODE_NUMBER,"*",ERR,ERROR))//" in element number "// &
                                          & TRIM(NumberToVString(element,"*",ERR,ERROR))//"."
                                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                      ENDIF
                                    ELSE
                                      LOCAL_ERROR="The basis for element "//TRIM(NumberToVString(element,"*",ERR,ERROR))// &
                                        & " is not associated."
                                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                    ENDIF
                                  ENDDO !elem_idx
                                  IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                    !Now calculate the average of the interpolated physical point
                                    DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                      SELECT CASE(INTERP_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                      CASE(FIELD_CONSTANT_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_FACE_BASED_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_LINE_BASED_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_NODE_BASED_INTERPOLATION)
                                        PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)/ &
                                          & REAL(NUMBER_OF_SURROUNDING_ELEMENTS,DP)
                                      CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                      CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                      CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                        CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                      CASE DEFAULT
                                        LOCAL_ERROR="The field component interpolation type of "// &
                                          & TRIM(NumberToVString(INTERP_VARIABLE%COMPONENTS(component_idx)% &
                                          & INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                          & " is invalid for component index "// &
                                          & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
                                      END SELECT
                                    ENDDO !component_idx
                                  ENDIF
                                ELSE
                                  CALL FlagError("Domain element topology is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="The specified node number of "//TRIM(NumberToVString(NODE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid. The node number needs to be > 0 and <= "// &
                                  & TRIM(NumberToVString(NODES_TOPOLOGY%NUMBER_OF_NODES,"*",ERR,ERROR))//"."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FlagError("Nodes topology is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The specified component number of "// &
                          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid. The component number must be > 0 and <= "// &
                          & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The field variable field is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("The geometric interpolation parameters field variable is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("The field interpolation parameters field variable is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Geometric interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FlagError("Field interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Physical point geometric interpolated point is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Physical point field interpolated point is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Physical point is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_FIELD_NODE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_FIELD_NODE",ERR,ERROR)
    RETURN 1

  END SUBROUTINE FIELD_INTERPOLATE_FIELD_NODE

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a face gauss point to give an interpolated point. PARTIAL_DERIVATIVE_TYPE controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated.
  SUBROUTINE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS(PARTIAL_DERIVATIVE_TYPE,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER, &
    & GAUSS_POINT_NUMBER,INTERPOLATED_POINT,ERR,ERROR,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARTIAL_DERIVATIVE_TYPE !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: QUADRATURE_SCHEME !<The quadrature scheme of the Gauss points \see BASIS_ROUTINES_QuadratureSchemes,BASIS_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_FACE_NUMBER !<The index number of the face to interpolate on
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER !<The number of the face Gauss point to interpolate the field at
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu,startComponentIdx,endComponentIdx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
        FIELD=>INTERPOLATION_PARAMETERS%FIELD
        IF(ASSOCIATED(FIELD)) THEN
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=-INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                  & PTR%NUMBER_OF_COMPONENTS+1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            startComponentIdx=1
            endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          SELECT CASE(PARTIAL_DERIVATIVE_TYPE)
          CASE(NO_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
!                 INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
!                   & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
!                   & PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                & ERR,ERROR,*999)
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=NO_PART_DERIV
          CASE(FIRST_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
!                 INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
!                   & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
!                   & PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
!                   INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
!                     & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
!                     & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,nu,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=FIRST_PART_DERIV
          CASE(SECOND_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
!                   INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
!                     & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
!                     & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,nu,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO! nu
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=SECOND_PART_DERIV
          CASE DEFAULT
            LOCAL_ERROR="The partial derivative type of "//TRIM(NumberToVString(PARTIAL_DERIVATIVE_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FlagError("The interpolation parameters field is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolated point is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a xi location to give an interpolated point. XI is the element location to be interpolated at. PARTIAL_DERIVATIVE_TYPE controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name PXI
  SUBROUTINE FIELD_INTERPOLATE_XI(PARTIAL_DERIVATIVE_TYPE,XI,INTERPOLATED_POINT,ERR,ERROR,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARTIAL_DERIVATIVE_TYPE !<The partial derivative type of the provide field interpolation
    REAL(DP), INTENT(IN) :: XI(:) !<XI(ni). The ni'th Xi coordinate to evaluate the field at
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Xi point
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu,startComponentIdx,endComponentIdx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATE_XI",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
        !!TODO: Fix this check. You can have less Xi directions than the mesh number of dimensions e.g., interpolating a line
        !IF(SIZE(XI,1)>=INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS) THEN
        FIELD=>INTERPOLATION_PARAMETERS%FIELD
        IF(ASSOCIATED(FIELD)) THEN
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=-INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                  & PTR%NUMBER_OF_COMPONENTS+1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            startComponentIdx=1
            endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          SELECT CASE(PARTIAL_DERIVATIVE_TYPE)
          CASE(NO_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                  & BASES(component_idx)%PTR,NO_PART_DERIV,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                & ERR,ERROR,*999)
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=NO_PART_DERIV
          CASE(FIRST_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                  & BASES(component_idx)%PTR,NO_PART_DERIV,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx), &
                    & ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=FIRST_PART_DERIV
          CASE(SECOND_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx), &
                    & ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO! nu
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=SECOND_PART_DERIV
          CASE DEFAULT
            LOCAL_ERROR="The partial derivative type of "//TRIM(NumberToVString(PARTIAL_DERIVATIVE_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FlagError("The interpolation parameters field is not associated.",ERR,ERROR,*999)
        ENDIF
        !ELSE
        !  LOCAL_ERROR="Invalid number of Xi directions. The supplied Xi has "// &
        !    & TRIM(NumberToVString(SIZE(XI,1),"*",ERR,ERROR))//" directions and the required number of directions is "// &
        !    & TRIM(NumberToVString(INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS, &
        !    & "*",ERR,ERROR))
        !  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        !ENDIF
      ELSE
        CALL FlagError("Interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolated point is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATE_XI")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATE_XI",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATE_XI

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a interpolated point metrics in a field.
  SUBROUTINE Field_PositionNormalTangentsCalculateIntPtMetric(interpolatedPointMetrics,reverseNormal,position,normal,tangents, &
    & err,error,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER, INTENT(IN) :: interpolatedPointMetrics !<A pointer to the interpolated point metric information to calculate the position etc. for
    LOGICAL, INTENT(IN) :: reverseNormal !<Reverse normal diretion if .TRUE.
    REAL(DP), INTENT(OUT) :: position(:) !<position(coordinate_idx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: normal(:) !<normal(coordinate_idx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: tangents(:,:) !<tangents(coordinate_idx,tangent_idx), on exit the tangent vectors for the tangent_idx'th tangent at the node. There are number_of_xi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: coordinateIdx,numberOfXDimensions,numberOfXiDimensions,xiIdx
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: interpolatedPoint
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_PositionNormalTangentsCalculateIntPtMetric",err,error,*999)

    IF(.NOT.ASSOCIATED(interpolatedPointMetrics)) CALL FlagError("Interpolated point metrics is not associated.",err,error,*999)
    numberOfXDimensions=interpolatedPointMetrics%NUMBER_OF_X_DIMENSIONS
    numberOfXiDimensions=interpolatedPointMetrics%NUMBER_OF_XI_DIMENSIONS
    IF(SIZE(position,1)<numberOfXDimensions) THEN
      localError="The size of position of "//TRIM(NumberToVString(SIZE(position,1),"*",err,error))// &
        & " is too small. The size must be >= "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(normal,1)<numberOfXDimensions) THEN
      localError="The size of normal of "//TRIM(NumberToVString(SIZE(normal,1),"*",err,error))// &
        & " is too small. The size must be >= "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,1)<numberOfXDimensions) THEN
      localError="The size of the 1st dimension of tangents of "// &
        & TRIM(NumberToVString(SIZE(tangents,1),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfXDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(SIZE(tangents,2)<numberOfXiDimensions) THEN
      localError="The size of the 2nd dimension of tangents of "// &
        & TRIM(NumberToVString(SIZE(tangents,2),"*",err,error))//" is too small. The size must be >= "// &
        & TRIM(NumberToVString(numberOfXiDimensions,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    interpolatedPoint=>interpolatedPointMetrics%INTERPOLATED_POINT
    IF(.NOT.ASSOCIATED(interpolatedPoint)) &
      & CALL FlagError("Interpolated point metrics interpolated point is not associated.",err,error,*999)

    position(1:numberOfXDimensions)=interpolatedPoint%values(1:numberOfXDimensions,NO_PART_DERIV)
    normal(1:numberOfXDimensions)=0.0_DP
    SELECT CASE(numberOfXiDimensions)
    CASE(1) !For lines
      normal(1:numberOfXDimensions)=0.0_DP
      DO coordinateIdx=1,numberOfXDimensions
        tangents(coordinateIdx,1)=interpolatedPointMetrics%DX_DXI(coordinateIdx,1)
      ENDDO !coordinateIdx
      CALL Normalise(tangents(1:numberOfXDimensions,1),tangents(1:numberOfXDimensions,1),err,error,*999)
      SELECT CASE(numberOfXDimensions)
      CASE(2)
        normal(1)=-tangents(2,1)
        normal(2)=tangents(1,1)
      CASE(3)
        CALL FlagError("Not implemented.",err,error,*999)
      CASE DEFAULT
        localError="The number of coordinate dimensions of "//TRIM(NumberToVString(numberOfXDimensions,"*",err,error))// &
          & " is invalid."
        CALL FlagError(localError,err,error,*999)
      END SELECT
    CASE(2) !For faces
      DO xiIdx=1,numberOfXiDimensions
        DO coordinateIdx=1,numberOfXDimensions
          tangents(coordinateIdx,xiIdx)=interpolatedPointMetrics%DX_DXI(coordinateIdx,xiIdx)
        ENDDO !coordinateIdx
        CALL Normalise(tangents(1:numberOfXDimensions,xiIdx),tangents(1:numberOfXDimensions,xiIdx),err,error,*999)
      ENDDO !xiIdx
      CALL CrossProduct(tangents(1:numberOfXDimensions,1),tangents(1:numberOfXDimensions,2),normal,err,error,*999)
    CASE DEFAULT
      localError="The interpolated metrics must be for lines/faces, dimension of " &
        & //TRIM(NumberToVString(numberOfXiDimensions,"*",err,error))//" is invalid."
      CALL FlagError(localError,err,error,*999)
    END SELECT
    IF(reverseNormal) normal(1:numberOfXDimensions)=-normal(1:numberOfXDimensions)

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolated point metrics data:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of X dimensions = ",numberOfXDimensions,err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Xi dimensions = ",numberOfXiDimensions,err,error,*999)
      CALL WriteStringVector(GENERAL_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,position, &
        & '("  Position    :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      CALL WriteStringVector(GENERAL_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,normal, &
        & '("  Normal      :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"  Tangents:",err,error,*999)
      DO xiIdx=1,numberOfXiDimensions
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Tangent : ",xiIdx,err,error,*999)
        CALL WriteStringVector(GENERAL_OUTPUT_TYPE,1,1,numberOfXDimensions,3,3,tangents(:,xiIdx), &
          & '("      Tangent :",3(X,E13.6))','(15X,3(X,E13.6))',err,error,*999)
      ENDDO !xiIdx
    ENDIF

    EXITS("Field_PositionNormalTangentsCalculateIntPtMetric")
    RETURN
999 ERRORS("Field_PositionNormalTangentsCalculateIntPtMetric",err,error)
    EXITS("Field_PositionNormalTangentsCalculateIntPtMetric")
    RETURN 1

  END SUBROUTINE Field_PositionNormalTangentsCalculateIntPtMetric

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a node in a field. If the node is internal to the mesh the normal and tangents are zero.
  SUBROUTINE Field_PositionNormalTangentsCalculateNode(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LOCAL_NODE_NUMBER, &
    & POSITION,NORMAL,TANGENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: FIELD !<A pointer to the field to interpolate the geometric information for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to compute the geometric information for
    REAL(DP), INTENT(OUT) :: POSITION(:) !<POSITION(coordinate_idx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: NORMAL(:) !<NORMAL(coordinate_idx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: TANGENTS(:,:) !<TANGENTS(coordinate_idx,tangent_idx), on exit the tangent vectors for the tangent_idx'th tangent at the node. There are number_of_xi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DIMS,INDEX_MATCH
    INTEGER(INTG) :: nic,component_idx,derivative_idx,xi_idx,element,element_idx,local_node,local_node_idx
    REAL(DP) :: XI(3), VEC(3), DXDXI(3,3), NORMVEC(3) ! Note VEC, DXDXI sizes are fixed, but it doesn't matter so much
    INTEGER(INTG) :: tangent_idx,tangent_xi_idx
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: TOPOLOGY
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMP_TOPOLOGY
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DECOMP_ELEMENTS
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_PositionNormalTangentsCalculateNode",ERR,ERROR,*999)

    NULLIFY(FIELD_VARIABLE)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            CALL Field_VariableGet(FIELD,VARIABLE_TYPE,FIELD_VARIABLE,ERR,ERROR,*999)
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              DIMS=GEOMETRIC_FIELD%VARIABLES(1)%NUMBER_OF_COMPONENTS !\TODO: clean this up
!               DIMS=FIELD_VARIABLE%NUMBER_OF_COMPONENTS !\TODO: clean this up
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=DIMS) THEN
                DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                IF(ASSOCIATED(DOMAIN)) THEN
                  TOPOLOGY=>DOMAIN%TOPOLOGY
                  IF(ASSOCIATED(TOPOLOGY)) THEN
                    DECOMPOSITION=>FIELD%DECOMPOSITION
                    IF(ASSOCIATED(DECOMPOSITION)) THEN
                      DECOMP_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                      IF(ASSOCIATED(DECOMP_TOPOLOGY)) THEN
                        DECOMP_ELEMENTS=>DECOMP_TOPOLOGY%ELEMENTS
                        IF(ASSOCIATED(DECOMP_ELEMENTS)) THEN
                          IF(SIZE(POSITION,1)>=DIMS) THEN
                            IF(SIZE(NORMAL,1)>=DIMS) THEN
                              IF(SIZE(TANGENTS,1)>=DIMS) THEN
                                IF(SIZE(DXDXI,1)>=DIMS) THEN
                                  SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                                  CASE(FIELD_CONSTANT_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has constant interpolation."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based&
                                      & interpolation."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_FACE_BASED_INTERPOLATION)
                                    !!!!!
                                    CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                                    !!!!!
                                  CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                    !!!!!
                                    CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here", &
                                      & ERR,ERROR,*999)
                                    !!!!!
                                  CASE(FIELD_LINE_BASED_INTERPOLATION)
                                    !!!!!
                                    CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                                    !!!!!
                                  CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                    !!!!!
                                    CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here", &
                                      & ERR,ERROR,*999)
                                    !!!!!
                                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                                    DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                                    IF(ASSOCIATED(DOMAIN)) THEN
                                      TOPOLOGY=>DOMAIN%TOPOLOGY
                                      IF(ASSOCIATED(TOPOLOGY)) THEN
                                        DOMAIN_ELEMENTS=>TOPOLOGY%ELEMENTS
                                        IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                                          DOMAIN_NODES=>TOPOLOGY%NODES
                                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                                            IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=DOMAIN_NODES%NUMBER_OF_NODES) THEN
                                              !Normal & tangent will be calculated as averages in all surrounding elements. This is
                                              !because there could be discontinuity in the surface gradients across elements.
                                              POSITION(1:DIMS)=0.0_DP
                                              DXDXI=0.0_DP
                                              NORMAL(1:DIMS)=0.0_DP
                                              CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(GEOMETRIC_FIELD, &
                                                & INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                              CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS, &
                                                & INTERPOLATED_POINTS,ERR,ERROR,*999)
                                              DO element_idx=1,DOMAIN_NODES%NODES(LOCAL_NODE_NUMBER)%NUMBER_OF_SURROUNDING_ELEMENTS
                                                element=DOMAIN_NODES%NODES(LOCAL_NODE_NUMBER)%SURROUNDING_ELEMENTS(element_idx)
                                                BASIS=>DOMAIN_ELEMENTS%ELEMENTS(element)%BASIS
                                                !Find local node number in the basis
                                                local_node=0
                                                DO local_node_idx=1,BASIS%NUMBER_OF_NODES
                                                  IF(DOMAIN_ELEMENTS%ELEMENTS(element)%ELEMENT_NODES(local_node_idx)== &
                                                    & LOCAL_NODE_NUMBER) THEN
                                                    local_node=local_node_idx
                                                    EXIT
                                                  ENDIF
                                                ENDDO !local_node_idx
                                                !Find the xi position of the node in the element. In most cases this will be 0,1.0 etc
                                                ! but in some cases the geometric field may not contain this node in which case xi can be
                                                ! arbitrary
                                                CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,local_node,XI,ERR,ERROR,*999)
                                                !Interpolate the geometric field at the xi position.
                                                CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                                  & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                                CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI(1:BASIS%NUMBER_OF_XI), &
                                                  & INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                                !Grab the position. This shouldn't vary between elements so do it once only
                                                IF(element_idx==1) POSITION(1:DIMS)=INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)% &
                                                  & PTR%VALUES(1:DIMS,NO_PART_DERIV)
                                                !Get DXDXI
                                                !\todo: What if the surrounding elements have different number of xi? then DXDXI will be different in size.
                                                !       Which one do we return in that case?
                                                DO component_idx=1,DIMS
                                                  DO xi_idx=1,BASIS%NUMBER_OF_XI
                                                    derivative_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx) !2,4,7
                                                    DXDXI(component_idx,xi_idx)=INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)%PTR% &
                                                      & VALUES(component_idx,derivative_idx) !dx/dxi
                                                  ENDDO
                                                ENDDO
                                                !Calculate the tangents and normal vectors
                                                IF(DOMAIN_NODES%NODES(LOCAL_NODE_NUMBER)%BOUNDARY_NODE) THEN
                                                  SELECT CASE(BASIS%TYPE)
                                                  CASE(BASIS_LAGRANGE_HERMITE_TP_TYPE)
                                                    DO nic=-BASIS%NUMBER_OF_XI_COORDINATES,BASIS%NUMBER_OF_XI_COORDINATES
                                                      IF(DECOMP_ELEMENTS%ELEMENTS(element)%ADJACENT_ELEMENTS(ABS(nic))% &
                                                        & NUMBER_OF_ADJACENT_ELEMENTS==0) THEN
                                                        IF(nic>0) THEN
                                                          INDEX_MATCH=BASIS%NUMBER_OF_NODES_XIC(ABS(nic))
                                                        ELSEIF(nic<0) THEN
                                                          INDEX_MATCH=1
                                                        ENDIF
                                                        IF(BASIS%NODE_POSITION_INDEX(local_node,ABS(nic))==INDEX_MATCH) THEN
                                                          !1D/2D/3D: tangents and normal
                                                          SELECT CASE(BASIS%NUMBER_OF_XI)
                                                          CASE(1)
                                                            !There are no tangents. We can provide a normal, but no need to sum
                                                            !and average, since in a 1D mesh, a boundary node won't be share
                                                            !with other elements.
                                                            NORMAL(1:DIMS)=DXDXI(1:DIMS,1)
                                                          CASE(2)
                                                            !One tangent vector, one normal vector
                                                            TANGENTS=0.0_DP
                                                            tangent_xi_idx=OTHER_XI_DIRECTIONS2(ABS(nic))
                                                            VEC(1:DIMS)=DXDXI(1:DIMS,tangent_xi_idx)
                                                            CALL Normalise(VEC(1:DIMS),VEC(1:DIMS),ERR,ERROR,*999)
                                                            TANGENTS(1:DIMS,1)=TANGENTS(1:DIMS,1)+ &
                                                              & VEC(1:DIMS)
                                                            !Normal is the other component in DXDXI (correct?) Ensure the
                                                            !direction is outward
                                                            VEC(1:DIMS)=DXDXI(1:DIMS,ABS(nic))
                                                            IF(nic<0) VEC=-VEC
                                                            CALL Normalise(VEC(1:DIMS),NORMVEC(1:DIMS),ERR,ERROR,*999)
                                                            NORMAL(1:DIMS)=NORMAL(1:DIMS)+ NORMVEC(1:DIMS)
                                                          CASE(3)
                                                            !Two tangent vectors, one normal vector
                                                            TANGENTS=0.0_DP
                                                            DO tangent_idx=1,2
                                                              tangent_xi_idx=OTHER_XI_DIRECTIONS3(ABS(nic),tangent_idx+1,1)
                                                              VEC(1:DIMS)=DXDXI(1:DIMS,tangent_xi_idx)
                                                              CALL Normalise(VEC(1:DIMS),VEC(1:DIMS),ERR,ERROR,*999)
                                                              TANGENTS(1:DIMS,tangent_idx)= &
                                                                & TANGENTS(1:DIMS,tangent_idx)+VEC(1:DIMS)
                                                            ENDDO
                                                            !Calculate the normal vector
                                                            CALL CrossProduct(TANGENTS(1:DIMS,1),TANGENTS(1:DIMS,2), &
                                                              & VEC(1:DIMS),ERR,ERROR,*999)
                                                            !Yes below is compicated, but that's what it takes to get the normals pointing outwards
                                                            IF(nic<0) VEC=-VEC
                                                            IF(ABS(nic)==2) VEC=-VEC
                                                            NORMAL(1:DIMS)=NORMAL(1:DIMS)+VEC(1:DIMS)
                                                          CASE DEFAULT
                                                            !Should never happen anyway
                                                          END SELECT
                                                        ENDIF
                                                      ENDIF
                                                    ENDDO !nic
                                                  CASE(BASIS_SIMPLEX_TYPE)
                                                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
      !                                               DO nic=1,BASIS%NUMBER_OF_XI_COORDINATES
      !                                                 IF(DOMAIN_ELEMENTS%ELEMENTS(element)%ADJACENT_ELEMENTS(nic)% &
      !                                                   & NUMBER_OF_ADJACENT_ELEMENTS==0) THEN
      !                                                   IF(BASIS%NODE_POSITION_INDEX(local_node,nic)==1) THEN
      !                                                     !Area coordinates
      !                                                     SELECT CASE(BASIS%NUMBER-OF_XI)
      !                                                     CASE(1)
      !
      !                                                     CASE(2)
      !
      !                                                     CASE(3)
      !
      !                                                     CASE DEFAULT
      !                                                       !Will never happen anyway
      !                                                     END SELECT
      !                                                   ENDIF
      !                                                 ENDIF
      !                                               ENDDO !nic
                                                  CASE(BASIS_SERENDIPITY_TYPE)
                                                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_AUXILLIARY_TYPE)
                                                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_B_SPLINE_TP_TYPE)
                                                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE)
                                                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_EXTENDED_LAGRANGE_TP_TYPE)
                                                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                                  CASE DEFAULT
                                                    LOCAL_ERROR="The basis type of "//TRIM(NumberToVString(BASIS%TYPE, &
                                                      & "*",ERR,ERROR))//" is invalid."
                                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                                  END SELECT
                                                ELSE
                                                  !Node is internal to the mesh. Assign zero normal and tangents
                                                  !Actually, they were already assigned to be zero at the start so do nothing.
                                                ENDIF
                                                  !Calculate tangents from DXDXI: which xi corresponds to normal direction?
                                              ENDDO !element_idx
                                              CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,ERR,ERROR,*999)
                                              CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*999)

                                              !Normalise the normal vector
                                              CALL Normalise(NORMAL(1:DIMS),NORMAL(1:DIMS),ERR,ERROR,*999)
                                              !Normalise the tangent vectors
                                              DO tangent_idx=1,BASIS%NUMBER_OF_XI-1
                                                CALL Normalise(TANGENTS(1:DIMS,tangent_idx),TANGENTS(1:DIMS,tangent_idx), &
                                                  & ERR,ERROR,*999)
                                              ENDDO
                                            ELSE
                                              LOCAL_ERROR="The local node number of "// &
                                                & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                                                & " is invalid for component number "// &
                                                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                                & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                                & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                                & ". The local node number must be > 0 and <="// &
                                                & TRIM(NumberToVString(DOMAIN_NODES%NUMBER_OF_NODES,"*",ERR,ERROR))//"."
                                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                            ENDIF
                                          ELSE
                                            LOCAL_ERROR="The domain topology nodes for component number "// &
                                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                          ENDIF
                                        ELSE
                                          LOCAL_ERROR="The domain topology elements for component number "// &
                                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                        ENDIF
                                      ELSE
                                        LOCAL_ERROR="The domain topology for component number "// &
                                          & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                          & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                      ENDIF
                                    ELSE
                                      LOCAL_ERROR="The domain for component number "// &
                                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                    ENDIF
                                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has grid point based interpolation."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has Gauss point based interpolation."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has data point based interpolation."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE DEFAULT
                                    LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString &
                                      & (FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                      & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*", &
                                      & ERR,ERROR))//" for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ELSE
                                  LOCAL_ERROR="The first dimension of the supplied dx/dxi array of "// &
                                    & TRIM(NumberToVString(SIZE(DXDXI,1),"*",ERR,ERROR))// &
                                    & " is too small. The first dimension of the supplied array must be >= "// &
                                    & TRIM(NumberToVString(DIMS,"*",ERR,ERROR))//"."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="The first dimension of the supplied tangent array of "// &
                                  & TRIM(NumberToVString(SIZE(TANGENTS,1),"*",ERR,ERROR))// &
                                  & " is too small. The first dimension of the supplied array must be >= "// &
                                  & TRIM(NumberToVString(DIMS,"*",ERR,ERROR))//"."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="The size of the supplied normal array of "//TRIM(NumberToVString(SIZE(NORMAL,1), &
                                & "*",ERR,ERROR))//" is too small. The size of the supplied array must be >= "// &
                                & TRIM(NumberToVString(DIMS,"*",ERR,ERROR))//"."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            LOCAL_ERROR="The size of the supplied position array of "//TRIM(NumberToVString(SIZE(POSITION,1), &
                              & "*",ERR,ERROR))//" is too small. The size of the supplied array must be >= "// &
                              & TRIM(NumberToVString(DIMS,"*",ERR,ERROR))//"."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Decomposition elements is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Decomposition topology is not associated.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("Decomposition is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("Domain topology is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field component number of "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The component number must be > 0 and <= "// &
                  & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The supplied variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field variable type must be > 1 and <= "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The geometric field is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Field normal at a node:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number      = ",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Variable type     = ",VARIABLE_TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Component number  = ",COMPONENT_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Local node number = ",LOCAL_NODE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,DIMS,3,3,POSITION, &
        & '("  Position          :",3(X,E13.6))','(21X,3(X,E13.6))',ERR,ERROR,*999)
      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,DIMS,3,3,NORMAL, &
        & '("  Normal            :",3(X,E13.6))','(21X,3(X,E13.6))',ERR,ERROR,*999)
    ENDIF

    EXITS("Field_PositionNormalTangentsCalculateNode")
    RETURN
999 ERRORS("Field_PositionNormalTangentsCalculateNode",ERR,ERROR)
    EXITS("Field_PositionNormalTangentsCalculateNode")
    RETURN 1

  END SUBROUTINE Field_PositionNormalTangentsCalculateNode

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_INTERPOLATED_POINT_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      IF(ALLOCATED(INTERPOLATED_POINT%VALUES)) DEALLOCATE(INTERPOLATED_POINT%VALUES)
      DEALLOCATE(INTERPOLATED_POINT)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINT_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,NUMBER_OF_DIMENSIONS,numberOfComponents
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_INTERPOLATED_POINT_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS%FIELD)) THEN
        IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
          CALL FlagError("Interpolated point is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(INTERPOLATED_POINT,STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point",ERR,ERROR,*999)
          INTERPOLATED_POINT%INTERPOLATION_PARAMETERS=>INTERPOLATION_PARAMETERS
          NUMBER_OF_DIMENSIONS=INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS
          INTERPOLATED_POINT%MAX_PARTIAL_DERIVATIVE_INDEX=PARTIAL_DERIVATIVE_MAXIMUM_MAP(NUMBER_OF_DIMENSIONS)
          !Calculate the number of components for the interpolated point
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS-INTERPOLATION_PARAMETERS% &
                  & FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FlagError(localError,ERR,ERROR,*999)
            END SELECT
          ELSE !.NOT.(PRESENT(componentType)) -default all components
            numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          ALLOCATE(INTERPOLATED_POINT%VALUES(numberOfComponents,INTERPOLATED_POINT%MAX_PARTIAL_DERIVATIVE_INDEX),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point values.",ERR,ERROR,*999)
          INTERPOLATED_POINT%VALUES=0.0_DP
        ENDIF
      ELSE
        CALL FlagError("Interpolation parameters field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATED_POINT_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:) !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("FIELD_INTERPOLATED_POINTS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATED_POINTS,1)
        CALL FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATED_POINTS)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINTS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINTS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINTS,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:) !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:) !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_INTERPOLATED_POINTS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
        CALL FlagError("Interpolated point is already associated.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(INTERPOLATED_POINTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate interpolated points",ERR,ERROR,*999)
        DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          NULLIFY(INTERPOLATED_POINTS(var_type_idx)%PTR)
          IF(ASSOCIATED(INTERPOLATION_PARAMETERS(var_type_idx)%PTR)) THEN
            IF(PRESENT(componentType)) THEN
              CALL FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS(var_type_idx)%PTR, &
                & INTERPOLATED_POINTS(var_type_idx)%PTR,ERR,ERROR,*999,componentType)
            ELSE
              CALL FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS(var_type_idx)%PTR, &
                & INTERPOLATED_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ENDDO !var_type_idx
      ENDIF
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINTS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATED_POINTS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the interpolated point metrics and the associated interpolated point
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(JACOBIAN_TYPE,INTERPOLATED_POINT_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metrics
    INTEGER(INTG), INTENT(IN) :: JACOBIAN_TYPE !<The Jacobian type of the calculation \see COORDINATE_ROUTINES_JacobianTypes,COORDINATE_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS

    ENTERS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
      INTERPOLATED_POINT=>INTERPOLATED_POINT_METRICS%INTERPOLATED_POINT
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS=INTERPOLATION_PARAMETERS%NUMBER_OF_XI
      FIELD=>INTERPOLATION_PARAMETERS%FIELD
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR.FIELD%TYPE==FIELD_FIBRE_TYPE.OR.FIELD%TYPE==FIELD_GENERAL_TYPE &
          & .OR.FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
        NULLIFY(COORDINATE_SYSTEM)
        CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
        CALL COORDINATE_METRICS_CALCULATE(COORDINATE_SYSTEM,JACOBIAN_TYPE,INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
      ELSE
        CALL FlagError("The field is not a geometric or fibre field.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolated point metrics is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%GL)) DEALLOCATE(INTERPOLATED_POINT_METRICS%GL)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%GU)) DEALLOCATE(INTERPOLATED_POINT_METRICS%GU)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%DX_DXI)) DEALLOCATE(INTERPOLATED_POINT_METRICS%DX_DXI)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%DXI_DX)) DEALLOCATE(INTERPOLATED_POINT_METRICS%DXI_DX)
      DEALLOCATE(INTERPOLATED_POINT_METRICS)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_INITIALISE(INTERPOLATED_POINT,INTERPOLATED_POINT_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !A pointer to the interpolated point to initliase the interpolated point metrics for
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: INTERPOLATED_POINT_METRICS !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_X_DIMENSIONS
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: DUMMY_ERROR !,LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
        CALL FlagError("Interpolated point metrics is already associated.",ERR,ERROR,*998)
      ELSE
        NULLIFY(COORDINATE_SYSTEM)
        CALL FIELD_COORDINATE_SYSTEM_GET(INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
        NUMBER_OF_X_DIMENSIONS=COORDINATE_SYSTEM%NUMBER_OF_DIMENSIONS
        NUMBER_OF_XI_DIMENSIONS=INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS
        !Size of interpolated point values may be greater than number of x dimensions, as FIELD_GEOMETRIC_GENERAL_TYPE
        !fields can have geometric components and then other non-geometric components, eg. for dependent fields with
        !geometric components.
        IF(NUMBER_OF_X_DIMENSIONS<=SIZE(INTERPOLATED_POINT%VALUES,1)) THEN
          ALLOCATE(INTERPOLATED_POINT_METRICS,STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point metrics.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%GL(NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_XI_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point metrics convariant tensor.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%GU(NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_XI_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point metrics contravariant tensor.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%DX_DXI(NUMBER_OF_X_DIMENSIONS,NUMBER_OF_XI_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point metrics dX_dXi.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%DXI_DX(NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_X_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolated point metrics dXi_dX.",ERR,ERROR,*999)
          INTERPOLATED_POINT_METRICS%INTERPOLATED_POINT=>INTERPOLATED_POINT
          INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS=NUMBER_OF_X_DIMENSIONS
          INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS=NUMBER_OF_XI_DIMENSIONS
          INTERPOLATED_POINT_METRICS%GL=0.0_DP
          INTERPOLATED_POINT_METRICS%GU=0.0_DP
          INTERPOLATED_POINT_METRICS%DX_DXI=0.0_DP
          INTERPOLATED_POINT_METRICS%DXI_DX=0.0_DP
          INTERPOLATED_POINT_METRICS%JACOBIAN=0.0_DP
          INTERPOLATED_POINT_METRICS%JACOBIAN_TYPE=0
         !For now don't flag an error if the number of xi dimensions doesn't match the number of x dimensions.
         !Simply do not allocate the metrics information.
!        ELSE
!          LOCAL_ERROR="The number of coordinate dimensions ("//TRIM(NumberToVString(NUMBER_OF_X_DIMENSIONS,"*",ERR,ERROR))// &
!            & ") does not match the number of components of the interpolated point ("// &
!            & TRIM(NumberToVString(SIZE(INTERPOLATED_POINT%VALUES,1),"*",ERR,ERROR))//")."
!          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Interpolation point is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINTS_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: INTERPOLATED_POINTS_METRICS(:) !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("Field_InterpolatedPointsMetricsFinalise",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS_METRICS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATED_POINTS_METRICS,1)
        CALL FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINTS_METRICS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATED_POINTS_METRICS)
    ENDIF

    EXITS("Field_InterpolatedPointsMetricsFinalise")
    RETURN
999 ERRORSEXITS("Field_InterpolatedPointsMetricsFinalise",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_InterpolatedPointsMetricsFinalise

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE Field_InterpolatedPointsMetricsInitialise(INTERPOLATED_POINTS,INTERPOLATED_POINTS_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:) !A pointer to the interpolated pointS to initliase the interpolated point metrics for
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: INTERPOLATED_POINTS_METRICS(:) !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx,DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("Field_InterpolatedPointsMetricsInitialise",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINTS_METRICS)) THEN
        CALL FlagError("Interpolated point metrics is already associated.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(INTERPOLATED_POINTS_METRICS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate interpolated points metrics.",ERR,ERROR,*999)
        !Nullify all pointers first so that finalise does not fail on error condition half way through the next loop
        DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          NULLIFY(INTERPOLATED_POINTS_METRICS(variableTypeIdx)%PTR)
        ENDDO !variableTypeIdx
        DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          IF(ASSOCIATED(INTERPOLATED_POINTS(variableTypeIdx)%PTR)) &
            & CALL FIELD_INTERPOLATED_POINT_METRICS_INITIALISE(INTERPOLATED_POINTS(variableTypeIdx)%PTR, &
            & INTERPOLATED_POINTS_METRICS(variableTypeIdx)%PTR,ERR,ERROR,*999)
        ENDDO !variableTypeIdx
      ENDIF
    ELSE
      CALL FlagError("Interpolation points is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("Field_InterpolatedPointsMetricsInitialise")
    RETURN
999 CALL Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINTS_METRICS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("Field_InterpolatedPointsMetricsInitialise",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_InterpolatedPointsMetricsInitialise

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_INTERPOLATION_PARAMETER_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%BASES)) DEALLOCATE(INTERPOLATION_PARAMETERS%BASES)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS)) DEALLOCATE(INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%PARAMETERS)) DEALLOCATE(INTERPOLATION_PARAMETERS%PARAMETERS)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%SCALE_FACTORS)) DEALLOCATE(INTERPOLATION_PARAMETERS%SCALE_FACTORS)
      DEALLOCATE(INTERPOLATION_PARAMETERS)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETER_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETER_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETER_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE,INTERPOLATION_PARAMETERS,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On exit, a pointer to the initialised interpolation parameters. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,numberOfComponents

    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    ENTERS("FIELD_INTERPOLATION_PARAMETER_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
      FIELD=>FIELD_VARIABLE%FIELD
      IF(ASSOCIATED(FIELD)) THEN
        IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
          CALL FlagError("Interpolation parameters is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(INTERPOLATION_PARAMETERS,STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate an interpolation parameter.",ERR,ERROR,*999)
          INTERPOLATION_PARAMETERS%FIELD=>FIELD
          INTERPOLATION_PARAMETERS%FIELD_VARIABLE=>FIELD_VARIABLE
          INTERPOLATION_PARAMETERS%NUMBER_OF_XI=0
          !Calculate the number of components required
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS-INTERPOLATION_PARAMETERS% &
                  & FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              localError="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FlagError(localError,ERR,ERROR,*999)
            END SELECT
          ELSE
            numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          ALLOCATE(INTERPOLATION_PARAMETERS%BASES(numberOfComponents),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate bases.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(numberOfComponents),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate interpolation type.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATION_PARAMETERS%PARAMETERS(FIELD_VARIABLE%maxNumberElementInterpolationParameters, &
            & numberOfComponents),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate parameters.",ERR,ERROR,*999)
          INTERPOLATION_PARAMETERS%PARAMETERS=0.0_DP
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_NO_SCALING) THEN
            ALLOCATE(INTERPOLATION_PARAMETERS%SCALE_FACTORS(FIELD_VARIABLE%maxNumberElementInterpolationParameters, &
              & numberOfComponents),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate scale factors.",ERR,ERROR,*999)
            INTERPOLATION_PARAMETERS%SCALE_FACTORS=0.0_DP
          ENDIF
          DO component_idx=1,numberOfComponents
            NULLIFY(INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR)
          ENDDO !component_idx
          INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS=0
        ENDIF
      ELSE
        CALL FlagError("Field variable field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETER_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETER_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETER_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular element. Old CMISS name XPXE, ZPZE
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,ELEMENT_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*, &
      & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the element parameters for
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to get the element parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,local_derivative_idx,version_idx,global_derivative_idx,element_node_idx,node_idx, &
      & element_parameter_idx,gaussIdx,dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEMENTS_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(PARAMETER_SET_TYPE>0.AND.PARAMETER_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
        PARAMETER_SET=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(PARAMETER_SET_TYPE)%PTR
        IF(ASSOCIATED(PARAMETER_SET)) THEN
          NULLIFY(FIELD_PARAMETER_SET_DATA)
          CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
          FIELD=>INTERPOLATION_PARAMETERS%FIELD
          IF(ASSOCIATED(FIELD)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            IF(PRESENT(componentType)) THEN
              SELECT CASE(componentType)
              CASE(FIELD_ALL_COMPONENTS_TYPE)
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                    & NUMBER_OF_COMPONENTS
                ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                    & PTR%NUMBER_OF_COMPONENTS+1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            ENDIF
            DO component_idx=startComponentIdx,endComponentIdx
              ELEMENTS_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
              IF(ELEMENT_NUMBER>0.AND.ELEMENT_NUMBER<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
                BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%BASIS
                INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
                IF(component_idx==1) THEN
                  INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
                ELSE
                  IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                    & CALL FlagError("Inconsistent number of xi directions???",ERR,ERROR,*999)
                ENDIF
                SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                    & CONSTANT_PARAM2DOF_MAP
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
                  INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                    & ELEMENT_PARAM2DOF_MAP%ELEMENTS(ELEMENT_NUMBER)
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
                  INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                CASE(FIELD_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  ELEMENTS_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
                  NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                  SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
                  CASE(FIELD_NO_SCALING)
                    DO element_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(element_node_idx)
                      DO local_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(element_node_idx)
                        global_derivative_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES( &
                          & local_derivative_idx,element_node_idx)
                        version_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions(local_derivative_idx, &
                          & element_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(local_derivative_idx,element_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(global_derivative_idx)%VERSIONS(version_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                      ENDDO !local_derivative_idx
                    ENDDO !element_node_idx
                  CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
                    scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
                    NULLIFY(SCALE_FACTORS)
                    CALL DistributedVector_DataGet(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                    DO element_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(element_node_idx)
                      DO local_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(element_node_idx)
                        global_derivative_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES( &
                          & local_derivative_idx,element_node_idx)
                        version_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions( &
                          & local_derivative_idx,element_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(global_derivative_idx,element_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(global_derivative_idx)%VERSIONS(version_idx)
                        node_scaling_dof_idx= &
                            & NODES_TOPOLOGY%NODES(node_idx)%DERIVATIVES(global_derivative_idx)%DOF_INDEX(version_idx)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(element_parameter_idx,ELEMENT_NUMBER)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(global_derivative_idx,node_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA( &
                          & dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                        INTERPOLATION_PARAMETERS%SCALE_FACTORS(element_parameter_idx,component_idx)=SCALE_FACTORS( &
                          & node_scaling_dof_idx)
                      ENDDO !local_derivative_idx
                    ENDDO !element_node_idx
                    CALL DistributedVector_DataRestore(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                  CASE(FIELD_ARC_LENGTH_SCALING)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                  CASE DEFAULT
                    LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
                      & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
                      & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS
                  DO gaussIdx=1,BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
                    dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                      & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussIdx,ELEMENT_NUMBER)
                    INTERPOLATION_PARAMETERS%PARAMETERS(gaussIdx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                  ENDDO !gaussIdx
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                    & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                LOCAL_ERROR="The element number of "//TRIM(NumberToVString(ELEMENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The number must be between 1 and "// &
                  & TRIM(NumberToVString(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !component_idx
            CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            CALL FlagError("The interpolation parameters field is not associated.",ERR,ERROR,*999)
          ENDIF
          CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
            & " has not been created for field number "// &
            & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The number must be between 1 and "//TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))// &
          & " for field number "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",ELEMENT_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:) !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATION_PARAMETERS,1)
        CALL FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATION_PARAMETERS)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:) !<On exit, a pointer to the initialised interpolation parameters.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
          CALL FlagError("Interpolation parameters is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(INTERPOLATION_PARAMETERS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate the interpolation parameters.",ERR,ERROR,*999)
          DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            NULLIFY(INTERPOLATION_PARAMETERS(var_type_idx)%PTR)
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(var_type_idx)%PTR
            IF(PRESENT(componentType)) THEN
              IF(ASSOCIATED(FIELD_VARIABLE)) CALL FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE, &
                & INTERPOLATION_PARAMETERS(var_type_idx)%PTR,ERR,ERROR,*999,componentType)
            ELSE
              IF(ASSOCIATED(FIELD_VARIABLE)) CALL FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE, &
                & INTERPOLATION_PARAMETERS(var_type_idx)%PTR,ERR,ERROR,*999)
            ENDIF
          ENDDO !var_type_idx
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular line. Old CMISS name XPXE, ZPZE
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_LINE_GET(PARAMETER_SET_TYPE,LINE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*, &
      & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the line parameters for
    INTEGER(INTG), INTENT(IN) :: LINE_NUMBER !<The line number to get the line parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get the interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: component_idx,basis_derivative_idx,derivative_idx,basis_node_idx,version_idx,node_idx,element_parameter_idx, &
      & dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_LINES_TYPE), POINTER :: LINES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(PARAMETER_SET_TYPE>0.AND.PARAMETER_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
        PARAMETER_SET=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(PARAMETER_SET_TYPE)%PTR
        IF(ASSOCIATED(PARAMETER_SET)) THEN
          NULLIFY(FIELD_PARAMETER_SET_DATA)
          CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
          FIELD=>INTERPOLATION_PARAMETERS%FIELD
          IF(ASSOCIATED(FIELD)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            IF(PRESENT(componentType)) THEN
              SELECT CASE(componentType)
              CASE(FIELD_ALL_COMPONENTS_TYPE)
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                    & NUMBER_OF_COMPONENTS
                ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                    & PTR%NUMBER_OF_COMPONENTS+1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            ENDIF
            DO component_idx=startComponentIdx,endComponentIdx
              LINES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%LINES
              !IF(LINE_NUMBER>0.AND.LINE_NUMBER<=LINES_TOPOLOGY%NUMBER_OF_LINES) THEN
              !Consider ghosts as well.
              IF(LINE_NUMBER>0.AND.LINE_NUMBER<=LINES_TOPOLOGY%TOTAL_NUMBER_OF_LINES) THEN
                BASIS=>LINES_TOPOLOGY%LINES(LINE_NUMBER)%BASIS
                INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
                IF(component_idx==1) THEN
                  INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
                ELSE
                  IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                    & CALL FlagError("Inconsistent number of xi directions???",ERR,ERROR,*999)
                ENDIF
                SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                  SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
                  CASE(FIELD_NO_SCALING)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%NODES_IN_LINE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
                    scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
                    NULLIFY(SCALE_FACTORS)
                    CALL DistributedVector_DataGet(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%NODES_IN_LINE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        node_scaling_dof_idx= &
                            & NODES_TOPOLOGY%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(derivative_idx,node_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)= &
                          & FIELD_PARAMETER_SET_DATA(dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                        INTERPOLATION_PARAMETERS%SCALE_FACTORS(element_parameter_idx,component_idx)= &
                          & SCALE_FACTORS(node_scaling_dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_ARC_LENGTH_SCALING)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                  CASE DEFAULT
                    LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
                      & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
                      & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                 CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                    & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                LOCAL_ERROR="The line number of "//TRIM(NumberToVString(LINE_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The number must be between 1 and "// &
                  & TRIM(NumberToVString(LINES_TOPOLOGY%NUMBER_OF_LINES,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)

              ENDIF
            ENDDO !component_idx
            CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            CALL FlagError("The interpolation parameters field is not associated.",ERR,ERROR,*999)
          ENDIF
          CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
            & " has not been created for field number "// &
            & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The number must be between 1 and "//TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))// &
          & " for field number "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",LINE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,ERR,ERROR,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_LINE_GET

  !
  !================================================================================================================================
  !
  !>Gets the interpolation parameters for a particular face.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FACE_GET(PARAMETER_SET_TYPE,FACE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*, &
      & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the face parameters for
    INTEGER(INTG), INTENT(IN) :: FACE_NUMBER !<The face number to get the face parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get field interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: component_idx,basis_derivative_idx,derivative_idx,version_idx,basis_node_idx,node_idx,element_parameter_idx, &
      & dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_FACES_TYPE), POINTER :: FACES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(PARAMETER_SET_TYPE>0.AND.PARAMETER_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
        PARAMETER_SET=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(PARAMETER_SET_TYPE)%PTR
        IF(ASSOCIATED(PARAMETER_SET)) THEN
          NULLIFY(FIELD_PARAMETER_SET_DATA)
          CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
          FIELD=>INTERPOLATION_PARAMETERS%FIELD
          IF(ASSOCIATED(FIELD)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            IF(PRESENT(componentType)) THEN
              SELECT CASE(componentType)
              CASE(FIELD_ALL_COMPONENTS_TYPE)
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                    & NUMBER_OF_COMPONENTS
                ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                    & PTR%NUMBER_OF_COMPONENTS+1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="Interpolation component type "//TRIM(NumberToVString(componentType,"*",ERR,ERROR))//" is not valid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            ENDIF
            DO component_idx=startComponentIdx,endComponentIdx
              FACES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%FACES
              IF(FACE_NUMBER>0.AND.FACE_NUMBER<=FACES_TOPOLOGY%NUMBER_OF_FACES) THEN
                BASIS=>FACES_TOPOLOGY%FACES(FACE_NUMBER)%BASIS
                INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
                IF(component_idx==1) THEN
                  INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
                ELSE
                  IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                    & CALL FlagError("Inconsistent number of xi directions???",ERR,ERROR,*999)
                ENDIF
                SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                  SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
                  CASE(FIELD_NO_SCALING)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%NODES_IN_FACE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
                    scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
                    NULLIFY(SCALE_FACTORS)
                    CALL DistributedVector_DataGet(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%NODES_IN_FACE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        node_scaling_dof_idx= &
                            & NODES_TOPOLOGY%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(derivative_idx,node_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)= &
                          & FIELD_PARAMETER_SET_DATA(dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                        INTERPOLATION_PARAMETERS%SCALE_FACTORS(element_parameter_idx,component_idx)= &
                          & SCALE_FACTORS(node_scaling_dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_ARC_LENGTH_SCALING)
                    CALL FlagError("Not implemented.",ERR,ERROR,*999)
                  CASE DEFAULT
                    LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
                      & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
                      & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                 CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                    & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                LOCAL_ERROR="The face number of "//TRIM(NumberToVString(FACE_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The number must be between 1 and "// &
                  & TRIM(NumberToVString(FACES_TOPOLOGY%NUMBER_OF_FACES,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !component_idx
            CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            CALL FlagError("The interpolation parameters field is not associated.",ERR,ERROR,*999)
          ENDIF
          CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
            & " has not been created for field number "// &
            & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The number must be between 1 and "//TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))// &
          & " for field number "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",FACE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,ERR,ERROR,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET")
    RETURN
999 ERRORSEXITS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FACE_GET

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element.
  SUBROUTINE Field_InterpolationParametersScaleFactorsElementGet(ELEMENT_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to get the element scale factors for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEMENTS_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_InterpolationParametersScaleFactorsElementGet",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
      CASE(FIELD_NO_SCALING)
        CALL FlagError("Can not get the scale factors for a field with no scaling.",ERR,ERROR,*999)
      CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
        DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ELEMENTS_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
          IF(ELEMENT_NUMBER>0.AND.ELEMENT_NUMBER<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
            BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%BASIS
            INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
            SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_FACE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
              scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
              NULLIFY(SCALE_FACTORS)
              CALL DistributedVector_DataGet(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO nn=1,BASIS%NUMBER_OF_NODES
                np=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(nn)
                DO mk=1,BASIS%NUMBER_OF_DERIVATIVES(nn)
                  nk=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES(mk,nn)
                  nv=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions(mk,nn)
                  ns=BASIS%ELEMENT_PARAMETER_INDEX(mk,nn)
                  ny=NODES_TOPOLOGY%NODES(np)%DERIVATIVES(nk)%DOF_INDEX(nv)
                  INTERPOLATION_PARAMETERS%SCALE_FACTORS(ns,component_idx)=SCALE_FACTORS(ny)
                ENDDO !mk
              ENDDO !nn
              CALL DistributedVector_DataRestore(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
              & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The element number of "//TRIM(NumberToVString(ELEMENT_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NumberToVString(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))// &
              & " for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
      CASE(FIELD_ARC_LENGTH_SCALING)
        CALL FlagError("Not implemented.",ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
          & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
          & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",ELEMENT_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%SCALE_FACTORS(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsElementGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsElementGet",ERR,ERROR)
    EXITS("Field_InterpolationParametersScaleFactorsElementGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsElementGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber, &
    & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostNode,userNodeExists
    INTEGER(INTG) :: domainLocalNodeNumber,scalingIdx,dofIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                IF(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION)THEN
                  domainTopology=>fieldVariable%COMPONENTS(componentNumber)%DOMAIN%TOPOLOGY
                  CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(domainTopology,nodeUserNumber,userNodeExists, &
                    & domainLocalNodeNumber,ghostNode,err,error,*999)
                  IF(userNodeExists) THEN
                    IF(ghostNode) THEN
                      localError="Cannot get by node for user node "// &
                        & TRIM(NumberToVString(nodeUserNumber,"*",err,error))//" as it is a ghost node."
                      CALL FlagError(localError,err,error,*999)
                    ELSE
                      domainNodes=>domainTopology%NODES
                      IF(ASSOCIATED(domainNodes)) THEN
                        IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%NODES(domainLocalNodeNumber)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(versionNumber>0.AND.versionNumber<= &
                              & fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                              & NUMBER_OF_VERSIONS) THEN
                            ! The field component number is used to determine which scaling index to use.
                            ! The number of scaling indices are set based on the number of mesh components (not field components).
                            scalingIdx=fieldVariable%COMPONENTS(componentNumber)%SCALING_INDEX
                            NULLIFY(fieldScaleFactors)
                            CALL DistributedVector_DataGet(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                              & fieldScaleFactors,err,error,*999)
                            dofIdx=domainNodes%NODES(nodeUserNumber)%DERIVATIVES(derivativeNumber)%DOF_INDEX(versionNumber)
                            !dofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                            !  & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                            !  & VERSIONS(versionNumber)
                            scaleFactor=fieldScaleFactors(dofIdx)
                            CALL DistributedVector_DataRestore(field%SCALINGS%SCALINGS(scalingIdx)% &
                              & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
                          ELSE
                            localError="Version number "//TRIM(NumberToVString(versionNumber,"*",err,error))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(derivativeNumber,"*",err,error))//" of node number "// &
                              & TRIM(NumberToVString(nodeUserNumber,"*",err,error))//" of component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                              & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has a maximum of "// &
                              & TRIM(NumberToVString(domainNodes%NODES(domainLocalNodeNumber)% &
                              & DERIVATIVES(derivativeNumber)%numberOfVersions,"*",err,error))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          localError="Derivative number "//TRIM(NumberToVString(derivativeNumber,"*",err,error))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(nodeUserNumber,"*",err,error))//" of component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                            & TRIM(NumberToVString(domainNodes%NODES(domainLocalNodeNumber)% &
                            & NUMBER_OF_DERIVATIVES,"*",err,error))//" derivatives."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ENDIF
                    ENDIF
                  ELSE
                    localError="The specified user node number of "// &
                      & TRIM(NumberToVString(nodeUserNumber,"*",err,error))// &
                      &  " does not exist in the domain for field component number "// &
                      & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                      & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                      & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable%COMPONENTS(componentNumber)% &
                    & INTERPOLATION_TYPE,"*",err,error))//" is not nodally based for component number "// &
                    & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field number "// &
                    & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                  & " components."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetNodeScaleFactorGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorGet",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorsGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              !The NUMBER_OF_SCALING_INDICES is the same as the number of mesh components (not field components).
              IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
                scalingIdx=meshComponentNumber
                NULLIFY(fieldScaleFactors)
                CALL DistributedVector_DataGet(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                  & fieldScaleFactors,err,error,*999)
                scaleFactors=fieldScaleFactors
                CALL DistributedVector_DataRestore(field%SCALINGS%SCALINGS(scalingIdx)% &
                  & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
              ELSE
                localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NumberToVString(field%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",err,error))// &
                  & " components."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetNodeScaleFactorsGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorsGet",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorsGet

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs.
  SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
    & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FlagError("Can not get the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              !The NUMBER_OF_SCALING_INDICES is the same as the number of mesh components (not field components).
              IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
                scalingIdx=meshComponentNumber
                NULLIFY(fieldScaleFactors)
                CALL DistributedVector_DataGet(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                  & fieldScaleFactors,err,error,*999)
                numberOfScaleFactorsDofs=SIZE(fieldScaleFactors,1)
                CALL DistributedVector_DataRestore(field%SCALINGS%SCALINGS(scalingIdx)% &
                  & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
              ELSE
                localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NumberToVString(field%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",err,error))// &
                  & " components."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN
999 ERRORS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error)
    EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN 1

  END SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber, &
    & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostNode,userNodeExists
    INTEGER(INTG) :: domainLocalNodeNumber,scalingIdx,dofIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorSet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FlagError("Can not set the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                IF(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION)THEN
                  domainTopology=>fieldVariable%COMPONENTS(componentNumber)%DOMAIN%TOPOLOGY
                  CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(domainTopology,nodeUserNumber,userNodeExists, &
                    & domainLocalNodeNumber,ghostNode,err,error,*999)
                  IF(userNodeExists) THEN
                    IF(ghostNode) THEN
                      localError="Cannot update by node for user node "// &
                        & TRIM(NumberToVString(nodeUserNumber,"*",err,error))//" as it is a ghost node."
                      CALL FlagError(localError,err,error,*999)
                    ELSE
                      domainNodes=>domainTopology%NODES
                      IF(ASSOCIATED(domainNodes)) THEN
                        IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%NODES(domainLocalNodeNumber)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(versionNumber>0.AND.versionNumber<= &
                            & fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                            & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                            & NUMBER_OF_VERSIONS) THEN

                            ! The field component number is used to determine which scaling index to use.
                            ! The number of scaling indices are set based on the number of mesh components (not field components).
                            scalingIdx=fieldVariable%COMPONENTS(componentNumber)%SCALING_INDEX
                            NULLIFY(fieldScaleFactors)
                            CALL DistributedVector_DataGet(field%SCALINGS%SCALINGS(scalingIdx)% &
                              & SCALE_FACTORS,fieldScaleFactors,err,error,*999)
                            dofIdx=domainNodes%NODES(nodeUserNumber)%DERIVATIVES(derivativeNumber)%DOF_INDEX(versionNumber)
                            !dofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                            !  & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                            !  & VERSIONS(versionNumber)
                            fieldScaleFactors(dofIdx)=scaleFactor
                            CALL DistributedVector_DataRestore(field%SCALINGS%SCALINGS(scalingIdx)% &
                              & SCALE_FACTORS,fieldScaleFactors,err,error,*999)

                          ELSE
                            localError="Version number "//TRIM(NumberToVString(versionNumber,"*",err,error))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(derivativeNumber,"*",err,error))//" of node number "// &
                              & TRIM(NumberToVString(nodeUserNumber,"*",err,error))//" of component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                              & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has a maximum of "// &
                              & TRIM(NumberToVString(domainNodes%NODES(domainLocalNodeNumber)% &
                              & DERIVATIVES(derivativeNumber)%numberOfVersions,"*",err,error))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          localError="Derivative number "//TRIM(NumberToVString(derivativeNumber,"*",err,error))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(nodeUserNumber,"*",err,error))//" of component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                            & TRIM(NumberToVString(domainNodes%NODES(domainLocalNodeNumber)% &
                            & NUMBER_OF_DERIVATIVES,"*",err,error))//" derivatives."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ENDIF
                    ENDIF
                  ELSE
                    localError="The specified user node number of "// &
                      & TRIM(NumberToVString(nodeUserNumber,"*",err,error))// &
                      &  " does not exist in the domain for field component number "// &
                      & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                      & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                      & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The interpolation type of "//TRIM(NumberToVString(fieldVariable%COMPONENTS(componentNumber)% &
                    & INTERPOLATION_TYPE,"*",err,error))//" is not nodally based for component number "// &
                    & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field number "// &
                    & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                  & " components."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetNodeScaleFactorSet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorSet",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorSet
  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetNodeScaleFactorsSet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FlagError("Can not set the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              !The NUMBER_OF_SCALING_INDICES is the same as the number of mesh components (not field components).
              IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
                scalingIdx=meshComponentNumber
                NULLIFY(fieldScaleFactors)
                CALL DistributedVector_DataGet(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                  & fieldScaleFactors,err,error,*999)
                IF(SIZE(fieldScaleFactors,1)==SIZE(scaleFactors,1)) THEN
                  fieldScaleFactors = scaleFactors
                ELSE
                  localError="The input scale factors have dimensions "//TRIM(NumberToVString(SIZE(scaleFactors),"*",err,error)) &
                    & //" and does not match the expected scale factor dimensions of "// &
                    & TRIM(NumberToVString(SIZE(fieldScaleFactors),"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
                CALL DistributedVector_DataRestore(field%SCALINGS%SCALINGS(scalingIdx)% &
                  & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
              ELSE
                localError="Mesh component number "//TRIM(NumberToVString(meshComponentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NumberToVString(field%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",err,error))// &
                  & " components."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FlagError("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NumberToVString(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetNodeScaleFactorsSet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetNodeScaleFactorsSet",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorsSet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element.
  SUBROUTINE Field_InterpolationParametersScaleFactorsLineGet(LINE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: LINE_NUMBER !<The line number to get the element scale factors for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_LINES_TYPE), POINTER :: LINES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_InterpolationParametersScaleFactorsLineGet",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
      CASE(FIELD_NO_SCALING)
        CALL FlagError("Can not scale factors for a field with no scaling.",ERR,ERROR,*999)
      CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
        DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          LINES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%LINES
          IF(LINE_NUMBER>0.AND.LINE_NUMBER<=LINES_TOPOLOGY%NUMBER_OF_LINES) THEN
            BASIS=>LINES_TOPOLOGY%LINES(LINE_NUMBER)%BASIS
            INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
            IF(component_idx==1) THEN
              INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
            ELSE
              IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                & CALL FlagError("Inconsistent number of xi directions???",ERR,ERROR,*999)
            ENDIF
            SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_FACE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
              scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
              NULLIFY(SCALE_FACTORS)
              CALL DistributedVector_DataGet(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO nn=1,BASIS%NUMBER_OF_NODES
                np=LINES_TOPOLOGY%LINES(LINE_NUMBER)%NODES_IN_LINE(nn)
                DO mk=1,BASIS%NUMBER_OF_DERIVATIVES(nn)
                  nk=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(1,mk,nn)
                  nv=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(2,mk,nn)
                  ns=BASIS%ELEMENT_PARAMETER_INDEX(mk,nn)
                  ny=NODES_TOPOLOGY%NODES(np)%DERIVATIVES(nk)%DOF_INDEX(nv)
                  INTERPOLATION_PARAMETERS%SCALE_FACTORS(ns,component_idx)=SCALE_FACTORS(ny)
                ENDDO !mk
              ENDDO !nn
              CALL DistributedVector_DataRestore(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
              & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The line number of "//TRIM(NumberToVString(LINE_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NumberToVString(LINES_TOPOLOGY%NUMBER_OF_LINES,"*",ERR,ERROR))// &
              & " for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
      CASE(FIELD_ARC_LENGTH_SCALING)
        CALL FlagError("Not implemented.",ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
          & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
          & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",LINE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%SCALE_FACTORS(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsLineGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsLineGet",ERR,ERROR)
    EXITS("Field_InterpolationParametersScaleFactorsLineGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsLineGet

  !
  !================================================================================================================================
  !

!>Gets the interpolation scale factors for a particular element.
  SUBROUTINE Field_InterpolationParametersScaleFactorsFaceGet(FACE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: FACE_NUMBER !<The face number to get the element scale factors for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_FACES_TYPE), POINTER :: FACES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_InterpolationParametersScaleFactorsFaceGet",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
      CASE(FIELD_NO_SCALING)
        CALL FlagError("Can not scale factors for a field with no scaling.",ERR,ERROR,*999)
      CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
        DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          FACES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%FACES
          IF(FACE_NUMBER>0.AND.FACE_NUMBER<=FACES_TOPOLOGY%NUMBER_OF_FACES) THEN
            BASIS=>FACES_TOPOLOGY%FACES(FACE_NUMBER)%BASIS
            INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
            IF(component_idx==1) THEN
              INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
            ELSE
              IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                & CALL FlagError("Inconsistent number of xi directions???",ERR,ERROR,*999)
            ENDIF
            SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_FACE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
              scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
              NULLIFY(SCALE_FACTORS)
              CALL DistributedVector_DataGet(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO nn=1,BASIS%NUMBER_OF_NODES
                np=FACES_TOPOLOGY%FACES(FACE_NUMBER)%NODES_IN_FACE(nn)
                DO mk=1,BASIS%NUMBER_OF_DERIVATIVES(nn)
                  nk=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(1,mk,nn)
                  nv=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(2,mk,nn)
                  ns=BASIS%ELEMENT_PARAMETER_INDEX(mk,nn)
                  ny=NODES_TOPOLOGY%NODES(np)%DERIVATIVES(nk)%DOF_INDEX(nv)
                  INTERPOLATION_PARAMETERS%SCALE_FACTORS(ns,component_idx)=SCALE_FACTORS(ny)
                ENDDO !mk
              ENDDO !nn
              CALL DistributedVector_DataRestore(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
              & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The face number of "//TRIM(NumberToVString(FACE_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NumberToVString(FACES_TOPOLOGY%NUMBER_OF_FACES,"*",ERR,ERROR))// &
              & " for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
      CASE(FIELD_ARC_LENGTH_SCALING)
        CALL FlagError("Not implemented.",ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
          & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
          & TRIM(NumberToVString(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FlagError("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",FACE_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%SCALE_FACTORS(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    EXITS("Field_InterpolationParametersScaleFactorsFaceGet")
    RETURN
999 ERRORS("Field_InterpolationParametersScaleFactorsFaceGet",ERR,ERROR)
    EXITS("Field_InterpolationParametersScaleFactorsFaceGet")
    RETURN 1

  END SUBROUTINE Field_InterpolationParametersScaleFactorsFaceGet

  !
  !================================================================================================================================
  !

  !>Finalises the physical point and deallocates all memory.
  SUBROUTINE FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<A pointer to the physical point to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_PHYSICAL_POINT_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      IF(ALLOCATED(PHYSICAL_POINT%VALUES)) DEALLOCATE(PHYSICAL_POINT%VALUES)
      DEALLOCATE(PHYSICAL_POINT)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINT_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PHYSICAL_POINT_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PHYSICAL_POINT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for interpolated points
  SUBROUTINE FIELD_PHYSICAL_POINT_INITIALISE(FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT,PHYSICAL_POINT, &
    & ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: FIELD_INTERPOLATED_POINT !<A pointer to the field interpolation point to initialise the physical point for
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: GEOMETRIC_INTERPOLATED_POINT !<A pointer to the geometric field interpolated point to initialise the physical point for
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<On exit, A pointer to the physical point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_PHYSICAL_POINT_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
      IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
        FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
        IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
          GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
          IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
            FIELD=>FIELD_INTERPOLATION_PARAMETERS%FIELD
            IF(ASSOCIATED(FIELD)) THEN
              GEOMETRIC_FIELD=>GEOMETRIC_INTERPOLATION_PARAMETERS%FIELD
              IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
                IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD,GEOMETRIC_FIELD)) THEN
                  IF(ASSOCIATED(PHYSICAL_POINT)) THEN
                    CALL FlagError("Physical point is already associated.",ERR,ERROR,*998)
                  ELSE
                    ALLOCATE(PHYSICAL_POINT,STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate physical point",ERR,ERROR,*999)
                    PHYSICAL_POINT%FIELD_INTERPOLATED_POINT=>FIELD_INTERPOLATED_POINT
                    PHYSICAL_POINT%GEOMETRIC_INTERPOLATED_POINT=>GEOMETRIC_INTERPOLATED_POINT
                    PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=0
                    ALLOCATE(PHYSICAL_POINT%VALUES(FIELD_INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate physical point values.",ERR,ERROR,*999)
                    PHYSICAL_POINT%VALUES=0.0_DP
                  ENDIF
                ELSE
                  CALL FlagError("The field geometric field and the specified geometric field are not associated.", &
                    & ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Geometric interpolation parameters field is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Field interpolation parameters field is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FlagError("Geometric interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FlagError("Field interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Geometric interpolated point is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Field interpolated point is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINT_INITIALISE")
    RETURN
999 CALL FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_PHYSICAL_POINT_INITIALISE",ERR,ERROR)
    RETURN 1

  END SUBROUTINE FIELD_PHYSICAL_POINT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the physical points and deallocates all memory.
  SUBROUTINE FIELD_PHYSICAL_POINTS_FINALISE(PHYSICAL_POINTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: PHYSICAL_POINTS(:) !<A pointer to the physical points to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    ENTERS("FIELD_PHYSICAL_POINTS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINTS)) THEN
      DO var_type_idx=1,SIZE(PHYSICAL_POINTS,1)
        CALL FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(PHYSICAL_POINTS)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINTS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PHYSICAL_POINTS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PHYSICAL_POINTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for an interpolation parameters
  SUBROUTINE FIELD_PHYSICAL_POINTS_INITIALISE(FIELD_INTERPOLATED_POINTS,GEOMETRIC_INTERPOLATED_POINTS, &
    & PHYSICAL_POINTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: FIELD_INTERPOLATED_POINTS(:) !<A pointer to the field interpolated points to initialise the physical points for
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: GEOMETRIC_INTERPOLATED_POINTS(:) !<A pointer to the geometric interpolated points to initialise the physical points for
    TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: PHYSICAL_POINTS(:) !<On exit, A pointer to the physical points that has been initialised. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_PHYSICAL_POINTS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD_INTERPOLATED_POINTS)) THEN
      IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINTS)) THEN
        IF(ASSOCIATED(PHYSICAL_POINTS)) THEN
          CALL FlagError("Physical points is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(PHYSICAL_POINTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate physical points.",ERR,ERROR,*999)
          DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES

            NULLIFY(PHYSICAL_POINTS(var_type_idx)%PTR)
            IF(ASSOCIATED(FIELD_INTERPOLATED_POINTS(var_type_idx)%PTR).AND. &
              & ASSOCIATED(GEOMETRIC_INTERPOLATED_POINTS(var_type_idx)%PTR)) &
              & CALL FIELD_PHYSICAL_POINT_INITIALISE(FIELD_INTERPOLATED_POINTS(var_type_idx)%PTR, &
              & GEOMETRIC_INTERPOLATED_POINTS(var_type_idx)%PTR,PHYSICAL_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
          ENDDO !var_type_idx
        ENDIF
      ELSE
        CALL FlagError("Geometric interpolated points is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Field interpolated points is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_PHYSICAL_POINTS_INITIALISE")
    RETURN
999 CALL FIELD_PHYSICAL_POINTS_FINALISE(PHYSICAL_POINTS,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_PHYSICAL_POINTS_INITIALISE",ERR,ERROR)
    RETURN 1

  END SUBROUTINE FIELD_PHYSICAL_POINTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the mappings to/from the degrees of freedom and the parameters for a field.
  SUBROUTINE FIELD_MAPPINGS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the mappings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx,component_idx,domain_type_idx,VARIABLE_GLOBAL_DOFS_OFFSET,NUMBER_OF_GLOBAL_VARIABLE_DOFS, &
      & NUMBER_OF_CONSTANT_DOFS,NUMBER_OF_ELEMENT_DOFS,NUMBER_OF_NODE_DOFS,NUMBER_OF_GRID_POINT_DOFS,NUMBER_OF_GAUSS_POINT_DOFS, &
      & NUMBER_OF_LOCAL_VARIABLE_DOFS,TOTAL_NUMBER_OF_VARIABLE_DOFS,NUMBER_OF_DOMAINS,variable_global_ny, &
      & variable_local_ny,domain_idx,domain_no,constant_nyy,element_ny,element_nyy,node_ny,node_nyy,grid_point_nyy, &
      & Gauss_point_nyy,version_idx,derivative_idx,ny,NumberComputationalNodes, DomainNo, DomainIdx, &
      & MyComputationalNodeNumber,domain_type_stop,start_idx,stop_idx,element_idx,node_idx,NUMBER_OF_LOCAL, NGP, MAX_NGP, &
      & gp,MPI_IERROR,NUMBER_OF_GLOBAL_DOFS,gauss_point_idx,NUMBER_OF_DATA_POINT_DOFS,data_point_nyy,dataPointIdx,elementIdx, &
      & localDataNumber,globalElementNumber,GlobalNumberBreaks, LocalNumberBreaks, PreviousNodeGlobalNo, NodeLocalNo, &
      & NodeGlobalNo, BreakIdx, NumberDofsInSequence, DofTableIndex, DerivativeIdx, LocalInternalNodeIdx, CurrentRank, &
      & NodeStartGlobalNo, NodeStopGlobalNo, NumberDofsCurrentSequence, LocalNodeIdx, I, NodeOnCurrentComputationalNodeGlobalNo, &
      & NumberDofsOnCurrentComputationalNode, NumberDofs, VersionIdx, DofLocalNo, DofGlobalNo, NodeDofIdx, NumberBoundaryDofs, &
      & MaximumNumberNodesSend, MaximumNumberNodesReceive, NodeSendIdx, FirstGhostNodeLocalNo, LastGhostNodeLocalNo, &
      & NodeReceiveIdx, MaxNumberDerivativesAtGhostNode, NumberVersions, StartDofGlobalNo, InternalDofIdx, AdjacentDomainIdx, &
      & GhostNodeNo, NumberDerivatives, CurrentDofLocalNo, CurrentDofGlobalNo, GhostReceiveIdx, GhostSendIdx, &
      & MaximumNumberNodesCommunicate, ElementDofIdx, CurrentElementDofIdx, ElementGlobalNo, ElementLocalNo, Element1LocalNo, &
      & AdjacentDomainNo, AdjacentDomainIdx2, ConstantDofIdx, countIfFace, NUMBER_OF_FACE_DOFS, face_nyy, faceDofIdx, &
      & PreviousFaceGlobalNo, FaceLocalNo, FaceGlobalNo, LocalInternalFaceIdx, FaceReceiveIdx, MaxNumberDerivativesAtGhostFace, &
      & FaceStartGlobalNo, FaceStopGlobalNo, LocalFaceIdx, FaceOnCurrentComputationalNodeGlobalNo, GhostFaceNo, &
      & MaximumNumberFacesSend, MaximumNumberFacesReceive, FaceSendIdx, FirstGhostFaceLocalNo, LastGhostFaceLocalNo, &
      & MaximumNumberFacesCommunicate, faceIdx, count, numberOfInternalExternalFaces, globalDofStartNumberFace, &
      & numberOfBoundaryExternalFaces, numberOfGhostExternalFaces, numberOfGlobalExternalFaces, lineIdx, lineDofIdx, &
      & NUMBER_OF_LINE_DOFS, numberOfBoundaryExternalLines, numberOfGhostExternalLines, numberOfGlobalExternalLines, &
      & PreviousLineGlobalNo, LineLocalNo, LineGlobalNo, LocalInternalLineIdx, LineReceiveIdx, MaxNumberDerivativesAtGhostLine, &
      & LineStartGlobalNo, LineStopGlobalNo, LocalLineIdx, LineOnCurrentComputationalNodeGlobalNo, GhostLineNo, &
      & MaximumNumberLinesSend, MaximumNumberLinesReceive, LineSendIdx, FirstGhostLineLocalNo, LastGhostLineLocalNo, &
      & MaximumNumberLinesCommunicate, numberOfInternalExternalLines, globalDofStartNumberLine, &
      & numberOfHashKeys, indexHash

    INTEGER(INTG), ALLOCATABLE :: VARIABLE_LOCAL_DOFS_OFFSETS(:),VARIABLE_GHOST_DOFS_OFFSETS(:), &
        & localDataParamCount(:),ghostDataParamCount(:), NumberBreaksNode(:), RowOffsetNode(:), DofTable(:), IntegerArray(:), &
        & SendBuffer2(:,:), ReceiveBuffer2(:,:), SendBuffer3(:,:,:), ReceiveBuffer3(:,:,:), ReceiveRequestHandle(:), &
        & SendRequestHandle(:), NumberDerivativesAtGhostNode(:), NodeDofSpecification(:,:), NumberBreaksDoubleNode(:), &
        & RowOffsetZeroBasedNode(:), FirstDofGlobalNo(:), Element1GlobalNo(:), FirstElementDofIdx(:), FirstDofLocalNo(:), &
        & RowOffsetFace(:), RowOffsetZeroBasedFace(:), NumberBreaksFace(:), NumberBreaksDoubleFace(:), &
        & NumberDerivativesAtGhostFace(:), FaceDofSpecification(:,:), ReceiveRequestHandle2(:), SendRequestHandle2(:), &
        & numberOfInternalAndBoundaryExternalFacesOnRank(:), dofGlobalNumberFromFaceLocalNumber(:), NumberBreaksLine(:), &
        & NumberBreaksDoubleLine(:), RowOffsetLine(:), RowOffsetZeroBasedLine(:), LineDofSpecification(:,:), &
        & numberOfInternalAndBoundaryExternalLinesOnRank(:), NumberDerivativesAtGhostLine(:), &
        & dofGlobalNumberFromLineLocalNumber(:), &
        & hashKeysArray(:), hashValuesArray(:), hashIntegerArray(:), &
        & hashValuesMatrix(:,:),hashValuesSubMatrix(:,:), hashArray (:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: elementsMapping,DOFS_MAPPING,FIELD_VARIABLE_DOFS_MAPPING,ELEMENTS_MAPPING, &
      & NODES_MAPPING, FACES_MAPPING, LINES_MAPPING
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: domainMappings
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(MeshComponentTopologyType), POINTER :: TOPOLOGY
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE), POINTER :: FIELD_COMPONENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR, localError
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(LIST_TYPE), POINTER :: BoundaryDofLocalNosList
    TYPE(LIST_PTR_TYPE), ALLOCATABLE :: hashKeysList(:)!, hashValuesList(:)
    LOGICAL :: CurrentNodeIsInternal, AdjacentDomainFound, NodeIsOnCurrentAdjacentDomain, CurrentElementIsInternal, &
      & ElementIsOnCurrentAdjacentDomain, CurrentFaceIsInternal, FaceIsOnCurrentAdjacentDomain, BoundaryFaceNumbersCalculated, &
      & BoundaryLineNumbersCalculated, CurrentLineIsInternal, LineIsOnCurrentAdjacentDomain, &
      & isHashFound

    ENTERS("FIELD_MAPPINGS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      NumberComputationalNodes=ComputationalEnvironment_NumberOfNodesGet(ERR,ERROR)
      IF(ERR/=0) GOTO 999
      myComputationalNodeNumber=ComputationalEnvironment_NodeNumberGet(ERR,ERROR)
      IF(ERR/=0) GOTO 999

      !The following line is what the if statement should be, for now we will just use new implementation if one of the components has face or line interpolation
      !IF (USE_NEW_LOCAL_IMPLEMENTATION) THEN
      countIfFace=0
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
          IF(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE==FIELD_FACE_BASED_INTERPOLATION .OR. &
            & FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE==FIELD_LINE_BASED_INTERPOLATION .OR. &
            & FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE== &
            & FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION .OR. &
            & FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE== &
            & FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION) THEN
            countIfFace=countIfFace+1
          ELSE
            !do nothing
          ENDIF
        ENDDO
      ENDDO

      IF(countIfFace>=1) THEN

        BoundaryFaceNumbersCalculated=.FALSE.
        BoundaryLineNumbersCalculated=.FALSE.

        !Calculate the number of global and local degrees of freedom for the field variables and components. Each field variable
        !component has a set of DOFs so loop over the components for each variable component and count up the DOFs.
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          NUMBER_OF_CONSTANT_DOFS=0
          NUMBER_OF_ELEMENT_DOFS=0
          NUMBER_OF_FACE_DOFS=0
          NUMBER_OF_LINE_DOFS=0
          NUMBER_OF_NODE_DOFS=0
          NUMBER_OF_GRID_POINT_DOFS=0
          NUMBER_OF_GAUSS_POINT_DOFS=0
          NUMBER_OF_DATA_POINT_DOFS=0
          NUMBER_OF_LOCAL_VARIABLE_DOFS=0  ! n dofs internal and boundary
          TOTAL_NUMBER_OF_VARIABLE_DOFS=0  ! n dofs internal, boundary and ghost
          NUMBER_OF_GLOBAL_VARIABLE_DOFS=0 ! global n dofs

          ! output interpolation type for all components
          IF (DIAGNOSTICS2) THEN
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
              ELEMENTS_MAPPING=>domainMappings%ELEMENTS
              NODES_MAPPING=>domainMappings%NODES
              DOFS_MAPPING=>domainMappings%DOFS

              IF (DIAGNOSTICS2) WRITE(*, '(I0,A,I0)', ADVANCE = "NO") MyComputationalNodeNumber, ": component ", component_idx

              SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_CONSTANT_INTERPOLATION"

              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_ELEMENT_BASED_INTERPOLATION"

              CASE(FIELD_FACE_BASED_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_FACE_BASED_INTERPOLATION"

              CASE(FIELD_LINE_BASED_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_LINE_BASED_INTERPOLATION"

              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION"

              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION"

              CASE(FIELD_NODE_BASED_INTERPOLATION)
                IF (DIAGNOSTICS2) WRITE(*, '(A)') " FIELD_NODE_BASED_INTERPOLATION"
              END SELECT
            ENDDO
          ENDIF

          ! loop over components of current field variable
          DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
            FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
            TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
            !TOPOLOGY=>FIELD_COMPONENT%DOMAIN%TOPOLOGY
            domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
            ELEMENTS_MAPPING=>domainMappings%ELEMENTS
            FACES_MAPPING=>domainMappings%FACES
            LINES_MAPPING=>domainMappings%LINES
            NODES_MAPPING=>domainMappings%NODES
            DOFS_MAPPING=>domainMappings%DOFS   ! dofs_mapping contains only some information like DOFS_MAPPING%NUMBER_OF_LOCAL, that was set in domainMappings_NODES_CALCULATE, the real dofs mapping is FIELD_VARIABLE_DOFS_MAPPING

            SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              NUMBER_OF_CONSTANT_DOFS = NUMBER_OF_CONSTANT_DOFS + 1
              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + 1
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + 1
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + 1

            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              NUMBER_OF_ELEMENT_DOFS = NUMBER_OF_ELEMENT_DOFS + ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + ELEMENTS_MAPPING%NUMBER_OF_LOCAL
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + ELEMENTS_MAPPING%NUMBER_OF_GLOBAL

              ! allocate param_to_dof_map for elements
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL), &
                & STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS = ELEMENTS_MAPPING% &
                & TOTAL_NUMBER_OF_LOCAL

            CASE(FIELD_FACE_BASED_INTERPOLATION)
              NUMBER_OF_FACE_DOFS = NUMBER_OF_FACE_DOFS + FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + FACES_MAPPING%NUMBER_OF_LOCAL
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + FACES_MAPPING%NUMBER_OF_GLOBAL

              ! allocate param_to_dof_map for faces
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL), &
                & STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS = FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL

            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)

              !Calculate the number of external faces that are, internal, boundary, and ghost to this domain


              IF(.NOT.BoundaryFaceNumbersCalculated) THEN
                count=0

                DO faceIdx=FACES_MAPPING%INTERNAL_START, FACES_MAPPING%INTERNAL_FINISH
                  FaceLocalNo=FACES_MAPPING%DOMAIN_LIST(faceIdx)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(FaceLocalNo)%BOUNDARY_LINE) THEN
                    !The face is an external face
                    count = count + 1

                  ELSE
                    !Do nothing
                  ENDIF
                ENDDO
                !This is the number of external faces of the mesh that are internal to this domain

                numberOfInternalExternalFaces=count
                count=0

                DO faceIdx=FACES_MAPPING%BOUNDARY_START, FACES_MAPPING%BOUNDARY_FINISH
                  FaceLocalNo=FACES_MAPPING%DOMAIN_LIST(faceIdx)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(FaceLocalNo)%BOUNDARY_LINE) THEN
                    !The face is an external face
                    count = count + 1
                  ELSE
                    !Do nothing
                  ENDIF
                ENDDO

                numberOfBoundaryExternalFaces=count
                count=0

                DO faceIdx=FACES_MAPPING%GHOST_START, FACES_MAPPING%GHOST_FINISH
                  FaceLocalNo=FACES_MAPPING%DOMAIN_LIST(faceIdx)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(FaceLocalNo)%BOUNDARY_LINE) THEN
                    !The face is an external face
                    count = count + 1
                  ELSE
                    !Do nothing
                  ENDIF
                ENDDO


                numberOfGhostExternalFaces=count


                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(NumberComputationalNodes-1),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(NumberComputationalNodes-1),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)


                !The has the number of internal and boundary external faces
                ALLOCATE(numberOfInternalAndBoundaryExternalFacesOnRank(0:NumberComputationalNodes-1))
                numberOfInternalAndBoundaryExternalFacesOnRank(MyComputationalNodeNumber)= &
                  & numberOfInternalExternalFaces+numberOfBoundaryExternalFaces


                DomainIdx=1
                ! commit send commands
                DO DomainNo=0,NumberComputationalNodes-1

                  IF(DomainNo==MyComputationalNodeNumber) THEN
                    !Do nothing
                  ELSE
                    CALL MPI_ISEND(numberOfInternalAndBoundaryExternalFacesOnRank(MyComputationalNodeNumber), 1, MPI_INT,  &
                      & DomainNo,0,computationalEnvironment%mpiCommunicator, sendRequestHandle(DomainIdx), MPI_IERROR)
                    CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,err,error,*999)
                    DomainIdx=DomainIdx+1
                  ENDIF
                ENDDO


                DomainIdx=1
                ! commit receive commands
                DO DomainNo=0,NumberComputationalNodes-1
                  IF(DomainNo==MyComputationalNodeNumber) THEN
                    !Do nothing
                  ELSE
                    CALL MPI_IRECV(numberOfInternalAndBoundaryExternalFacesOnRank(DomainNo), 1, MPI_INT, DomainNo, 0, &
                      & computationalEnvironment%mpiCommunicator, receiveRequestHandle(DomainIdx), MPI_IERROR)
                    CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,err,error,*999)
                    DomainIdx=DomainIdx+1
                  ENDIF
                ENDDO

                ! wait for all communication to finish
                CALL MPI_WAITALL(NumberComputationalNodes-1, sendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,err,error,*999)

                CALL MPI_WAITALL(NumberComputationalNodes-1, receiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,err,error,*999)

                !Calculate the start number for iterating through global dof numbers for this rank

                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(sendRequestHandle)) DEALLOCATE(sendRequestHandle)

                globalDofStartNumberFace=1
                DO DomainNo=0,MyComputationalNodeNumber-1

                  globalDofStartNumberFace=globalDofStartNumberFace+numberOfInternalAndBoundaryExternalFacesOnRank(DomainNo)

                ENDDO


                !Communicate the numberOfinternalAndBoundary of each domain to get the global number of external faces.
                ! allreduce number of external faces
                CALL MPI_ALLREDUCE(numberOfInternalExternalFaces+numberOfBoundaryExternalFaces, &
                  & numberOfGlobalExternalFaces,1,MPI_INTEGER,MPI_SUM, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,err,error,*999)

                BoundaryFaceNumbersCalculated=.TRUE.
              ENDIF





              NUMBER_OF_ELEMENT_DOFS = NUMBER_OF_ELEMENT_DOFS + ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL

              NUMBER_OF_FACE_DOFS = NUMBER_OF_FACE_DOFS + numberOfInternalExternalFaces + numberOfBoundaryExternalFaces + &
                & numberOfGhostExternalFaces

              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + ELEMENTS_MAPPING%NUMBER_OF_LOCAL+ &
                & numberOfInternalExternalFaces + numberOfBoundaryExternalFaces
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL+ &
                & numberOfInternalExternalFaces + numberOfBoundaryExternalFaces + &
                & numberOfGhostExternalFaces
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + ELEMENTS_MAPPING%NUMBER_OF_GLOBAL+ &
                & numberOfGlobalExternalFaces



              ! allocate param_to_dof_map for elements
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP% &
              & ELEMENTS(ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL), STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS = ELEMENTS_MAPPING% &
                & TOTAL_NUMBER_OF_LOCAL

              !FIXTHIS, this allocates all local faces, not just boundary faces, seems to be the only way to have a face-dof map
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP% &
              & FACES(FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL), STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS = FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL

            CASE(FIELD_LINE_BASED_INTERPOLATION)
              NUMBER_OF_LINE_DOFS = NUMBER_OF_LINE_DOFS + LINES_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + LINES_MAPPING%NUMBER_OF_LOCAL
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + LINES_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + LINES_MAPPING%NUMBER_OF_GLOBAL

              ! allocate param_to_dof_map for lines
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LINES_MAPPING%TOTAL_NUMBER_OF_LOCAL), &
                & STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS = LINES_MAPPING%TOTAL_NUMBER_OF_LOCAL

            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)

              !Calculate the number of external lines that are, internal, boundary, and ghost to this domain


              IF(.NOT.BoundaryLineNumbersCalculated) THEN
                count=0

                DO lineIdx=LINES_MAPPING%INTERNAL_START, LINES_MAPPING%INTERNAL_FINISH
                  lineLocalNo=LINES_MAPPING%DOMAIN_LIST(lineIdx)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(lineLocalNo)%BOUNDARY_LINE) THEN
                    !The line is an external line
                    count = count + 1

                  ELSE
                    !Do nothing
                  ENDIF
                ENDDO
                !This is the number of external lines of the mesh that are internal to this domain

                numberOfInternalExternalLines=count
                count=0

                DO lineIdx=LINES_MAPPING%BOUNDARY_START, LINES_MAPPING%BOUNDARY_FINISH
                  lineLocalNo=LINES_MAPPING%DOMAIN_LIST(lineIdx)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(lineLocalNo)%BOUNDARY_LINE) THEN
                    !The line is an external line
                    count = count + 1
                  ELSE
                    !Do nothing
                  ENDIF
                ENDDO

                numberOfBoundaryExternalLines=count
                count=0

                DO lineIdx=LINES_MAPPING%GHOST_START, LINES_MAPPING%GHOST_FINISH
                  LineLocalNo=LINES_MAPPING%DOMAIN_LIST(lineIdx)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(lineLocalNo)%BOUNDARY_LINE) THEN
                    !The line is an external line
                    count = count + 1
                  ELSE
                    !Do nothing
                  ENDIF
                ENDDO


                numberOfGhostExternalLines=count


                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(NumberComputationalNodes-1),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(NumberComputationalNodes-1),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)


                !The has the number of internal and boundary external lines
                ALLOCATE(numberOfInternalAndBoundaryExternalLinesOnRank(0:NumberComputationalNodes-1))
                numberOfInternalAndBoundaryExternalLinesOnRank(MyComputationalNodeNumber)= &
                  & numberOfInternalExternalLines+numberOfBoundaryExternalLines


                DomainIdx=1
                ! commit send commands
                DO DomainNo=0,NumberComputationalNodes-1

                  IF(DomainNo==MyComputationalNodeNumber) THEN
                    !Do nothing
                  ELSE
                    CALL MPI_ISEND(numberOfInternalAndBoundaryExternalLinesOnRank(MyComputationalNodeNumber), 1, MPI_INT,  &
                      & DomainNo,0,computationalEnvironment%mpiCommunicator, sendRequestHandle(DomainIdx), MPI_IERROR)
                    CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,err,error,*999)
                    DomainIdx=DomainIdx+1
                  ENDIF
                ENDDO


                DomainIdx=1
                ! commit receive commands
                DO DomainNo=0,NumberComputationalNodes-1
                  IF(DomainNo==MyComputationalNodeNumber) THEN
                    !Do nothing
                  ELSE
                    CALL MPI_IRECV(numberOfInternalAndBoundaryExternalLinesOnRank(DomainNo), 1, MPI_INT, DomainNo, 0, &
                      & computationalEnvironment%mpiCommunicator, receiveRequestHandle(DomainIdx), MPI_IERROR)
                    CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,err,error,*999)
                    DomainIdx=DomainIdx+1
                  ENDIF
                ENDDO

                ! wait for all communication to finish
                CALL MPI_WAITALL(NumberComputationalNodes-1, sendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,err,error,*999)

                CALL MPI_WAITALL(NumberComputationalNodes-1, receiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,err,error,*999)

                !Calculate the start number for iterating through global dof numbers for this rank

                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(sendRequestHandle)) DEALLOCATE(sendRequestHandle)

                globalDofStartNumberLine=1
                DO DomainNo=0,MyComputationalNodeNumber-1

                  globalDofStartNumberLine=globalDofStartNumberLine+numberOfInternalAndBoundaryExternalLinesOnRank(DomainNo)

                ENDDO


                !Communicate the numberOfinternalAndBoundary of each domain to get the global number of external lines.
                ! allreduce number of external lines
                CALL MPI_ALLREDUCE(numberOfInternalExternalLines+numberOfBoundaryExternalLines, &
                  & numberOfGlobalExternalLines,1,MPI_INTEGER,MPI_SUM, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,err,error,*999)

                BoundaryLineNumbersCalculated=.TRUE.
              ENDIF





              NUMBER_OF_ELEMENT_DOFS = NUMBER_OF_ELEMENT_DOFS + ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL

              NUMBER_OF_LINE_DOFS = NUMBER_OF_LINE_DOFS + numberOfInternalExternalLines + numberOfBoundaryExternalLines + &
                & numberOfGhostExternalLines

              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + ELEMENTS_MAPPING%NUMBER_OF_LOCAL+ &
                & numberOfInternalExternalLines + numberOfBoundaryExternalLines
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL+ &
                & numberOfInternalExternalLines + numberOfBoundaryExternalLines + &
                & numberOfGhostExternalLines
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + ELEMENTS_MAPPING%NUMBER_OF_GLOBAL+ &
                & numberOfGlobalExternalLines



              ! allocate param_to_dof_map for elements
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP% &
              & ELEMENTS(ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL), STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS = ELEMENTS_MAPPING% &
                & TOTAL_NUMBER_OF_LOCAL

              !FIXTHIS, this allocates all local lines, not just boundary lines, seems to be the only way to have a line-dof map
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP% &
              & LINES(LINES_MAPPING%TOTAL_NUMBER_OF_LOCAL), STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS = LINES_MAPPING%TOTAL_NUMBER_OF_LOCAL


            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NUMBER_OF_NODE_DOFS = NUMBER_OF_NODE_DOFS + DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_LOCAL_VARIABLE_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS + DOFS_MAPPING%NUMBER_OF_LOCAL
              TOTAL_NUMBER_OF_VARIABLE_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS + DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_GLOBAL_VARIABLE_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS + DOFS_MAPPING%NUMBER_OF_GLOBAL

              ! allocate param_to_dof_map for nodes
              ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NODES_MAPPING%TOTAL_NUMBER_OF_LOCAL),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate param to dof nodes map.",ERR,ERROR,*999)
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS = NODES_MAPPING%TOTAL_NUMBER_OF_LOCAL

            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)

            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)

            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)

            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                & " of variable type  "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT

            ! FIXTHIS These were formally allocated for every component.
            ! !todo/ These should only be called if that interpolation type is present
            ! ! allocate param_to_dof_map for nodes
            ! ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NODES_MAPPING%TOTAL_NUMBER_OF_LOCAL),STAT=ERR)
            ! IF(ERR/=0) CALL FlagError("Could not allocate param to dof nodes map.",ERR,ERROR,*999)
            !
            ! ! allocate param_to_dof_map for elements
            ! ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ELEMENTS_MAPPING%TOTAL_NUMBER_OF_LOCAL), &
            !   & STAT=ERR)
            ! IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)
            !
            ! ! allocate param_to_dof_map for faces
            ! ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FACES_MAPPING%TOTAL_NUMBER_OF_LOCAL), &
            !   & STAT=ERR)
            ! IF(ERR/=0) CALL FlagError("Could not allocate param to dof elements map.",ERR,ERROR,*999)

          ENDDO !component_idx

          ! mapping from variable data (multiple components) to storage positions (dofs)
          FIELD_VARIABLE_DOFS_MAPPING=>FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING

          ! Define the pointer to the decomposition
          IF(.NOT.ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING%DECOMPOSITION)) THEN
            FIELD_VARIABLE_DOFS_MAPPING%DECOMPOSITION=>FIELD%DECOMPOSITION
          ELSE
            CALL FlagError("FIELD_VARIABLE_DOFS_MAPPING%DECOMPOSITION already associated!",ERR,ERROR,*999)
          END IF

          PRINT *, "Testing field dofs calculation."
          STOP

          FIELD%VARIABLES(variable_idx)%NUMBER_OF_DOFS = NUMBER_OF_LOCAL_VARIABLE_DOFS
          FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS = TOTAL_NUMBER_OF_VARIABLE_DOFS
          FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS = NUMBER_OF_GLOBAL_VARIABLE_DOFS

          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_LOCAL = NUMBER_OF_LOCAL_VARIABLE_DOFS
          FIELD_VARIABLE_DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL = TOTAL_NUMBER_OF_VARIABLE_DOFS
          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_GLOBAL = NUMBER_OF_GLOBAL_VARIABLE_DOFS
          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_DOMAINS = NumberComputationalNodes

          IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": number dofs local: ", NUMBER_OF_LOCAL_VARIABLE_DOFS, &
            & ", total: ", TOTAL_NUMBER_OF_VARIABLE_DOFS,", global: ", NUMBER_OF_GLOBAL_VARIABLE_DOFS

          ! a 'parameter' is the catch-all term for nodes, elements, gauss, components etc.
          ! allocate DOF_TYPE
          ! DOF_TYPE(1,dofNo) = type of dof: 1=constant, 2=element based, 3=node based, 4=point based
          ! DOF_TYPE(2,dofNo) = index of corresponding DOF2PARAM_MAP
          ! FIELD_CONSTANT_DOF_TYPE=1, FIELD_ELEMENT_DOF_TYPE=2, FIELD_FACE_DOF_TYPE=3, FIELD_LINE_DOF_TYPE=4, FIELD_NODE_DOF_TYPE=5, FIELD_GRID_POINT_DOF_TYPE=6, FIELD_GAUSS_POINT_DOF_TYPE=7, FIELD_DATA_POINT_DOF_TYPE=8,

          ! allocate dof to parameter mappings
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,TOTAL_NUMBER_OF_VARIABLE_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS

          ! allocate DOF2PARAM_MAP for constant dofs
          IF(NUMBER_OF_CONSTANT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(NUMBER_OF_CONSTANT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter constant map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=NUMBER_OF_CONSTANT_DOFS
          ENDIF

          ! allocate DOF2PARAM_MAP for element based dofs
          IF(NUMBER_OF_ELEMENT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,NUMBER_OF_ELEMENT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter element map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=NUMBER_OF_ELEMENT_DOFS
          ENDIF

          ! allocate DOF2PARAM_MAP for face based dofs
          IF(NUMBER_OF_FACE_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(2,NUMBER_OF_FACE_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter face map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_FACE_DOFS=NUMBER_OF_FACE_DOFS
          ENDIF

          ! allocate DOF2PARAM_MAP for line based dofs
          IF(NUMBER_OF_LINE_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(2,NUMBER_OF_LINE_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter line map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_LINE_DOFS=NUMBER_OF_LINE_DOFS
          ENDIF

          ! allocate DOF2PARAM_MAP for node based dofs
          IF(NUMBER_OF_NODE_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,NUMBER_OF_NODE_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter node map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=NUMBER_OF_NODE_DOFS
          ENDIF

          ! allocate storage for domain mapping
          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(TOTAL_NUMBER_OF_VARIABLE_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_TO_GLOBAL_MAP of size "//&
              & TRIM(NUMBER_TO_VSTRING(TOTAL_NUMBER_OF_VARIABLE_DOFS,"*",ERR,ERROR))//".",ERR,ERROR,*999)

          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(TOTAL_NUMBER_OF_VARIABLE_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate DOMAIN_LIST of size "//&
              & TRIM(NUMBER_TO_VSTRING(TOTAL_NUMBER_OF_VARIABLE_DOFS,"*",ERR,ERROR))//".",ERR,ERROR,*999)

          ! allocate adjacent domains array, use information from first component
          ! get nodes mapping of first component
          component_idx = 1
          FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
          NODES_MAPPING=>FIELD_COMPONENT%DOMAIN%MAPPINGS%NODES

          ! set number of adjacent domains from nodes mapping
          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS = NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

          ! allocate adjacent domains array
          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate ADJACENT_DOMAINS",ERR,ERROR,*999)

          ! initialize adjacent domains array
          DO AdjacentDomainIdx=1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
            !CALL domainMappings_ADJACENT_DOMAIN_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx), &
            !  & ERR,ERROR,*999)
            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS = 0
            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS = 0
            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_FURTHER_LINKED_GHOSTS = 0
            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER &
              & = NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
          ENDDO

          ! create list that collects boundary dofs
          NULLIFY(BoundaryDofLocalNosList)
          CALL LIST_CREATE_START(BoundaryDofLocalNosList,ERR,ERROR,*999)
          CALL LIST_DATA_TYPE_SET(BoundaryDofLocalNosList,LIST_INTG_TYPE,ERR,ERROR,*999)
          CALL LIST_CREATE_FINISH(BoundaryDofLocalNosList,ERR,ERROR,*999)

          ! create helper objects for nodal dofs
          IF(NUMBER_OF_NODE_DOFS>0) THEN
            ! allocate helper arrays
            ALLOCATE(NumberBreaksNode(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate NumberBreaksNode",ERR,ERROR,*999)

            ALLOCATE(NumberBreaksDoubleNode(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate NumberBreaksDoubleNode",ERR,ERROR,*999)

            ALLOCATE(RowOffsetNode(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate RowOffsetNode",ERR,ERROR,*999)

            ALLOCATE(RowOffsetZeroBasedNode(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate RowOffsetZeroBasedNode",ERR,ERROR,*999)

            NodeDofIdx = 1
          ENDIF

          ! create helper objects for face dofs
          IF(NUMBER_OF_FACE_DOFS>0) THEN
            ! allocate helper arrays
            ALLOCATE(NumberBreaksFace(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate NumberBreaksFace",ERR,ERROR,*999)

            ALLOCATE(NumberBreaksDoubleFace(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate NumberBreaksDoubleFace",ERR,ERROR,*999)

            ALLOCATE(RowOffsetFace(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate RowOffsetFace",ERR,ERROR,*999)

            ALLOCATE(RowOffsetZeroBasedFace(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate RowOffsetZeroBasedFace",ERR,ERROR,*999)

            faceDofIdx = 1
          ENDIF

          ! create helper objects for line dofs
          IF(NUMBER_OF_LINE_DOFS>0) THEN
            ! allocate helper arrays
            ALLOCATE(NumberBreaksLine(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate NumberBreaksLine",ERR,ERROR,*999)

            ALLOCATE(NumberBreaksDoubleLine(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate NumberBreaksDoubleLine",ERR,ERROR,*999)

            ALLOCATE(RowOffsetLine(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate RowOffsetLine",ERR,ERROR,*999)

            ALLOCATE(RowOffsetZeroBasedLine(0:NumberComputationalNodes-1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate RowOffsetZeroBasedLine",ERR,ERROR,*999)

            lineDofIdx = 1
          ENDIF

          ! create helper objects for element dofs
          IF(NUMBER_OF_ELEMENT_DOFS>0) THEN

            ALLOCATE(FirstDofGlobalNo(FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate FirstDofGlobalNo",ERR,ERROR,*999)

            ALLOCATE(Element1GlobalNo(FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate FirstElementGlobalNo",ERR,ERROR,*999)

            ALLOCATE(FirstDofLocalNo(FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate FirstDofGlobalNo",ERR,ERROR,*999)

            ALLOCATE(FirstElementDofIdx(FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate FirstElementGlobalNo",ERR,ERROR,*999)

            CurrentElementDofIdx = 1
          ENDIF

          ConstantDofIdx = 1

          CurrentDofLocalNo = 1    ! counter of local dof no, gets increased while iterating over the newly visited dofs
          CurrentDofGlobalNo = 1   ! counter of global dof no, analoguous to local dof counter
          InternalDofIdx = 1       ! counter of the idx for DOMAIN_LIST

          ! loop over components of current field variable
          DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
            FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
            TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
            !TOPOLOGY=>FIELD_COMPONENT%DOMAIN%TOPOLOGY
            domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
            ELEMENTS_MAPPING=>domainMappings%ELEMENTS
            NODES_MAPPING=>domainMappings%NODES
            FACES_MAPPING=>domainMappings%FACES
            LINES_MAPPING=>domainMappings%LINES

            ! handle node based interpolation dofs
            SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
            CASE(FIELD_NODE_BASED_INTERPOLATION)

              ! Count number of 'breaks' in contiguous global node numbering on current domain. A break is when there
              ! is a jump in the global node number for successive local node numbers.
              LocalNumberBreaks = 0
              PreviousNodeGlobalNo = -1

              ! loop over internal and boundary nodes
              DO NodeLocalNo = 1,NODES_MAPPING%NUMBER_OF_LOCAL
                NodeGlobalNo = NODES_MAPPING%LOCAL_TO_GLOBAL_MAP(NodeLocalNo)

                ! if there is a jump in global node no. count break
                IF (NodeGlobalNo /= PreviousNodeGlobalNo+1 .AND. PreviousNodeGlobalNo /= -1) THEN
                  LocalNumberBreaks = LocalNumberBreaks + 1
                ENDIF
                PreviousNodeGlobalNo = NodeGlobalNo
              ENDDO
              ! add last node also as break
              LocalNumberBreaks = LocalNumberBreaks + 1

              ! exchange the number of breaks on every rank
              ! merge information from every rank
              NumberBreaksNode(MyComputationalNodeNumber) = LocalNumberBreaks
              CALL MPI_ALLGATHER(MPI_IN_PLACE,1,MPI_INTEGER, &
                & NumberBreaksNode,1,MPI_INTEGER,computationalEnvironment%mpiCommunicator,MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLGATHER",MPI_IERROR,ERR,ERROR,*999)

              IF (DIAGNOSTICS2) THEN
                PRINT *, MyComputationalNodeNumber, " ------------------------------------ "
                PRINT *, MyComputationalNodeNumber, ": component ", component_idx, ", number breaks: ",NumberBreaksNode
              ENDIF

              ! DofTable
              !                         1 break: 2 values
              !        break no. ->     /--^-\
              ! rank   (glob.node,dof)  (4,13) (12,24) ...
              !  |
              !  v
              ! ---------------------------
              ! explanation of the triple values:
              !    global node: the last global node no. that is on the rank before the break
              !    dof: number of dofs in last break-free sequence
              !
              ! the table is laid out row-major as a 1D array where each row has NumberBreaksNode(rank) entries

              ! compute the row offsets, i.e. the indices where each row starts
              RowOffsetNode(0) = 1
              DO I = 1,NumberComputationalNodes-1
                RowOffsetNode(I) = RowOffsetNode(I-1) + NumberBreaksNode(I-1)*2
              ENDDO

              ! compute global number of breaks as sum over all LocalNumberBreaks
              GlobalNumberBreaks = 0
              DO I = 0,NumberComputationalNodes-1
                GlobalNumberBreaks = GlobalNumberBreaks + NumberBreaksNode(I)
              ENDDO

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": RowOffsetNode: ", RowOffsetNode, &
                & ", GlobalNumberBreaks=", GlobalNumberBreaks

              ! allocate lookup table
              ALLOCATE(DofTable(GlobalNumberBreaks*2),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate DofTable of size "//&
                & TRIM(NUMBER_TO_VSTRING(GlobalNumberBreaks*2,"*",ERR,ERROR))//".",ERR,ERROR,*999)

              ! reset row that belongs to own rank to 0
              DofTable(RowOffsetNode(MyComputationalNodeNumber):RowOffsetNode(MyComputationalNodeNumber)+LocalNumberBreaks) = 0

              ! fill table with own values
              BreakIdx = 0
              NumberDofsInSequence = 0
              PreviousNodeGlobalNo = -1

              ! loop over internal and boundary nodes
              DO NodeLocalNo = 1,NODES_MAPPING%NUMBER_OF_LOCAL
                NodeGlobalNo = NODES_MAPPING%LOCAL_TO_GLOBAL_MAP(NodeLocalNo)

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": node global ",NodeGlobalNo

                ! if there is a jump in global node no. count break
                IF (NodeGlobalNo /= PreviousNodeGlobalNo+1 .AND. PreviousNodeGlobalNo /= -1) THEN

                  DofTableIndex = RowOffsetNode(MyComputationalNodeNumber) + BreakIdx*2
                  BreakIdx = BreakIdx + 1

                  ! set first entry of pair in lookup table: global node no. end
                  DofTable(DofTableIndex+0) = PreviousNodeGlobalNo

                  ! set second entry of pair in lookup table: number of dofs in break-free sequence
                  DofTable(DofTableIndex+1) = NumberDofsInSequence


                  !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": jump, (",PreviousNodeGlobalNo,NumberDofsInSequence,")"

                  ! reset dof counter
                  NumberDofsInSequence = 0
                ENDIF

                ! advance local dof no by number of dofs on current node
                DO DerivativeIdx=1,TOPOLOGY%NODES%NODES(NodeGlobalNo)%numberOfDerivatives
                  NumberDofsInSequence = NumberDofsInSequence + &
                    & TOPOLOGY%NODES%NODES(NodeGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions
                ENDDO

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberDofsInSequence: ", NumberDofsInSequence
                PreviousNodeGlobalNo = NodeGlobalNo

              ENDDO   ! NodeLocalNo

              ! add last node also as break
              DofTableIndex = RowOffsetNode(MyComputationalNodeNumber) + BreakIdx*2
              DofTable(DofTableIndex+0) = PreviousNodeGlobalNo
              DofTable(DofTableIndex+1) = NumberDofsInSequence

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": last: (",PreviousNodeGlobalNo,NumberDofsInSequence,")"

              ! create auxiliary arrays for allgatherv
              NumberBreaksDoubleNode = 2*NumberBreaksNode
              RowOffsetZeroBasedNode = RowOffsetNode-1

              !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberBreaksDoubleNode:",NumberBreaksDoubleNode, &
              !  & ", RowOffsetNode:",RowOffsetNode, ", RowOffsetZeroBasedNode:",RowOffsetZeroBasedNode
              !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": pre DofTable:",DofTable

              ! merge information from every rank
              CALL MPI_ALLGATHERV(MPI_IN_PLACE,0,MPI_INTEGER, &
                & DofTable,NumberBreaksDoubleNode,RowOffsetZeroBasedNode,MPI_INTEGER,computationalEnvironment%mpiCommunicator, &
                  & MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLGATHERV",MPI_IERROR,ERR,ERROR,*999)

              IF (DIAGNOSTICS2) THEN
                PRINT *, MyComputationalNodeNumber, ": DofTable: "
                DO I = 0,NumberComputationalNodes-1
                  WRITE (*,'(2(I0,A))',ADVANCE='NO') MyComputationalNodeNumber, ": rank ",I," "
                  DO BreakIdx=0,NumberBreaksNode(I)-1
                    WRITE (*,'(2(A,I0),A)',ADVANCE='NO') "(",DofTable(RowOffsetNode(I)+BreakIdx*2), &
                      & ",",DofTable(RowOffsetNode(I)+BreakIdx*2+1),")"
                  ENDDO
                  PRINT *, ""
                ENDDO
              ENDIF

              !        break no. ->
              ! rank   (glob.node,dof)  (4,13) (12,24) ...
              !  |
              !  v
              ! find out global dof no. of first local dof
              NodeLocalNo = 1
              LocalInternalNodeIdx = 1

              CurrentRank = 0
              NodeStartGlobalNo = 1
              NodeStopGlobalNo = -1
              NumberDofsCurrentSequence = 0
              LocalNodeIdx = NODES_MAPPING%INTERNAL_START

              ! loop over all break-free sequences
              DO

                ! determine rank that has the lowest global node no. above the current start node
                ! loop over ranks
                DO I = 0,NumberComputationalNodes-1
                  ! determine the first global no. above the current on rank I (NodeOnCurrentComputationalNodeGlobalNo)
                  NodeOnCurrentComputationalNodeGlobalNo = 0
                  NumberDofsOnCurrentComputationalNode = 0

                  ! loop over breaks
                  DO BreakIdx = 0,NumberBreaksNode(I)-1

                    ! get global number of break
                    NodeGlobalNo = DofTable(RowOffsetNode(I)+BreakIdx*2)
                    NumberDofs = DofTable(RowOffsetNode(I)+BreakIdx*2+1)

                    ! store it if it is the first after start node
                    IF (NodeGlobalNo >= NodeStartGlobalNo) THEN
                      NodeOnCurrentComputationalNodeGlobalNo = NodeGlobalNo
                      NumberDofsOnCurrentComputationalNode = NumberDofs
                      EXIT
                    ENDIF
                  ENDDO

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":   rank ", I, &
                    & ", node global ", NodeOnCurrentComputationalNodeGlobalNo, ", ndofs: ", NumberDofsOnCurrentComputationalNode

                  ! if a node was found on rank I
                  IF (NodeOnCurrentComputationalNodeGlobalNo /= 0) THEN
                    ! store NodeOnCurrentComputationalNodeGlobalNo if it is the lowest node so far
                    IF (NodeStopGlobalNo == -1 .OR. NodeOnCurrentComputationalNodeGlobalNo < NodeStopGlobalNo) THEN
                      NodeStopGlobalNo = NodeOnCurrentComputationalNodeGlobalNo
                      CurrentRank = I
                      NumberDofsCurrentSequence = NumberDofsOnCurrentComputationalNode
                    ENDIF
                  ENDIF
                ENDDO  ! I


                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": range [", NodeStartGlobalNo, ",", NodeStopGlobalNo, "]", &
                    & " on rank", CurrentRank


                ! the current range of nodes [NodeStartGlobalNo,NodeStopGlobalNo] is on rank CurrentRank
                ! and has number of dofs NumberDofsCurrentSequence, starting from CurrentDofGlobalNo

                ! add up dof no.s
                IF (CurrentRank == MyComputationalNodeNumber) THEN
                  ! loop over nodes of current break-free sequences
                  DO
                    NodeGlobalNo = NODES_MAPPING%LOCAL_TO_GLOBAL_MAP(NodeLocalNo)

                    IF (DIAGNOSTICS2) WRITE(*,'(5(I0,A))',ADVANCE='no') MyComputationalNodeNumber, ": on this rank, node global ", &
                      & NodeGlobalNo,", local ",NodeLocalNo,", (node idx",LocalInternalNodeIdx,&
                      & ", local ",NODES_MAPPING%DOMAIN_LIST(LocalInternalNodeIdx),"),  is internal: "

                    ! check if current node is internal or boundary
                    CurrentNodeIsInternal = .FALSE.
                    IF (NodeLocalNo == NODES_MAPPING%DOMAIN_LIST(LocalInternalNodeIdx) &
                      & .AND. LocalInternalNodeIdx <= NODES_MAPPING%INTERNAL_FINISH) THEN
                      CurrentNodeIsInternal = .TRUE.
                      LocalInternalNodeIdx = LocalInternalNodeIdx + 1
                    ENDIF

                    IF (DIAGNOSTICS2) WRITE(*,*) CurrentNodeIsInternal

                    NumberDerivatives = TOPOLOGY%NODES%NODES(NodeGlobalNo)%numberOfDerivatives

                    ! allocate parameter to dof map for nodes
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)%DERIVATIVES(&
                      & NumberDerivatives),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate param to dof nodes derivative map for node local "//&
                      & TRIM(NUMBER_TO_VSTRING(NodeLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                    ! loop over dofs for current node, derivatives
                    DO DerivativeIdx=1,NumberDerivatives

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": derivative ", DerivativeIdx, "/", NumberDerivatives

                      NumberVersions = TOPOLOGY%NODES%NODES(NodeGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions

                      ! allocate parameter to dof map for node, derivative, versions
                      ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)%DERIVATIVES(DerivativeIdx)%&
                        & VERSIONS(NumberVersions),&
                        & STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate param to dof nodes derivative versions map for node local "//&
                        & TRIM(NUMBER_TO_VSTRING(NodeLocalNo,"*",ERR,ERROR))//", derivative index "//&
                        & TRIM(NUMBER_TO_VSTRING(DerivativeIdx,"*",ERR,ERROR)),ERR,ERROR,*999)

                      DO VersionIdx=1,NumberVersions

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": version ", VersionIdx, "/", NumberVersions

                        ! add global dof no to LOCAL_TO_GLOBAL_MAP
                        FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

                        ! if internal node, add dof index to DOMAIN_LIST
                        IF (CurrentNodeIsInternal) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                          InternalDofIdx = InternalDofIdx + 1
                        ELSE
                          ! if node is not internal, save boundary dofs
                          CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, CurrentDofLocalNo, ERR, ERROR, *999)
                        ENDIF

                        IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    d",DerivativeIdx,"v",VersionIdx,&
                          & "dof idx ",InternalDofIdx-1,", local",CurrentDofLocalNo,", global",CurrentDofGlobalNo

                        ! setup dof to parameter map
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_NODE_DOF_TYPE
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=NodeDofIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(1,NodeDofIdx)=VersionIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(2,NodeDofIdx)=DerivativeIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(3,NodeDofIdx)=NodeLocalNo
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,NodeDofIdx)=component_idx
                        NodeDofIdx = NodeDofIdx + 1   ! this is the index when iterating over all node dofs of this field variable

                        ! setup reverse parameter to dof map
                        FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)%DERIVATIVES(DerivativeIdx)% &
                          & VERSIONS(VersionIdx) = CurrentDofLocalNo

                        !IF (DIAGNOSTICS2) PRINT "(4(I0,A),I0)", MyComputationalNodeNumber, ": set dof(",NodeLocalNo,",",&
                        !  & DerivativeIdx, &
                        !  & ",",VersionIdx,")=",CurrentDofLocalNo

                        ! set NUMBER_OF_SEND_GHOSTS

                        ! find out on which domains (if any) the corresponding ghost nodes reside from nodes mapping
                        ! loop over the adjacent domains of the nodes mapping which are the same as for the dofs mapping
                        DO AdjacentDomainIdx = 1,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                          NodeIsOnCurrentAdjacentDomain = .FALSE.
                          ! check if node is a ghost on the adjacent domain with index AdjacentDomainIdx

                          ! loop over send ghost local numbers
                          DO GhostSendIdx = 1,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                            ! if node was found on adjacent domain AdjacentDomainIdx
                            IF (NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                              & == NodeLocalNo) THEN
                              NodeIsOnCurrentAdjacentDomain = .TRUE.
                              EXIT
                            ENDIF
                          ENDDO

                          ! if the current node is on the current adjacent domain as ghost node
                          IF (NodeIsOnCurrentAdjacentDomain) THEN

                            ! add current dof to LOCAL_GHOST_SEND_INDICES
                            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS &
                              = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS + 1

                            ! add CurrentDofLocalNo to LOCAL_GHOST_SEND_INDICES
                            IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                              ! array does not yet exist, allocate with size 1
                              ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)% &
                                & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                              IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                              FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(1) &
                                & = CurrentDofLocalNo
                            ELSE
                              ! array already exists, increase size by 1
                              FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                                & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES, &
                                & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS], &
                                & [CurrentDofLocalNo])
                            ENDIF

                          ENDIF
                        ENDDO  ! AdjacentDomainIdx

                        ! advance local and global dof no
                        CurrentDofLocalNo = CurrentDofLocalNo + 1
                        CurrentDofGlobalNo = CurrentDofGlobalNo + 1
                      ENDDO  ! VersionIdx
                    ENDDO  ! DerivativeIdx

                    NodeLocalNo = NodeLocalNo + 1

                    IF (NodeGlobalNo == NodeStopGlobalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": Node global ", NodeGlobalNo, " is stop node, exit"
                      EXIT
                    ENDIF
                  ENDDO   ! loop over nodes in break-free sequence
                ELSE
                  ! node range is not on own rank

                  ! advance global dof no by number of dofs on foreign rank
                  CurrentDofGlobalNo = CurrentDofGlobalNo + NumberDofsCurrentSequence
                ENDIF

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NodeStopGlobalNo=",NodeStopGlobalNo,&
                  & ", end:",NODES_MAPPING%NUMBER_OF_GLOBAL
                IF (NodeStopGlobalNo == NODES_MAPPING%NUMBER_OF_GLOBAL) EXIT

                ! advance start and stop node to next sequence
                NodeStartGlobalNo = NodeStopGlobalNo+1
                NodeStopGlobalNo = -1     ! unknown

              ENDDO   ! loop over break-free sequences

              IF(ALLOCATED(DofTable)) DEALLOCATE(DofTable)


            CASE(FIELD_FACE_BASED_INTERPOLATION)

              ! Count number of 'breaks' in contiguous global face numbering on current domain. A break is when there
              ! is a jump in the global face number for successive local face numbers.
              LocalNumberBreaks = 0
              PreviousFaceGlobalNo = -1

              ! loop over internal and boundary faces
              DO FaceLocalNo = 1,FACES_MAPPING%NUMBER_OF_LOCAL
                FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                ! if there is a jump in global face no. count break
                IF (FaceGlobalNo /= PreviousFaceGlobalNo+1 .AND. PreviousFaceGlobalNo /= -1) THEN
                  LocalNumberBreaks = LocalNumberBreaks + 1
                ENDIF
                PreviousFaceGlobalNo = FaceGlobalNo
              ENDDO
              ! add last face also as break
              LocalNumberBreaks = LocalNumberBreaks + 1

              ! exchange the number of breaks on every rank
              ! merge information from every rank
              NumberBreaksFace(MyComputationalNodeNumber) = LocalNumberBreaks
              CALL MPI_ALLGATHER(MPI_IN_PLACE,1,MPI_INTEGER, &
                & NumberBreaksFace,1,MPI_INTEGER,computationalEnvironment%mpiCommunicator,MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLGATHER",MPI_IERROR,ERR,ERROR,*999)

              IF (DIAGNOSTICS2) THEN
                PRINT *, MyComputationalNodeNumber, " ------------------------------------ "
                PRINT *, MyComputationalNodeNumber, ": component ", component_idx, ", number breaks: ",NumberBreaksFace
              ENDIF

              ! DofTable
              !                         1 break: 2 values
              !        break no. ->     /--^-\
              ! rank   (glob.face,dof)  (4,13) (12,24) ...
              !  |
              !  v
              ! ---------------------------
              ! explanation of the triple values:
              !    global face: the last global face no. that is on the rank before the break
              !    dof: number of dofs in last break-free sequence
              !
              ! the table is laid out row-major as a 1D array where each row has NumberBreaksFace(rank) entries

              ! compute the row offsets, i.e. the indices where each row starts
              RowOffsetFace(0) = 1
              DO I = 1,NumberComputationalNodes-1
                RowOffsetFace(I) = RowOffsetFace(I-1) + NumberBreaksFace(I-1)*2
              ENDDO

              ! compute global number of breaks as sum over all LocalNumberBreaks
              GlobalNumberBreaks = 0
              DO I = 0,NumberComputationalNodes-1
                GlobalNumberBreaks = GlobalNumberBreaks + NumberBreaksFace(I)
              ENDDO

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": RowOffsetFace: ", RowOffsetFace, &
                & ", GlobalNumberBreaks=", GlobalNumberBreaks

              ! allocate lookup table
              ALLOCATE(DofTable(GlobalNumberBreaks*2),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate DofTable of size "//&
                & TRIM(NUMBER_TO_VSTRING(GlobalNumberBreaks*2,"*",ERR,ERROR))//".",ERR,ERROR,*999)

              ! reset row that belongs to own rank to 0
              DofTable(RowOffsetFace(MyComputationalNodeNumber):RowOffsetFace(MyComputationalNodeNumber)+LocalNumberBreaks) = 0

              ! fill table with own values
              BreakIdx = 0
              NumberDofsInSequence = 0
              PreviousFaceGlobalNo = -1

              ! loop over internal and boundary faces
              DO FaceLocalNo = 1,FACES_MAPPING%NUMBER_OF_LOCAL
                FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": face global ",FaceGlobalNo

                ! if there is a jump in global face no. count break
                IF (FaceGlobalNo /= PreviousFaceGlobalNo+1 .AND. PreviousFaceGlobalNo /= -1) THEN

                  DofTableIndex = RowOffsetFace(MyComputationalNodeNumber) + BreakIdx*2
                  BreakIdx = BreakIdx + 1

                  ! set first entry of pair in lookup table: global face no. end
                  DofTable(DofTableIndex+0) = PreviousFaceGlobalNo

                  ! set second entry of pair in lookup table: number of dofs in break-free sequence
                  DofTable(DofTableIndex+1) = NumberDofsInSequence


                  !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": jump, (",PreviousFaceGlobalNo,NumberDofsInSequence,")"

                  ! reset dof counter
                  NumberDofsInSequence = 0
                ENDIF

                !! advance local dof no by number of dofs on current face
                !DO DerivativeIdx=1,TOPOLOGY%FACES%FACES(FaceGlobalNo)%numberOfDerivatives
                !  NumberDofsInSequence = NumberDofsInSequence + &
                !    & TOPOLOGY%FACES%FACES(FaceGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions
                !ENDDO
                NumberDofsInSequence = NumberDofsInSequence + 1 !Currently faces don't have derivatives so only one dof on face

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberDofsInSequence: ", NumberDofsInSequence
                PreviousFaceGlobalNo = FaceGlobalNo

              ENDDO   ! FaceLocalNo

              ! add last face also as break
              DofTableIndex = RowOffsetFace(MyComputationalNodeNumber) + BreakIdx*2
              DofTable(DofTableIndex+0) = PreviousFaceGlobalNo
              DofTable(DofTableIndex+1) = NumberDofsInSequence

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": last: (",PreviousFaceGlobalNo,NumberDofsInSequence,")"

              ! create auxiliary arrays for allgatherv
              NumberBreaksDoubleFace = 2*NumberBreaksFace
              RowOffsetZeroBasedFace = RowOffsetFace-1

              !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberBreaksDoubleFace:",NumberBreaksDoubleFace, &
              !  & ", RowOffsetFace:",RowOffsetFace, ", RowOffsetZeroBasedFace:",RowOffsetZeroBasedFace
              !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": pre DofTable:",DofTable

              ! merge information from every rank
              CALL MPI_ALLGATHERV(MPI_IN_PLACE,0,MPI_INTEGER, &
                & DofTable,NumberBreaksDoubleFace,RowOffsetZeroBasedFace,MPI_INTEGER,computationalEnvironment%mpiCommunicator,  &
                  & MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLGATHERV",MPI_IERROR,ERR,ERROR,*999)

              IF (DIAGNOSTICS2) THEN
                PRINT *, MyComputationalNodeNumber, ": DofTable: "
                DO I = 0,NumberComputationalNodes-1
                  WRITE (*,'(2(I0,A))',ADVANCE='NO') MyComputationalNodeNumber, ": rank ",I," "
                  DO BreakIdx=0,NumberBreaksFace(I)-1
                    WRITE (*,'(2(A,I0),A)',ADVANCE='NO') "(",DofTable(RowOffsetFace(I)+BreakIdx*2), &
                      & ",",DofTable(RowOffsetFace(I)+BreakIdx*2+1),")"
                  ENDDO
                  PRINT *, ""
                ENDDO
              ENDIF

              !        break no. ->
              ! rank   (glob.face,dof)  (4,13) (12,24) ...
              !  |
              !  v
              ! find out global dof no. of first local dof
              FaceLocalNo = 1
              LocalInternalFaceIdx = 1

              CurrentRank = 0
              FaceStartGlobalNo = 1
              FaceStopGlobalNo = -1
              NumberDofsCurrentSequence = 0
              LocalFaceIdx = FACES_MAPPING%INTERNAL_START

              ! loop over all break-free sequences
              DO

                ! determine rank that has the lowest global face no. above the current start face
                ! loop over ranks
                DO I = 0,NumberComputationalNodes-1
                  ! determine the first global no. above the current on rank I (FaceOnCurrentComputationalNodeGlobalNo)
                  FaceOnCurrentComputationalNodeGlobalNo = 0
                  NumberDofsOnCurrentComputationalNode = 0

                  ! loop over breaks
                  DO BreakIdx = 0,NumberBreaksFace(I)-1

                    ! get global number of break
                    FaceGlobalNo = DofTable(RowOffsetFace(I)+BreakIdx*2)
                    NumberDofs = DofTable(RowOffsetFace(I)+BreakIdx*2+1)

                    ! store it if it is the first after start face
                    IF (FaceGlobalNo >= FaceStartGlobalNo) THEN
                      FaceOnCurrentComputationalNodeGlobalNo = FaceGlobalNo
                      NumberDofsOnCurrentComputationalNode = NumberDofs
                      EXIT
                    ENDIF
                  ENDDO

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":   rank ", I, &
                    & ", face global ", FaceOnCurrentComputationalNodeGlobalNo, ", ndofs: ", NumberDofsOnCurrentComputationalNode

                  ! if a face was found on rank I
                  IF (FaceOnCurrentComputationalNodeGlobalNo /= 0) THEN
                    ! store FaceOnCurrentComputationalNodeGlobalNo if it is the lowest face so far
                    IF (FaceStopGlobalNo == -1 .OR. FaceOnCurrentComputationalNodeGlobalNo < FaceStopGlobalNo) THEN
                      FaceStopGlobalNo = FaceOnCurrentComputationalNodeGlobalNo
                      CurrentRank = I
                      NumberDofsCurrentSequence = NumberDofsOnCurrentComputationalNode
                    ENDIF
                  ENDIF
                ENDDO  ! I


                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": range [", FaceStartGlobalNo, ",", FaceStopGlobalNo, "]", &
                    & " on rank", CurrentRank


                ! the current range of faces [FaceStartGlobalNo,FaceStopGlobalNo] is on rank CurrentRank
                ! and has number of dofs NumberDofsCurrentSequence, starting from CurrentDofGlobalNo

                ! add up dof no.s
                IF (CurrentRank == MyComputationalNodeNumber) THEN
                  ! loop over faces of current break-free sequences
                  DO
                    FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                    IF (DIAGNOSTICS2) WRITE(*,'(5(I0,A))',ADVANCE='no') MyComputationalNodeNumber, ": on this rank, face global ", &
                      & FaceGlobalNo,", local ",FaceLocalNo,", (face idx",LocalInternalFaceIdx,&
                      & ", local ",FACES_MAPPING%DOMAIN_LIST(LocalInternalFaceIdx),"),  is internal: "

                    ! check if current face is internal or boundary
                    CurrentFaceIsInternal = .FALSE.
                    IF (FaceLocalNo == FACES_MAPPING%DOMAIN_LIST(LocalInternalFaceIdx) &
                      & .AND. LocalInternalFaceIdx <= FACES_MAPPING%INTERNAL_FINISH) THEN
                      CurrentFaceIsInternal = .TRUE.
                      LocalInternalFaceIdx = LocalInternalFaceIdx + 1
                    ENDIF

                    IF (DIAGNOSTICS2) WRITE(*,*) CurrentFaceIsInternal

                    !NumberDerivatives = TOPOLOGY%FACES%FACES(FaceGlobalNo)%numberOfDerivatives
                    NumberDerivatives = 1 !For faces we assume there is only one derivative for now


                    ! allocate parameter to dof map for faces
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(&
                      & NumberDerivatives),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative map for face local "//&
                      & TRIM(NUMBER_TO_VSTRING(FaceLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                    ! loop over dofs for current face, derivatives
                    DO DerivativeIdx=1,NumberDerivatives

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": derivative ", DerivativeIdx, "/", NumberDerivatives

                      NumberVersions = 1 !TOPOLOGY%FACES%FACES(FaceGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions !For faces we assume there is only one version for now

                      ! allocate parameter to dof map for face, derivative, versions
                      ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(DerivativeIdx)%&
                        & VERSIONS(NumberVersions),&
                        & STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative versions map for face local "//&
                        & TRIM(NUMBER_TO_VSTRING(FaceLocalNo,"*",ERR,ERROR))//", derivative index "//&
                        & TRIM(NUMBER_TO_VSTRING(DerivativeIdx,"*",ERR,ERROR)),ERR,ERROR,*999)

                      DO VersionIdx=1,NumberVersions

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": version ", VersionIdx, "/", NumberVersions

                        ! add global dof no to LOCAL_TO_GLOBAL_MAP
                        FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

                        ! if internal face, add dof index to DOMAIN_LIST
                        IF (CurrentFaceIsInternal) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                          InternalDofIdx = InternalDofIdx + 1
                        ELSE
                          ! if face is not internal, save boundary dofs
                          CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, CurrentDofLocalNo, ERR, ERROR, *999)
                        ENDIF

                        IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    d",DerivativeIdx,"v",VersionIdx,&
                          & "dof idx ",InternalDofIdx-1,", local",CurrentDofLocalNo,", global",CurrentDofGlobalNo

                        ! setup dof to parameter map
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_FACE_DOF_TYPE
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=faceDofIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(1,faceDofIdx)=VersionIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(2,faceDofIdx)=DerivativeIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(3,faceDofIdx)=FaceLocalNo
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(4,faceDofIdx)=component_idx
                        faceDofIdx = faceDofIdx + 1   ! this is the index when iterating over all face dofs of this field variable

                        ! setup reverse parameter to dof map
                        FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(DerivativeIdx)% &
                          & VERSIONS(VersionIdx) = CurrentDofLocalNo

                        !IF (DIAGNOSTICS2) PRINT "(4(I0,A),I0)", MyComputationalNodeNumber, ": set dof(",FaceLocalNo,",",&
                        !  & DerivativeIdx, &
                        !  & ",",VersionIdx,")=",CurrentDofLocalNo

                        ! set NUMBER_OF_SEND_GHOSTS

                        ! find out on which domains (if any) the corresponding ghost faces reside from faces mapping
                        ! loop over the adjacent domains of the faces mapping which are the same as for the dofs mapping
                        DO AdjacentDomainIdx = 1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                          FaceIsOnCurrentAdjacentDomain = .FALSE.
                          ! check if face is a ghost on the adjacent domain with index AdjacentDomainIdx

                          ! loop over send ghost local numbers
                          DO GhostSendIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                            ! if face was found on adjacent domain AdjacentDomainIdx
                            IF (FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                              & == FaceLocalNo) THEN
                              FaceIsOnCurrentAdjacentDomain = .TRUE.
                              EXIT
                            ENDIF
                          ENDDO

                          ! if the current face is on the current adjacent domain as ghost face
                          IF (FaceIsOnCurrentAdjacentDomain) THEN

                            ! add current dof to LOCAL_GHOST_SEND_INDICES
                            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS &
                              = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS + 1

                            ! add CurrentDofLocalNo to LOCAL_GHOST_SEND_INDICES
                            IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                              ! array does not yet exist, allocate with size 1
                              ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)% &
                                & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                              IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                              FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(1) &
                                & = CurrentDofLocalNo
                            ELSE
                              ! array already exists, increase size by 1
                              FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                                & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES, &
                                & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS], &
                                & [CurrentDofLocalNo])
                            ENDIF

                          ENDIF
                        ENDDO  ! AdjacentDomainIdx

                        ! advance local and global dof no
                        CurrentDofLocalNo = CurrentDofLocalNo + 1
                        CurrentDofGlobalNo = CurrentDofGlobalNo + 1
                      ENDDO  ! VersionIdx
                    ENDDO  ! DerivativeIdx

                    FaceLocalNo = FaceLocalNo + 1

                    IF (FaceGlobalNo == FaceStopGlobalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": Face global ", FaceGlobalNo, " is stop face, exit"
                      EXIT
                    ENDIF
                  ENDDO   ! loop over faces in break-free sequence
                ELSE
                  ! face range is not on own rank

                  ! advance global dof no by number of dofs on foreign rank
                  CurrentDofGlobalNo = CurrentDofGlobalNo + NumberDofsCurrentSequence
                ENDIF

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": FaceStopGlobalNo=",FaceStopGlobalNo,&
                  & ", end:",FACES_MAPPING%NUMBER_OF_GLOBAL
                IF (FaceStopGlobalNo == FACES_MAPPING%NUMBER_OF_GLOBAL) EXIT

                ! advance start and stop face to next sequence
                FaceStartGlobalNo = FaceStopGlobalNo+1
                FaceStopGlobalNo = -1     ! unknown

              ENDDO   ! loop over break-free sequences

              IF(ALLOCATED(DofTable)) DEALLOCATE(DofTable)

            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)

              !This is the same as for element_based_interpolation, another loop over component_idx is done after this loop to include external face dofs

              Element1LocalNo = 1
              FirstDofLocalNo(component_idx) = CurrentDofLocalNo

              Element1GlobalNo(component_idx) = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(Element1LocalNo)
              FirstDofGlobalNo(component_idx) = CurrentDofGlobalNo

              FirstElementDofIdx(component_idx) = CurrentElementDofIdx

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": component ", component_idx, ", Element1GlobalNo: ", &
                & Element1GlobalNo(component_idx), ", FirstDofGlobalNo: ", FirstDofGlobalNo(component_idx)

              ! loop over interior and boundary elements
              DO ElementIdx = ELEMENTS_MAPPING%INTERNAL_START,ELEMENTS_MAPPING%BOUNDARY_FINISH
                ElementLocalNo = ELEMENTS_MAPPING%DOMAIN_LIST(ElementIdx)
                ElementGlobalNo = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(ElementLocalNo)

                ! compute the dof global no from the element global no
                DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - 1
                !DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - Element1GlobalNo(component_idx)
                DofLocalNo = FirstDofLocalNo(component_idx) + ElementLocalNo - Element1LocalNo
                ElementDofIdx = FirstElementDofIdx(component_idx) + ElementLocalNo - Element1LocalNo

                ! add global dof no to LOCAL_TO_GLOBAL_MAP
                FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo

                CurrentElementIsInternal = ElementIdx <= ELEMENTS_MAPPING%INTERNAL_FINISH

                ! if internal element, add dof index to DOMAIN_LIST
                IF (CurrentElementIsInternal) THEN
                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = DofLocalNo
                  InternalDofIdx = InternalDofIdx + 1
                ELSE
                  ! if element is not internal, save boundary dofs
                  CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, DofLocalNo, ERR, ERROR, *999)
                ENDIF

                IF (DIAGNOSTICS2) THEN
                  PRINT *, MyComputationalNodeNumber, ":    element idx ",ElementIdx," local ",ElementLocalNo, &
                    & " global ",ElementGlobalNo,", dof idx ",InternalDofIdx-1, &
                    & ", local",DofLocalNo,", global",DofGlobalNo
                  PRINT *, MyComputationalNodeNumber, ":    ElementDofIdx=",ElementDofIdx," (first: ", &
                    & FirstElementDofIdx(component_idx),")"
                ENDIF

                ! setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_ELEMENT_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=ElementDofIdx
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,ElementDofIdx)=ElementLocalNo
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,ElementDofIdx)=component_idx
                CurrentElementDofIdx = CurrentElementDofIdx + 1   ! counter of number of ElementDofIdx used

                ! setup reverse parameter to dof map
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ElementLocalNo) = &
                  & DofLocalNo

                ! set NUMBER_OF_SEND_GHOSTS

                ! find out on which domains (if any) the corresponding ghost elements reside from elements mapping
                ! loop over the adjacent domains of the elements mapping which are the same as for the dofs mapping
                DO AdjacentDomainIdx = 1,ELEMENTS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ElementIsOnCurrentAdjacentDomain = .FALSE.
                  ! check if element is a ghost on the adjacent domain with index AdjacentDomainIdx

                  ! loop over send ghost local numbers
                  DO GhostSendIdx = 1,ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    ! if element was found on adjacent domain AdjacentDomainIdx
                    IF (ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                      & == ElementLocalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    adjacent domain idx ", AdjacentDomainIdx,&
                        & " no ", ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                        & " is send current element, add SEND_GHOST"

                      AdjacentDomainNo = ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                      ElementIsOnCurrentAdjacentDomain = .TRUE.
                      EXIT
                    ENDIF
                  ENDDO

                  ! if the current element is on the current adjacent domain as ghost element
                  IF (ElementIsOnCurrentAdjacentDomain) THEN

                    ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                    DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                        EXIT
                      ENDIF
                    ENDDO

                    ! add current dof to LOCAL_GHOST_SEND_INDICES
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS &
                      = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS + 1

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    add local dof no",DofLocalNo, &
                      & " to ADJACENT_DOMAINS(",AdjacentDomainIdx2,") (domain ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx2)%DOMAIN_NUMBER,"), now has ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS &
                      & (AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS," SEND_GHOSTS"

                    ! add DofLocalNo to LOCAL_GHOST_SEND_INDICES
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                      ! array does not yet exist, allocate with size 1
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)% &
                        & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES(1) &
                        & = DofLocalNo
                    ELSE
                      ! array already exists, increase size by 1
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                        & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES, &
                        & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS], &
                        & [DofLocalNo])
                    ENDIF

                  ENDIF
                ENDDO  ! AdjacentDomainIdx

                ! advance local dof no, this is not the dof local no counter that is used but it is increased the right number of times
                CurrentDofLocalNo = CurrentDofLocalNo + 1


              ENDDO ! ElementIdx
              CurrentDofGlobalNo = CurrentDofGlobalNo + ELEMENTS_MAPPING%NUMBER_OF_GLOBAL
            CASE(FIELD_LINE_BASED_INTERPOLATION)
              ! Count number of 'breaks' in contiguous global line numbering on current domain. A break is when there
              ! is a jump in the global line number for successive local line numbers.
              LocalNumberBreaks = 0
              PreviousLineGlobalNo = -1

              ! loop over internal and boundary lines
              DO LineLocalNo = 1,LINES_MAPPING%NUMBER_OF_LOCAL
                LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                ! if there is a jump in global line no. count break
                IF (LineGlobalNo /= PreviousLineGlobalNo+1 .AND. PreviousLineGlobalNo /= -1) THEN
                  LocalNumberBreaks = LocalNumberBreaks + 1
                ENDIF
                PreviousLineGlobalNo = LineGlobalNo
              ENDDO
              ! add last line also as break
              LocalNumberBreaks = LocalNumberBreaks + 1

              ! exchange the number of breaks on every rank
              ! merge information from every rank
              NumberBreaksLine(MyComputationalNodeNumber) = LocalNumberBreaks
              CALL MPI_ALLGATHER(MPI_IN_PLACE,1,MPI_INTEGER, &
                & NumberBreaksLine,1,MPI_INTEGER,computationalEnvironment%mpiCommunicator,MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLGATHER",MPI_IERROR,ERR,ERROR,*999)

              IF (DIAGNOSTICS2) THEN
                PRINT *, MyComputationalNodeNumber, " ------------------------------------ "
                PRINT *, MyComputationalNodeNumber, ": component ", component_idx, ", number breaks: ",NumberBreaksLine
              ENDIF

              ! DofTable
              !                         1 break: 2 values
              !        break no. ->     /--^-\
              ! rank   (glob.line,dof)  (4,13) (12,24) ...
              !  |
              !  v
              ! ---------------------------
              ! explanation of the triple values:
              !    global line: the last global line no. that is on the rank before the break
              !    dof: number of dofs in last break-free sequence
              !
              ! the table is laid out row-major as a 1D array where each row has NumberBreaksLine(rank) entries

              ! compute the row offsets, i.e. the indices where each row starts
              RowOffsetLine(0) = 1
              DO I = 1,NumberComputationalNodes-1
                RowOffsetLine(I) = RowOffsetLine(I-1) + NumberBreaksLine(I-1)*2
              ENDDO

              ! compute global number of breaks as sum over all LocalNumberBreaks
              GlobalNumberBreaks = 0
              DO I = 0,NumberComputationalNodes-1
                GlobalNumberBreaks = GlobalNumberBreaks + NumberBreaksLine(I)
              ENDDO

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": RowOffsetLine: ", RowOffsetLine, &
                & ", GlobalNumberBreaks=", GlobalNumberBreaks

              ! allocate lookup table
              ALLOCATE(DofTable(GlobalNumberBreaks*2),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate DofTable of size "//&
                & TRIM(NUMBER_TO_VSTRING(GlobalNumberBreaks*2,"*",ERR,ERROR))//".",ERR,ERROR,*999)

              ! reset row that belongs to own rank to 0
              DofTable(RowOffsetLine(MyComputationalNodeNumber):RowOffsetLine(MyComputationalNodeNumber)+LocalNumberBreaks) = 0

              ! fill table with own values
              BreakIdx = 0
              NumberDofsInSequence = 0
              PreviousLineGlobalNo = -1

              ! loop over internal and boundary lines
              DO LineLocalNo = 1,LINES_MAPPING%NUMBER_OF_LOCAL
                LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": line global ",LineGlobalNo

                ! if there is a jump in global line no. count break
                IF (LineGlobalNo /= PreviousLineGlobalNo+1 .AND. PreviousLineGlobalNo /= -1) THEN

                  DofTableIndex = RowOffsetLine(MyComputationalNodeNumber) + BreakIdx*2
                  BreakIdx = BreakIdx + 1

                  ! set first entry of pair in lookup table: global line no. end
                  DofTable(DofTableIndex+0) = PreviousLineGlobalNo

                  ! set second entry of pair in lookup table: number of dofs in break-free sequence
                  DofTable(DofTableIndex+1) = NumberDofsInSequence


                  !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": jump, (",PreviousLineGlobalNo,NumberDofsInSequence,")"

                  ! reset dof counter
                  NumberDofsInSequence = 0
                ENDIF

                !! advance local dof no by number of dofs on current line
                !DO DerivativeIdx=1,TOPOLOGY%LINES%LINES(LineGlobalNo)%numberOfDerivatives
                !  NumberDofsInSequence = NumberDofsInSequence + &
                !    & TOPOLOGY%LINES%LINES(LineGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions
                !ENDDO
                NumberDofsInSequence = NumberDofsInSequence + 1 !Currently lines don't have derivatives so only one dof on line

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberDofsInSequence: ", NumberDofsInSequence
                PreviousLineGlobalNo = LineGlobalNo

              ENDDO   ! LineLocalNo

              ! add last line also as break
              DofTableIndex = RowOffsetLine(MyComputationalNodeNumber) + BreakIdx*2
              DofTable(DofTableIndex+0) = PreviousLineGlobalNo
              DofTable(DofTableIndex+1) = NumberDofsInSequence

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": last: (",PreviousLineGlobalNo,NumberDofsInSequence,")"

              ! create auxiliary arrays for allgatherv
              NumberBreaksDoubleLine = 2*NumberBreaksLine
              RowOffsetZeroBasedLine = RowOffsetLine-1

              !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberBreaksDoubleLine:",NumberBreaksDoubleLine, &
              !  & ", RowOffsetLine:",RowOffsetLine, ", RowOffsetZeroBasedLine:",RowOffsetZeroBasedLine
              !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": pre DofTable:",DofTable

              ! merge information from every rank
              CALL MPI_ALLGATHERV(MPI_IN_PLACE,0,MPI_INTEGER, &
                & DofTable,NumberBreaksDoubleLine,RowOffsetZeroBasedLine,MPI_INTEGER,computationalEnvironment%mpiCommunicator,  &
                  & MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLGATHERV",MPI_IERROR,ERR,ERROR,*999)

              IF (DIAGNOSTICS2) THEN
                PRINT *, MyComputationalNodeNumber, ": DofTable: "
                DO I = 0,NumberComputationalNodes-1
                  WRITE (*,'(2(I0,A))',ADVANCE='NO') MyComputationalNodeNumber, ": rank ",I," "
                  DO BreakIdx=0,NumberBreaksLine(I)-1
                    WRITE (*,'(2(A,I0),A)',ADVANCE='NO') "(",DofTable(RowOffsetLine(I)+BreakIdx*2), &
                      & ",",DofTable(RowOffsetLine(I)+BreakIdx*2+1),")"
                  ENDDO
                  PRINT *, ""
                ENDDO
              ENDIF

              !        break no. ->
              ! rank   (glob.line,dof)  (4,13) (12,24) ...
              !  |
              !  v
              ! find out global dof no. of first local dof
              LineLocalNo = 1
              LocalInternalLineIdx = 1

              CurrentRank = 0
              LineStartGlobalNo = 1
              LineStopGlobalNo = -1
              NumberDofsCurrentSequence = 0
              LocalLineIdx = LINES_MAPPING%INTERNAL_START

              ! loop over all break-free sequences
              DO

                ! determine rank that has the lowest global line no. above the current start line
                ! loop over ranks
                DO I = 0,NumberComputationalNodes-1
                  ! determine the first global no. above the current on rank I (LineOnCurrentComputationalNodeGlobalNo)
                  LineOnCurrentComputationalNodeGlobalNo = 0
                  NumberDofsOnCurrentComputationalNode = 0

                  ! loop over breaks
                  DO BreakIdx = 0,NumberBreaksLine(I)-1

                    ! get global number of break
                    LineGlobalNo = DofTable(RowOffsetLine(I)+BreakIdx*2)
                    NumberDofs = DofTable(RowOffsetLine(I)+BreakIdx*2+1)

                    ! store it if it is the first after start line
                    IF (LineGlobalNo >= LineStartGlobalNo) THEN
                      LineOnCurrentComputationalNodeGlobalNo = LineGlobalNo
                      NumberDofsOnCurrentComputationalNode = NumberDofs
                      EXIT
                    ENDIF
                  ENDDO

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":   rank ", I, &
                    & ", line global ", LineOnCurrentComputationalNodeGlobalNo, ", ndofs: ", NumberDofsOnCurrentComputationalNode

                  ! if a line was found on rank I
                  IF (LineOnCurrentComputationalNodeGlobalNo /= 0) THEN
                    ! store LineOnCurrentComputationalNodeGlobalNo if it is the lowest line so far
                    IF (LineStopGlobalNo == -1 .OR. LineOnCurrentComputationalNodeGlobalNo < LineStopGlobalNo) THEN
                      LineStopGlobalNo = LineOnCurrentComputationalNodeGlobalNo
                      CurrentRank = I
                      NumberDofsCurrentSequence = NumberDofsOnCurrentComputationalNode
                    ENDIF
                  ENDIF
                ENDDO  ! I


                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": range [", LineStartGlobalNo, ",", LineStopGlobalNo, "]", &
                    & " on rank", CurrentRank


                ! the current range of lines [LineStartGlobalNo,LineStopGlobalNo] is on rank CurrentRank
                ! and has number of dofs NumberDofsCurrentSequence, starting from CurrentDofGlobalNo

                ! add up dof no.s
                IF (CurrentRank == MyComputationalNodeNumber) THEN
                  ! loop over lines of current break-free sequences
                  DO
                    LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                    IF (DIAGNOSTICS2) WRITE(*,'(5(I0,A))',ADVANCE='no') MyComputationalNodeNumber, ": on this rank, line global ", &
                      & LineGlobalNo,", local ",LineLocalNo,", (line idx",LocalInternalLineIdx,&
                      & ", local ",LINES_MAPPING%DOMAIN_LIST(LocalInternalLineIdx),"),  is internal: "

                    ! check if current line is internal or boundary
                    CurrentLineIsInternal = .FALSE.
                    IF (LineLocalNo == LINES_MAPPING%DOMAIN_LIST(LocalInternalLineIdx) &
                      & .AND. LocalInternalLineIdx <= LINES_MAPPING%INTERNAL_FINISH) THEN
                      CurrentLineIsInternal = .TRUE.
                      LocalInternalLineIdx = LocalInternalLineIdx + 1
                    ENDIF

                    IF (DIAGNOSTICS2) WRITE(*,*) CurrentLineIsInternal

                    !NumberDerivatives = TOPOLOGY%LINES%LINES(LineGlobalNo)%numberOfDerivatives
                    NumberDerivatives = 1 !For lines we assume there is only one derivative for now


                    ! allocate parameter to dof map for lines
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(&
                      & NumberDerivatives),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative map for line local "//&
                      & TRIM(NUMBER_TO_VSTRING(LineLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                    ! loop over dofs for current line, derivatives
                    DO DerivativeIdx=1,NumberDerivatives

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": derivative ", DerivativeIdx, "/", NumberDerivatives

                      NumberVersions = 1 !TOPOLOGY%LINES%LINES(LineGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions !For lines we assume there is only one version for now

                      ! allocate parameter to dof map for line, derivative, versions
                      ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(DerivativeIdx)%&
                        & VERSIONS(NumberVersions),&
                        & STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative versions map for line local "//&
                        & TRIM(NUMBER_TO_VSTRING(LineLocalNo,"*",ERR,ERROR))//", derivative index "//&
                        & TRIM(NUMBER_TO_VSTRING(DerivativeIdx,"*",ERR,ERROR)),ERR,ERROR,*999)

                      DO VersionIdx=1,NumberVersions

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": version ", VersionIdx, "/", NumberVersions

                        ! add global dof no to LOCAL_TO_GLOBAL_MAP
                        FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

                        ! if internal line, add dof index to DOMAIN_LIST
                        IF (CurrentLineIsInternal) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                          InternalDofIdx = InternalDofIdx + 1
                        ELSE
                          ! if line is not internal, save boundary dofs
                          CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, CurrentDofLocalNo, ERR, ERROR, *999)
                        ENDIF

                        IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    d",DerivativeIdx,"v",VersionIdx,&
                          & "dof idx ",InternalDofIdx-1,", local",CurrentDofLocalNo,", global",CurrentDofGlobalNo

                        ! setup dof to parameter map
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_LINE_DOF_TYPE
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=lineDofIdx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(1,lineDofIdx)=LineLocalNo
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(2,lineDofIdx)=component_idx
                        lineDofIdx = lineDofIdx + 1   ! this is the index when iterating over all line dofs of this field variable

                        ! setup reverse parameter to dof map
                        FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(DerivativeIdx)% &
                          & VERSIONS(VersionIdx) = CurrentDofLocalNo

                        !IF (DIAGNOSTICS2) PRINT "(4(I0,A),I0)", MyComputationalNodeNumber, ": set dof(",LineLocalNo,",",&
                        !  & DerivativeIdx, &
                        !  & ",",VersionIdx,")=",CurrentDofLocalNo

                        ! set NUMBER_OF_SEND_GHOSTS

                        ! find out on which domains (if any) the corresponding ghost lines reside from lines mapping
                        ! loop over the adjacent domains of the lines mapping which are the same as for the dofs mapping
                        DO AdjacentDomainIdx = 1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                          LineIsOnCurrentAdjacentDomain = .FALSE.
                          ! check if line is a ghost on the adjacent domain with index AdjacentDomainIdx

                          ! loop over send ghost local numbers
                          DO GhostSendIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                            ! if line was found on adjacent domain AdjacentDomainIdx
                            IF (LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                              & == LineLocalNo) THEN
                              LineIsOnCurrentAdjacentDomain = .TRUE.
                              EXIT
                            ENDIF
                          ENDDO

                          ! if the current line is on the current adjacent domain as ghost line
                          IF (LineIsOnCurrentAdjacentDomain) THEN

                            ! add current dof to LOCAL_GHOST_SEND_INDICES
                            FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS &
                              = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS + 1

                            ! add CurrentDofLocalNo to LOCAL_GHOST_SEND_INDICES
                            IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                              ! array does not yet exist, allocate with size 1
                              ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)% &
                                & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                              IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                              FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(1) &
                                & = CurrentDofLocalNo
                            ELSE
                              ! array already exists, increase size by 1
                              FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                                & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES, &
                                & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS], &
                                & [CurrentDofLocalNo])
                            ENDIF

                          ENDIF
                        ENDDO  ! AdjacentDomainIdx

                        ! advance local and global dof no
                        CurrentDofLocalNo = CurrentDofLocalNo + 1
                        CurrentDofGlobalNo = CurrentDofGlobalNo + 1
                      ENDDO  ! VersionIdx
                    ENDDO  ! DerivativeIdx

                    LineLocalNo = LineLocalNo + 1

                    IF (LineGlobalNo == LineStopGlobalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": Line global ", LineGlobalNo, " is stop line, exit"
                      EXIT
                    ENDIF
                  ENDDO   ! loop over lines in break-free sequence
                ELSE
                  ! line range is not on own rank

                  ! advance global dof no by number of dofs on foreign rank
                  CurrentDofGlobalNo = CurrentDofGlobalNo + NumberDofsCurrentSequence
                ENDIF

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": LineStopGlobalNo=",LineStopGlobalNo,&
                  & ", end:",LINES_MAPPING%NUMBER_OF_GLOBAL
                IF (LineStopGlobalNo == LINES_MAPPING%NUMBER_OF_GLOBAL) EXIT

                ! advance start and stop line to next sequence
                LineStartGlobalNo = LineStopGlobalNo+1
                LineStopGlobalNo = -1     ! unknown

              ENDDO   ! loop over break-free sequences

              IF(ALLOCATED(DofTable)) DEALLOCATE(DofTable)
            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)

              !This is the same as for element_based_interpolation, another loop over component_idx is done after this loop to include external line dofs

              Element1LocalNo = 1
              FirstDofLocalNo(component_idx) = CurrentDofLocalNo

              Element1GlobalNo(component_idx) = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(Element1LocalNo)
              FirstDofGlobalNo(component_idx) = CurrentDofGlobalNo

              FirstElementDofIdx(component_idx) = CurrentElementDofIdx

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": component ", component_idx, ", Element1GlobalNo: ", &
                & Element1GlobalNo(component_idx), ", FirstDofGlobalNo: ", FirstDofGlobalNo(component_idx)

              ! loop over interior and boundary elements
              DO ElementIdx = ELEMENTS_MAPPING%INTERNAL_START,ELEMENTS_MAPPING%BOUNDARY_FINISH
                ElementLocalNo = ELEMENTS_MAPPING%DOMAIN_LIST(ElementIdx)
                ElementGlobalNo = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(ElementLocalNo)

                ! compute the dof global no from the element global no
                DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - 1
                !DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - Element1GlobalNo(component_idx)
                DofLocalNo = FirstDofLocalNo(component_idx) + ElementLocalNo - Element1LocalNo
                ElementDofIdx = FirstElementDofIdx(component_idx) + ElementLocalNo - Element1LocalNo

                ! add global dof no to LOCAL_TO_GLOBAL_MAP
                FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo

                CurrentElementIsInternal = ElementIdx <= ELEMENTS_MAPPING%INTERNAL_FINISH

                ! if internal element, add dof index to DOMAIN_LIST
                IF (CurrentElementIsInternal) THEN
                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = DofLocalNo
                  InternalDofIdx = InternalDofIdx + 1
                ELSE
                  ! if element is not internal, save boundary dofs
                  CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, DofLocalNo, ERR, ERROR, *999)
                ENDIF

                IF (DIAGNOSTICS2) THEN
                  PRINT *, MyComputationalNodeNumber, ":    element idx ",ElementIdx," local ",ElementLocalNo, &
                    & " global ",ElementGlobalNo,", dof idx ",InternalDofIdx-1, &
                    & ", local",DofLocalNo,", global",DofGlobalNo
                  PRINT *, MyComputationalNodeNumber, ":    ElementDofIdx=",ElementDofIdx," (first: ", &
                    & FirstElementDofIdx(component_idx),")"
                ENDIF

                ! setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_ELEMENT_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=ElementDofIdx
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,ElementDofIdx)=ElementLocalNo
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,ElementDofIdx)=component_idx
                CurrentElementDofIdx = CurrentElementDofIdx + 1   ! counter of number of ElementDofIdx used

                ! setup reverse parameter to dof map
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ElementLocalNo) = &
                  & DofLocalNo

                ! set NUMBER_OF_SEND_GHOSTS

                ! find out on which domains (if any) the corresponding ghost elements reside from elements mapping
                ! loop over the adjacent domains of the elements mapping which are the same as for the dofs mapping
                DO AdjacentDomainIdx = 1,ELEMENTS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ElementIsOnCurrentAdjacentDomain = .FALSE.
                  ! check if element is a ghost on the adjacent domain with index AdjacentDomainIdx

                  ! loop over send ghost local numbers
                  DO GhostSendIdx = 1,ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    ! if element was found on adjacent domain AdjacentDomainIdx
                    IF (ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                      & == ElementLocalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    adjacent domain idx ", AdjacentDomainIdx,&
                        & " no ", ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                        & " is send current element, add SEND_GHOST"

                      AdjacentDomainNo = ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                      ElementIsOnCurrentAdjacentDomain = .TRUE.
                      EXIT
                    ENDIF
                  ENDDO

                  ! if the current element is on the current adjacent domain as ghost element
                  IF (ElementIsOnCurrentAdjacentDomain) THEN

                    ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                    DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                        EXIT
                      ENDIF
                    ENDDO

                    ! add current dof to LOCAL_GHOST_SEND_INDICES
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS &
                      = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS + 1

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    add local dof no",DofLocalNo, &
                      & " to ADJACENT_DOMAINS(",AdjacentDomainIdx2,") (domain ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx2)%DOMAIN_NUMBER,"), now has ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS &
                      & (AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS," SEND_GHOSTS"

                    ! add DofLocalNo to LOCAL_GHOST_SEND_INDICES
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                      ! array does not yet exist, allocate with size 1
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)% &
                        & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES(1) &
                        & = DofLocalNo
                    ELSE
                      ! array already exists, increase size by 1
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                        & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES, &
                        & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS], &
                        & [DofLocalNo])
                    ENDIF

                  ENDIF
                ENDDO  ! AdjacentDomainIdx

                ! advance local dof no, this is not the dof local no counter that is used but it is increased the right number of times
                CurrentDofLocalNo = CurrentDofLocalNo + 1


              ENDDO ! ElementIdx
              CurrentDofGlobalNo = CurrentDofGlobalNo + ELEMENTS_MAPPING%NUMBER_OF_GLOBAL
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)

              Element1LocalNo = 1
              FirstDofLocalNo(component_idx) = CurrentDofLocalNo

              Element1GlobalNo(component_idx) = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(Element1LocalNo)
              FirstDofGlobalNo(component_idx) = CurrentDofGlobalNo

              FirstElementDofIdx(component_idx) = CurrentElementDofIdx

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": component ", component_idx, ", Element1GlobalNo: ", &
                & Element1GlobalNo(component_idx), ", FirstDofGlobalNo: ", FirstDofGlobalNo(component_idx)

              ! loop over interior and boundary elements
              DO ElementIdx = ELEMENTS_MAPPING%INTERNAL_START,ELEMENTS_MAPPING%BOUNDARY_FINISH
                ElementLocalNo = ELEMENTS_MAPPING%DOMAIN_LIST(ElementIdx)
                ElementGlobalNo = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(ElementLocalNo)

                ! compute the dof global no from the element global no
                DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - 1
                !DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - Element1GlobalNo(component_idx)
                DofLocalNo = FirstDofLocalNo(component_idx) + ElementLocalNo - Element1LocalNo
                ElementDofIdx = FirstElementDofIdx(component_idx) + ElementLocalNo - Element1LocalNo

                ! add global dof no to LOCAL_TO_GLOBAL_MAP
                FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo

                CurrentElementIsInternal = ElementIdx <= ELEMENTS_MAPPING%INTERNAL_FINISH

                ! if internal element, add dof index to DOMAIN_LIST
                IF (CurrentElementIsInternal) THEN
                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = DofLocalNo
                  InternalDofIdx = InternalDofIdx + 1
                ELSE
                  ! if element is not internal, save boundary dofs
                  CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, DofLocalNo, ERR, ERROR, *999)
                ENDIF

                IF (DIAGNOSTICS2) THEN
                  PRINT *, MyComputationalNodeNumber, ":    element idx ",ElementIdx," local ",ElementLocalNo, &
                    & " global ",ElementGlobalNo,", dof idx ",InternalDofIdx-1, &
                    & ", local",DofLocalNo,", global",DofGlobalNo
                  PRINT *, MyComputationalNodeNumber, ":    ElementDofIdx=",ElementDofIdx," (first: ", &
                    & FirstElementDofIdx(component_idx),")"
                ENDIF

                ! setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_ELEMENT_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=ElementDofIdx
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,ElementDofIdx)=ElementLocalNo
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,ElementDofIdx)=component_idx
                CurrentElementDofIdx = CurrentElementDofIdx + 1   ! counter of number of ElementDofIdx used

                ! setup reverse parameter to dof map
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ElementLocalNo) = DofLocalNo

                ! set NUMBER_OF_SEND_GHOSTS

                ! find out on which domains (if any) the corresponding ghost elements reside from elements mapping
                ! loop over the adjacent domains of the elements mapping which are the same as for the dofs mapping
                DO AdjacentDomainIdx = 1,ELEMENTS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ElementIsOnCurrentAdjacentDomain = .FALSE.
                  ! check if element is a ghost on the adjacent domain with index AdjacentDomainIdx

                  ! loop over send ghost local numbers
                  DO GhostSendIdx = 1,ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    ! if element was found on adjacent domain AdjacentDomainIdx
                    IF (ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                      & == ElementLocalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    adjacent domain idx ", AdjacentDomainIdx,&
                        & " no ", ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                        & " is send current element, add SEND_GHOST"

                      AdjacentDomainNo = ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                      ElementIsOnCurrentAdjacentDomain = .TRUE.
                      EXIT
                    ENDIF
                  ENDDO

                  ! if the current element is on the current adjacent domain as ghost element
                  IF (ElementIsOnCurrentAdjacentDomain) THEN

                    ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                    DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                        EXIT
                      ENDIF
                    ENDDO

                    ! add current dof to LOCAL_GHOST_SEND_INDICES
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS &
                      = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS + 1

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    add local dof no",DofLocalNo, &
                      & " to ADJACENT_DOMAINS(",AdjacentDomainIdx2,") (domain ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx2)%DOMAIN_NUMBER,"), now has ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS &
                      & (AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS," SEND_GHOSTS"

                    ! add DofLocalNo to LOCAL_GHOST_SEND_INDICES
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                      ! array does not yet exist, allocate with size 1
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)% &
                        & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES(1) &
                        & = DofLocalNo
                    ELSE
                      ! array already exists, increase size by 1
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                        & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES, &
                        & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS], &
                        & [DofLocalNo])
                    ENDIF

                  ENDIF
                ENDDO  ! AdjacentDomainIdx

                ! advance local dof no, this is not the dof local no counter that is used but it is increased the right number of times
                CurrentDofLocalNo = CurrentDofLocalNo + 1


              ENDDO ! ElementIdx
              CurrentDofGlobalNo = CurrentDofGlobalNo + ELEMENTS_MAPPING%NUMBER_OF_GLOBAL

            ! endif (node-based interpolation)
            CASE(FIELD_CONSTANT_INTERPOLATION)

              ! add global dof no to LOCAL_TO_GLOBAL_MAP
              FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

              ! add dof index to DOMAIN_LIST
              FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
              InternalDofIdx = InternalDofIdx + 1

              IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    constant dof, dof idx ",InternalDofIdx-1, &
                  & ", local",CurrentDofLocalNo,", global",DofGlobalNo

              ! setup dof to parameter map
              FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_CONSTANT_DOF_TYPE
              FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=ConstantDofIdx
              FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(ConstantDofIdx)=component_idx
              ConstantDofIdx = ConstantDofIdx + 1   ! index for CONSTANT_DOF2PARAM_MAP

              ! setup reverse parameter to dof map
              FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP = CurrentDofLocalNo

              CurrentDofLocalNo = CurrentDofLocalNo + 1
              CurrentDofGlobalNo = CurrentDofGlobalNo + 1

            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)

            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)

            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)

            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                & " of variable type  "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT

          ENDDO  ! component_idx

          !Here we loop over components again for faces IF the interpolation type is ELEMENTS_AND_EXT_FACES
          IF(FIELD_COMPONENT%INTERPOLATION_TYPE==FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION) THEN
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
              !TOPOLOGY=>FIELD_COMPONENT%DOMAIN%TOPOLOGY
              domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
              FACES_MAPPING=>domainMappings%FACES




              ! Face1LocalNo = 1
              ! FirstDofLocalNo(component_idx) = CurrentDofLocalNo
              !
              ! Face1GlobalNo(component_idx) = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(Face1LocalNo)
              ! FirstDofGlobalNo(component_idx) = CurrentDofGlobalNo
              !
              ! FirstFaceDofIdx(component_idx) = faceDofIdx

              DofGlobalNo=CurrentDofGlobalNo+globalDofStartNumberFace-2
              DofLocalNo=CurrentDofLocalNo-1




              ! loop over interior and boundary faces
              DO FaceIdx = FACES_MAPPING%INTERNAL_START,FACES_MAPPING%BOUNDARY_FINISH
                FaceLocalNo = FACES_MAPPING%DOMAIN_LIST(FaceIdx)
                FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                !If this face isn't an external face then we exit the do loop.
                IF(.NOT.FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(FaceLocalNo)%BOUNDARY_LINE) CYCLE

                ! compute the dof global no from the face global no
                DofGlobalNo = DofGlobalNo+1
                DofLocalNo = DofLocalNo+1

                ! add global dof no to LOCAL_TO_GLOBAL_MAP
                FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo

                CurrentFaceIsInternal = FaceIdx <= FACES_MAPPING%INTERNAL_FINISH

                ! if internal face, add dof index to DOMAIN_LIST
                IF (CurrentFaceIsInternal) THEN
                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = DofLocalNo
                  InternalDofIdx = InternalDofIdx + 1
                ELSE
                  ! if face is not internal, save boundary dofs
                  CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, DofLocalNo, ERR, ERROR, *999)
                ENDIF

                IF (DIAGNOSTICS2) THEN
                  PRINT *, MyComputationalNodeNumber, ":    face idx ",FaceIdx," local ",FaceLocalNo, &
                    & " global ",FaceGlobalNo,", dof idx ",InternalDofIdx-1, &
                    & ", local",DofLocalNo,", global",DofGlobalNo
                ENDIF

                ! setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_FACE_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=faceDofIdx
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(1,faceDofIdx)=FaceLocalNo
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(2,faceDofIdx)=component_idx


                ! setup reverse parameter to dof map
                !Faces atm have just one derivative and one version
                !When/if Faces have more than one derivative
                NumberDerivatives=1
                NumberVersions=1


                !Not sure if we want this to be componentFaceDofIdx or faceLocalNo, id it is faceLocal Number we would have to allocate a lot more FACES for face_param2dof_map
                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(&
                  & NumberDerivatives),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative map for FaceLocalNo "//&
                  & TRIM(NUMBER_TO_VSTRING(FaceLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)% &
                  & DERIVATIVES(NumberDerivatives)%VERSIONS(NumberVersions),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative versions map for FaceLocalNo"//&
                  & TRIM(NUMBER_TO_VSTRING(FaceLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)



                FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(1)%VERSIONS(1) =  &
                  & DofLocalNo
                faceDofIdx = faceDofIdx + 1   ! counter of number of faceDofIdx used
                ! set NUMBER_OF_SEND_GHOSTS

                ! find out on which domains (if any) the corresponding ghost faces reside from faces mapping
                ! loop over the adjacent domains of the faces mapping which are the same as for the dofs mapping
                DO AdjacentDomainIdx = 1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  FaceIsOnCurrentAdjacentDomain = .FALSE.
                  ! check if face is a ghost on the adjacent domain with index AdjacentDomainIdx

                  ! loop over send ghost local numbers
                  DO GhostSendIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    ! if face was found on adjacent domain AdjacentDomainIdx
                    IF (FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                      & == FaceLocalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    adjacent domain idx ", AdjacentDomainIdx,&
                        & " no ", FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                        & " is send current face, add SEND_GHOST"

                      AdjacentDomainNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                      FaceIsOnCurrentAdjacentDomain = .TRUE.
                      EXIT
                    ENDIF
                  ENDDO

                  ! if the current face is on the current adjacent domain as ghost face
                  IF (FaceIsOnCurrentAdjacentDomain) THEN

                    ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                    DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                        EXIT
                      ENDIF
                    ENDDO

                    ! add current dof to LOCAL_GHOST_SEND_INDICES
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS &
                      = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS + 1

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    add local dof no",DofLocalNo, &
                      & " to ADJACENT_DOMAINS(",AdjacentDomainIdx2,") (domain ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx2)%DOMAIN_NUMBER,"), now has ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS &
                      & (AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS," SEND_GHOSTS"

                    ! add DofLocalNo to LOCAL_GHOST_SEND_INDICES
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                      ! array does not yet exist, allocate with size 1
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)% &
                        & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES(1) &
                        & = DofLocalNo
                    ELSE
                      ! array already exists, increase size by 1
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                        & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES, &
                        & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS], &
                        & [DofLocalNo])
                    ENDIF

                  ENDIF
                ENDDO  ! AdjacentDomainIdx

                ! advance local dof no, this is not the dof local no counter that is used but it is increased the right number of times
                CurrentDofLocalNo = CurrentDofLocalNo + 1


              ENDDO ! FaceIdx
              CurrentDofGlobalNo = CurrentDofGlobalNo + numberOfGlobalExternalFaces


            ENDDO !component_idx

          !Here we loop over components again for lines IF the interpolation type is ELEMENTS_AND_EXT_LINES
          ELSE IF(FIELD_COMPONENT%INTERPOLATION_TYPE==FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION) THEN
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
              !TOPOLOGY=>FIELD_COMPONENT%DOMAIN%TOPOLOGY
              domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
              LINES_MAPPING=>domainMappings%LINES




              ! Line1LocalNo = 1
              ! FirstDofLocalNo(component_idx) = CurrentDofLocalNo
              !
              ! Line1GlobalNo(component_idx) = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(Line1LocalNo)
              ! FirstDofGlobalNo(component_idx) = CurrentDofGlobalNo
              !
              ! FirstLineDofIdx(component_idx) = lineDofIdx

              DofGlobalNo=CurrentDofGlobalNo+globalDofStartNumberLine-2
              DofLocalNo=CurrentDofLocalNo-1




              ! loop over interior and boundary lines
              DO LineIdx = LINES_MAPPING%INTERNAL_START,LINES_MAPPING%BOUNDARY_FINISH
                LineLocalNo = LINES_MAPPING%DOMAIN_LIST(LineIdx)
                LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                !If this line isn't an external line then we exit the do loop.
                IF(.NOT.FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(LineLocalNo)%BOUNDARY_LINE) CYCLE

                ! compute the dof global no from the line global no
                DofGlobalNo = DofGlobalNo+1
                DofLocalNo = DofLocalNo+1

                ! add global dof no to LOCAL_TO_GLOBAL_MAP
                FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo

                CurrentLineIsInternal = LineIdx <= LINES_MAPPING%INTERNAL_FINISH

                ! if internal line, add dof index to DOMAIN_LIST
                IF (CurrentLineIsInternal) THEN
                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = DofLocalNo
                  InternalDofIdx = InternalDofIdx + 1
                ELSE
                  ! if line is not internal, save boundary dofs
                  CALL LIST_ITEM_ADD(BoundaryDofLocalNosList, DofLocalNo, ERR, ERROR, *999)
                ENDIF

                IF (DIAGNOSTICS2) THEN
                  PRINT *, MyComputationalNodeNumber, ":    line idx ",LineIdx," local ",LineLocalNo, &
                    & " global ",LineGlobalNo,", dof idx ",InternalDofIdx-1, &
                    & ", local",DofLocalNo,", global",DofGlobalNo
                ENDIF

                ! setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_LINE_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=lineDofIdx
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(1,lineDofIdx)=LineLocalNo
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(2,lineDofIdx)=component_idx


                ! setup reverse parameter to dof map
                !Lines atm have just one derivative and one version
                !When/if Lines have more than one derivative
                NumberDerivatives=1
                NumberVersions=1


                !Not sure if we want this to be componentLineDofIdx or lineLocalNo, id it is lineLocal Number we would have to allocate a lot more LINES for line_param2dof_map
                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(&
                  & NumberDerivatives),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative map for LineLocalNo "//&
                  & TRIM(NUMBER_TO_VSTRING(LineLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)% &
                  & DERIVATIVES(NumberDerivatives)%VERSIONS(NumberVersions),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative versions map for LineLocalNo"//&
                  & TRIM(NUMBER_TO_VSTRING(LineLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)



                FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(1)%VERSIONS(1) =  &
                  & DofLocalNo
                lineDofIdx = lineDofIdx + 1   ! counter of number of lineDofIdx used
                ! set NUMBER_OF_SEND_GHOSTS

                ! find out on which domains (if any) the corresponding ghost lines reside from lines mapping
                ! loop over the adjacent domains of the lines mapping which are the same as for the dofs mapping
                DO AdjacentDomainIdx = 1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  LineIsOnCurrentAdjacentDomain = .FALSE.
                  ! check if line is a ghost on the adjacent domain with index AdjacentDomainIdx

                  ! loop over send ghost local numbers
                  DO GhostSendIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    ! if line was found on adjacent domain AdjacentDomainIdx
                    IF (LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(GhostSendIdx) &
                      & == LineLocalNo) THEN
                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    adjacent domain idx ", AdjacentDomainIdx,&
                        & " no ", LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                        & " is send current line, add SEND_GHOST"

                      AdjacentDomainNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                      LineIsOnCurrentAdjacentDomain = .TRUE.
                      EXIT
                    ENDIF
                  ENDDO

                  ! if the current line is on the current adjacent domain as ghost line
                  IF (LineIsOnCurrentAdjacentDomain) THEN

                    ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                    DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                        EXIT
                      ENDIF
                    ENDDO

                    ! add current dof to LOCAL_GHOST_SEND_INDICES
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS &
                      = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS + 1

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    add local dof no",DofLocalNo, &
                      & " to ADJACENT_DOMAINS(",AdjacentDomainIdx2,") (domain ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx2)%DOMAIN_NUMBER,"), now has ",FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS &
                      & (AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS," SEND_GHOSTS"

                    ! add DofLocalNo to LOCAL_GHOST_SEND_INDICES
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS == 1) THEN
                      ! array does not yet exist, allocate with size 1
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)% &
                        & LOCAL_GHOST_SEND_INDICES(1),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_SEND_INDICES.",ERR,ERROR,*999)

                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES(1) &
                        & = DofLocalNo
                    ELSE
                      ! array already exists, increase size by 1
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES = RESHAPE(&
                        & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_SEND_INDICES, &
                        & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_SEND_GHOSTS], &
                        & [DofLocalNo])
                    ENDIF

                  ENDIF
                ENDDO  ! AdjacentDomainIdx

                ! advance local dof no, this is not the dof local no counter that is used but it is increased the right number of times
                CurrentDofLocalNo = CurrentDofLocalNo + 1


              ENDDO ! LineIdx
              CurrentDofGlobalNo = CurrentDofGlobalNo + numberOfGlobalExternalLines


            ENDDO !component_idx
          ENDIF




          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_INTERNAL = InternalDofIdx-1
          FIELD_VARIABLE_DOFS_MAPPING%INTERNAL_START=1
          FIELD_VARIABLE_DOFS_MAPPING%INTERNAL_FINISH=InternalDofIdx-1
          FIELD_VARIABLE_DOFS_MAPPING%BOUNDARY_START=InternalDofIdx

          ! add boundary nodes to DOMAIN_LIST
          CALL LIST_DETACH_AND_DESTROY(BoundaryDofLocalNosList,NumberBoundaryDofs,IntegerArray,&
            & ERR,ERROR,*999)

          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_BOUNDARY = NumberBoundaryDofs
          InternalDofIdx = InternalDofIdx + NumberBoundaryDofs
          FIELD_VARIABLE_DOFS_MAPPING%BOUNDARY_FINISH = InternalDofIdx - 1

          FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(FIELD_VARIABLE_DOFS_MAPPING%BOUNDARY_START:&
            & FIELD_VARIABLE_DOFS_MAPPING%BOUNDARY_FINISH) = IntegerArray(1:NumberBoundaryDofs)
          IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": collected ",NumberBoundaryDofs,&
            & "boundary dofs (local no.):", IntegerArray

          IF(ALLOCATED(IntegerArray)) DEALLOCATE(IntegerArray)

          ! set start index in DOMAIN_LIST for ghost dofs
          FIELD_VARIABLE_DOFS_MAPPING%GHOST_START = InternalDofIdx

          ! handle ghost dofs, only if multiple domains
          IF (NumberComputationalNodes /= 1) THEN

            ! loop over components of current field variable
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
              domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
              ELEMENTS_MAPPING=>domainMappings%ELEMENTS
              NODES_MAPPING=>domainMappings%NODES
              FACES_MAPPING=>domainMappings%FACES
              LINES_MAPPING=>domainMappings%LINES

              ! handle ghosts for node based interpolation dofs
              SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
              CASE(FIELD_NODE_BASED_INTERPOLATION)

                ! set ghost dofs, use nodes boundary/ghost information and communicate global dof no.s

                ! determine maximum number of nodes to send and receive for all adjacent domains
                MaximumNumberNodesSend = 0
                MaximumNumberNodesReceive = 0

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                  MaximumNumberNodesSend = MAX(MaximumNumberNodesSend, &
                    & NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS)
                  MaximumNumberNodesReceive = MAX(MaximumNumberNodesReceive, &
                    & NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS)
                ENDDO
                MaximumNumberNodesCommunicate = MAX(MaximumNumberNodesSend,MaximumNumberNodesReceive)

                ! reduce over all processes
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaximumNumberNodesCommunicate,1,MPI_INT,MPI_MAX, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": MaximumNumberNodesSend=",MaximumNumberNodesSend, &
                  & ", MaximumNumberNodesReceive=",MaximumNumberNodesReceive, &
                  & ", MaximumNumberNodesCommunicate=",MaximumNumberNodesCommunicate

                ! allocate send and receive buffers
                ALLOCATE(SendBuffer2(MaximumNumberNodesCommunicate,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer2",ERR,ERROR,*999)

                ALLOCATE(ReceiveBuffer2(MaximumNumberNodesCommunicate,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer2",ERR,ERROR,*999)

                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

                ! exchange number of derivatives
                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO NodeSendIdx = 1,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    NodeLocalNo = NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(NodeSendIdx)
                    NodeGlobalNo = NODES_MAPPING%LOCAL_TO_GLOBAL_MAP(NodeLocalNo)

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send to adj domain ",NODES_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx)%DOMAIN_NUMBER,"idx ", AdjacentDomainIdx, &
                      & " (NodeSendIdx=",NodeSendIdx,"), node global ",NodeGlobalNo,&
                      & ", n derivatives: ",TOPOLOGY%NODES%NODES(NodeGlobalNo)%numberOfDerivatives
                    SendBuffer2(NodeSendIdx,AdjacentDomainIdx) = TOPOLOGY%NODES%NODES(NodeGlobalNo)%numberOfDerivatives
                  ENDDO

                  ! post receive calls
                  CALL MPI_IRECV(ReceiveBuffer2(:,AdjacentDomainIdx),MaximumNumberNodesCommunicate,MPI_INTEGER, &
                    & NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                  ! post send calls
                  CALL MPI_ISEND(SendBuffer2(:,AdjacentDomainIdx),MaximumNumberNodesCommunicate,MPI_INTEGER, &
                    & NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

                ENDDO   ! AdjacentDomainIdx

                ! wait for all communication to finish
                CALL MPI_WAITALL(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                CALL MPI_WAITALL(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                ! deallocate request handles
                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(SendRequestHandle)) DEALLOCATE(SendRequestHandle)

                ! copy received number of derivatives at nodes to unified array, which collects all values for ghost nodes
                FirstGhostNodeLocalNo = NODES_MAPPING%DOMAIN_LIST(NODES_MAPPING%GHOST_START)
                LastGhostNodeLocalNo = NODES_MAPPING%DOMAIN_LIST(NODES_MAPPING%GHOST_FINISH)

                ! allocate array for number of derivatives at every ghost node, index is the local node no.
                ALLOCATE(NumberDerivativesAtGhostNode(FirstGhostNodeLocalNo:LastGhostNodeLocalNo),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate NumberDerivativesAtGhostNode",ERR,ERROR,*999)

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information from receive buffer
                  DO NodeReceiveIdx = 1,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    NodeLocalNo = NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(NodeReceiveIdx)


                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": recv from adj domain ", &
                      & NODES_MAPPING%ADJACENT_DOMAINS( &
                      & AdjacentDomainIdx)%DOMAIN_NUMBER,", idx", AdjacentDomainIdx, &
                      & ", node local ",NodeLocalNo,", n derivatives: ",ReceiveBuffer2(NodeReceiveIdx,AdjacentDomainIdx)

                    ! get entry in receive buffer
                    NumberDerivativesAtGhostNode(NodeLocalNo) = ReceiveBuffer2(NodeReceiveIdx,AdjacentDomainIdx)
                  ENDDO  ! NodeReceiveIdx
                ENDDO   ! AdjacentDomainIdx

                ! find out maximum number of derivatives at a node
                MaxNumberDerivativesAtGhostNode = 0
                DO GhostNodeNo = FirstGhostNodeLocalNo,LastGhostNodeLocalNo
                  MaxNumberDerivativesAtGhostNode = MAX(MaxNumberDerivativesAtGhostNode, NumberDerivativesAtGhostNode(GhostNodeNo))

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberDerivativesAtGhostNode(local ",GhostNodeNo,")=",&
                    & NumberDerivativesAtGhostNode(GhostNodeNo)

                ENDDO  ! GhostNodeNo

                ! reduce over all processes
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaxNumberDerivativesAtGhostNode,1,MPI_INT,MPI_MAX, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)

                ! transfer information that reproduces all global ghost numbers at ghost nodes to the domains where it is a boundary node, each
                ! allocate send and receive buffers
                ALLOCATE(SendBuffer3(0:MaxNumberDerivativesAtGhostNode, MaximumNumberNodesCommunicate,&
                  & NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer",ERR,ERROR,*999)

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": allocate send buffer for ", &
                  & MaxNumberDerivativesAtGhostNode, " derivatives"
                ! SendBuffer(0,NodeSendIdx,AdjacentDomainIdx) = global dof no of first dof at this node
                ! SendBuffer(1:DerivativeIdx,NodeSendIdx,AdjacentDomainIdx) = for each derivative the number of versions

                ALLOCATE(ReceiveBuffer3(0:MaxNumberDerivativesAtGhostNode,MaximumNumberNodesCommunicate,&
                  & NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer",ERR,ERROR,*999)

                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

                ! prepare send buffer and start send commands
                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO NodeSendIdx = 1,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    NodeLocalNo = NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(NodeSendIdx)
                    NodeGlobalNo = NODES_MAPPING%LOCAL_TO_GLOBAL_MAP(NodeLocalNo)

                    DerivativeIdx = 1
                    VersionIdx = 1

                    ! get first dof at this node
                    DofLocalNo = FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)% &
                      & DERIVATIVES(DerivativeIdx)%VERSIONS(VersionIdx)

                    IF (DIAGNOSTICS2) PRINT "(4(I0,A),I0)", MyComputationalNodeNumber, ": node local ",NodeLocalNo, &
                      ", global ",NodeGlobalNo, " first dof at this node local: ", DofLocalNo

                    DofGlobalNo = FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo)

                    IF (DIAGNOSTICS2) PRINT "(5(I0,A),I0)", MyComputationalNodeNumber, ": get dof(",NodeLocalNo,",",DerivativeIdx, &
                      & ",",VersionIdx,")=local ",DofLocalNo, " global ",DofGlobalNo

                    ! store in send buffer
                    SendBuffer3(0,NodeSendIdx,AdjacentDomainIdx) = DofGlobalNo

                    ! fill send buffer with number of versions for each derivative
                    DO DerivativeIdx=1,TOPOLOGY%NODES%NODES(NodeGlobalNo)%numberOfDerivatives
                      NumberVersions = TOPOLOGY%NODES%NODES(NodeGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": node global ",NodeGlobalNo," has ",TOPOLOGY%NODES%&
                      !  & NODES(NodeGlobalNo)%numberOfDerivatives," derivatives, sendbuffer ",AdjacentDomainIdx, &
                      !  & " DerivativeIdx=",DerivativeIdx, &
                      !  & " NumberVersions=",NumberVersions

                      SendBuffer3(DerivativeIdx,NodeSendIdx,AdjacentDomainIdx) = NumberVersions
                    ENDDO  ! DerivativeIdx
                  ENDDO  ! NodeSendIdx

                  !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send buffer to adj idx ", AdjacentDomainIdx,": ", &
                  !  & SendBuffer3(:,:,AdjacentDomainIdx)

                  ! post receive calls
                  CALL MPI_IRECV(ReceiveBuffer3(:,:,AdjacentDomainIdx),MaximumNumberNodesCommunicate* &
                    & (MaxNumberDerivativesAtGhostNode+1), &
                    & MPI_INTEGER,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                  ! post send calls
                  CALL MPI_ISEND(SendBuffer3(:,:,AdjacentDomainIdx),MaximumNumberNodesCommunicate* &
                    & (MaxNumberDerivativesAtGhostNode+1), &
                    & MPI_INTEGER,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

                ENDDO  ! AdjacentDomainIdx

                ! wait for all communication to finish
                CALL MPI_WAITALL(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                CALL MPI_WAITALL(NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                ! deallocate request handles
                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(SendRequestHandle)) DEALLOCATE(SendRequestHandle)

                ! copy received ghost node value sets received from different adjacent domains to unified array, which collects all values for ghost nodes
                ! allocate NodeDofSpecification
                ALLOCATE(NodeDofSpecification(0:MaxNumberDerivativesAtGhostNode,FirstGhostNodeLocalNo:LastGhostNodeLocalNo), &
                 & STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate NodeDofSpecification",ERR,ERROR,*999)
                ! NodeDofSpecification(0,NodeLocalNo) = first dof global no at this node
                ! NodeDofSpecification(1:MaxNumberDerivativesAtGhostNode,NodeLocalNo) = number of versions for derivatives at this node

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,NODES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information from receive buffer
                  DO NodeReceiveIdx = 1,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    NodeLocalNo = NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(NodeReceiveIdx)

                    !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": recv buffer from adj idx ", AdjacentDomainIdx,": ", &
                    !  & ReceiveBuffer3(:,:,AdjacentDomainIdx)

                    ! copy entry in receive buffer to entry of node
                    DO I = 0,MaxNumberDerivativesAtGhostNode
                      NodeDofSpecification(I,NodeLocalNo) = ReceiveBuffer3(I,NodeReceiveIdx,AdjacentDomainIdx)
                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": local node ",NodeLocalNo, &
                      !  & ", I=",I,", NodeReceiveIdx=",NodeReceiveIdx,", value=",NodeDofSpecification(I,NodeLocalNo)
                    ENDDO
                    !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": local node ",NodeLocalNo, &
                    !  & ", received (first dof,n versions): ", NodeDofSpecification(:,NodeLocalNo)


                    ! NodeDofSpecification(0,NodeLocalNo) = first dof global no at this node
                    ! NodeDofSpecification(1:MaxNumberDerivativesAtGhostNode,NodeLocalNo) = number of versions for derivatives at this node

                  ENDDO  ! NodeReceiveIdx
                ENDDO  ! AdjacentDomainIdx

                ! set dof indices at ghost nodes from NodeDofSpecification
                ! loop over ghost nodes
                DO NodeLocalNo = FirstGhostNodeLocalNo,LastGhostNodeLocalNo

                  ! find adjacent domain where current node resides
                  AdjacentDomainIdx = 1
                  AdjacentDomainFound = .FALSE.
                  DO WHILE(.NOT. AdjacentDomainFound)

                    ! check if node is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (NODES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == NodeLocalNo) THEN
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF

                    ENDDO
                    IF (.NOT. AdjacentDomainFound) AdjacentDomainIdx = AdjacentDomainIdx + 1
                  ENDDO  ! DO WHILE

                  ! get dof information for current ghost node
                  StartDofGlobalNo = NodeDofSpecification(0,NodeLocalNo)
                  CurrentDofGlobalNo = StartDofGlobalNo


                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": ghost node local",NodeLocalNo,", start dof global",&
                    & StartDofGlobalNo, ", n versions for ",NumberDerivativesAtGhostNode(NodeLocalNo),"derivatives: ", &
                    & NodeDofSpecification(1:NumberDerivativesAtGhostNode(NodeLocalNo),NodeLocalNo)

                  ! allocate parameter to dof map for nodes
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)%DERIVATIVES(&
                    & NumberDerivativesAtGhostNode(NodeLocalNo)),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate param to dof nodes derivative map.",ERR,ERROR,*999)

                  ! loop over derivatives at ghost node
                  DO DerivativeIdx = 1, NumberDerivativesAtGhostNode(NodeLocalNo)

                    NumberVersions = NodeDofSpecification(DerivativeIdx,NodeLocalNo)

                    ! allocate parameter to dof map for node, derivative, versions
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)%DERIVATIVES(DerivativeIdx)% &
                      & VERSIONS(NumberVersions),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate param to dof nodes derivative map.",ERR,ERROR,*999)

                    ! loop over versions of derivatives
                    DO VersionIdx = 1,NumberVersions

                      ! add global dof no to LOCAL_TO_GLOBAL_MAP
                      FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

                      FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                      InternalDofIdx = InternalDofIdx + 1

                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    dof idx",InternalDofIdx-1,&
                        & ", local",CurrentDofLocalNo,", global",CurrentDofGlobalNo, ", NodeDofIdx=",NodeDofIdx

                      ! setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_NODE_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=NodeDofIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(1,NodeDofIdx)=VersionIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(2,NodeDofIdx)=DerivativeIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(3,NodeDofIdx)=NodeLocalNo
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,NodeDofIdx)=component_idx
                      NodeDofIdx = NodeDofIdx + 1   ! this is the index when iterating over all node dofs of this field variable

                      ! setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(NodeLocalNo)%DERIVATIVES(DerivativeIdx)% &
                        & VERSIONS(VersionIdx) = CurrentDofLocalNo

                      ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS &
                        = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS + 1

                      ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                        ! array does not yet exist, allocate with size 1
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                          & STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                        FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                          & = CurrentDofLocalNo
                      ELSE
                        ! array already exists, increase size by 1
                        FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                          & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES, &
                          & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS], &
                          & [CurrentDofLocalNo])
                      ENDIF

                      CurrentDofLocalNo = CurrentDofLocalNo + 1
                      CurrentDofGlobalNo = CurrentDofGlobalNo + 1

                    ENDDO  ! VersionIdx
                  ENDDO ! DerivativeIdx

                ENDDO  ! NodeLocalNo


                ! deallocate send and receive buffers
                IF(ALLOCATED(NodeDofSpecification)) DEALLOCATE(NodeDofSpecification)
                IF(ALLOCATED(SendBuffer2)) DEALLOCATE(SendBuffer2)
                IF(ALLOCATED(ReceiveBuffer2)) DEALLOCATE(ReceiveBuffer2)

                IF(ALLOCATED(SendBuffer3)) DEALLOCATE(SendBuffer3)
                IF(ALLOCATED(ReceiveBuffer3)) DEALLOCATE(ReceiveBuffer3)
                IF(ALLOCATED(NumberDerivativesAtGhostNode)) DEALLOCATE(NumberDerivativesAtGhostNode)

              CASE(FIELD_FACE_BASED_INTERPOLATION)

                ! set ghost dofs, use faces boundary/ghost information and communicate global dof no.s

                ! determine maximum number of faces to send and receive for all adjacent domains
                MaximumNumberFacesSend = 0
                MaximumNumberFacesReceive = 0

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                  MaximumNumberFacesSend = MAX(MaximumNumberFacesSend, &
                    & FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS)
                  MaximumNumberFacesReceive = MAX(MaximumNumberFacesReceive, &
                    & FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS)
                ENDDO
                MaximumNumberFacesCommunicate = MAX(MaximumNumberFacesSend,MaximumNumberFacesReceive)

                ! reduce over all processes
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaximumNumberFacesCommunicate,1,MPI_INT,MPI_MAX, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": MaximumNumberFacesSend=",MaximumNumberFacesSend, &
                  & ", MaximumNumberFacesReceive=",MaximumNumberFacesReceive, &
                  & ", MaximumNumberFacesCommunicate=",MaximumNumberFacesCommunicate

                ! allocate send and receive buffers
                ALLOCATE(SendBuffer2(MaximumNumberFacesCommunicate,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer2",ERR,ERROR,*999)

                SendBuffer2=0 !FIXTHIS: temporary for debugging

                ALLOCATE(ReceiveBuffer2(MaximumNumberFacesCommunicate,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer2",ERR,ERROR,*999)

                ReceiveBuffer2=0 !FIXTHIS: temporary for debugging

                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

                ! exchange number of derivatives
                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO FaceSendIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    FaceLocalNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(FaceSendIdx)
                    FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send to adj domain ",FACES_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx)%DOMAIN_NUMBER,"idx ", AdjacentDomainIdx, &
                      & " (FaceSendIdx=",FaceSendIdx,"), face global ",FaceGlobalNo,&
                      & ", n derivatives: ",1!TOPOLOGY%FACES%FACES(FaceGlobalNo)%numberOfDerivatives
                    SendBuffer2(FaceSendIdx,AdjacentDomainIdx) = 1  !TOPOLOGY%FACES%FACES(FaceGlobalNo)%numberOfDerivatives (faces currently don't have derivatives so leave this as 1)
                  ENDDO

                  ! post receive calls
                  CALL MPI_IRECV(ReceiveBuffer2(:,AdjacentDomainIdx),MaximumNumberFacesCommunicate,MPI_INTEGER, &
                    & FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                  ! post send calls
                  CALL MPI_ISEND(SendBuffer2(:,AdjacentDomainIdx),MaximumNumberFacesCommunicate,MPI_INTEGER, &
                    & FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

                ENDDO   ! AdjacentDomainIdx

                ! wait for all communication to finish
                CALL MPI_WAITALL(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                CALL MPI_WAITALL(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                ! deallocate request handles
                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(SendRequestHandle)) DEALLOCATE(SendRequestHandle)

                ! copy received number of derivatives at faces to unified array, which collects all values for ghost faces
                FirstGhostFaceLocalNo = FACES_MAPPING%DOMAIN_LIST(FACES_MAPPING%GHOST_START)
                LastGhostFaceLocalNo = FACES_MAPPING%DOMAIN_LIST(FACES_MAPPING%GHOST_FINISH)

                ! allocate array for number of derivatives at every ghost face, index is the local face no.
                ALLOCATE(NumberDerivativesAtGhostFace(FirstGhostFaceLocalNo:LastGhostFaceLocalNo),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate NumberDerivativesAtGhostFace",ERR,ERROR,*999)

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information from receive buffer
                  DO FaceReceiveIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    FaceLocalNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(FaceReceiveIdx)


                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": recv from adj domain ", &
                      & FACES_MAPPING%ADJACENT_DOMAINS( &
                      & AdjacentDomainIdx)%DOMAIN_NUMBER,", idx", AdjacentDomainIdx, &
                      & ", face local ",FaceLocalNo,", n derivatives: ",ReceiveBuffer2(FaceReceiveIdx,AdjacentDomainIdx)

                    ! get entry in receive buffer
                    NumberDerivativesAtGhostFace(FaceLocalNo) = ReceiveBuffer2(FaceReceiveIdx,AdjacentDomainIdx)
                  ENDDO  ! FaceReceiveIdx
                ENDDO   ! AdjacentDomainIdx

                ! find out maximum number of derivatives at a face
                MaxNumberDerivativesAtGhostFace = 0
                DO GhostFaceNo = FirstGhostFaceLocalNo,LastGhostFaceLocalNo
                  MaxNumberDerivativesAtGhostFace = MAX(MaxNumberDerivativesAtGhostFace, NumberDerivativesAtGhostFace(GhostFaceNo))

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberDerivativesAtGhostFace(local ",GhostFaceNo,")=",&
                    & NumberDerivativesAtGhostFace(GhostFaceNo)

                ENDDO  ! GhostFaceNo

                ! reduce over all processes
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaxNumberDerivativesAtGhostFace,1,MPI_INT,MPI_MAX, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)

                ! transfer information that reproduces all global ghost numbers at ghost faces to the domains where it is a boundary face, each
                ! allocate send and receive buffers
                ALLOCATE(SendBuffer3(0:MaxNumberDerivativesAtGhostFace, MaximumNumberFacesCommunicate,&
                  & FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer",ERR,ERROR,*999)

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": allocate send buffer for ", &
                  & MaxNumberDerivativesAtGhostFace, " derivatives"
                ! SendBuffer(0,FaceSendIdx,AdjacentDomainIdx) = global dof no of first dof at this face
                ! SendBuffer(1:DerivativeIdx,FaceSendIdx,AdjacentDomainIdx) = for each derivative the number of versions

                ALLOCATE(ReceiveBuffer3(0:MaxNumberDerivativesAtGhostFace,MaximumNumberFacesCommunicate,&
                  & FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer",ERR,ERROR,*999)

                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

                ! prepare send buffer and start send commands
                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO FaceSendIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    FaceLocalNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(FaceSendIdx)
                    FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                    DerivativeIdx = 1
                    VersionIdx = 1

                    ! get first dof at this face
                    DofLocalNo = FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)% &
                      & DERIVATIVES(DerivativeIdx)%VERSIONS(VersionIdx)

                    IF (DIAGNOSTICS2) PRINT "(4(I0,A),I0)", MyComputationalNodeNumber, ": face local ",FaceLocalNo, &
                      ", global ",FaceGlobalNo, " first dof at this face local: ", DofLocalNo

                    DofGlobalNo = FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo)

                    IF (DIAGNOSTICS2) PRINT "(5(I0,A),I0)", MyComputationalNodeNumber, ": get dof(",FaceLocalNo,",",DerivativeIdx, &
                      & ",",VersionIdx,")=local ",DofLocalNo, " global ",DofGlobalNo

                    ! store in send buffer
                    SendBuffer3(0,FaceSendIdx,AdjacentDomainIdx) = DofGlobalNo

                    ! fill send buffer with number of versions for each derivative
                    DO DerivativeIdx=1,1 !TOPOLOGY%FACES%FACES(FaceGlobalNo)%numberOfDerivatives (faces currently don't have derivatives so leave this as 1)
                      NumberVersions = 1 !TOPOLOGY%FACES%FACES(FaceGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions (faces currently don't have derivatives so leave this as 1)

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": face global ",FaceGlobalNo," has ", 1, !&TOPOLOGY%FACES%FACES(FaceGlobalNo)%numberOfDerivatives,
                      !  & " derivatives, sendbuffer ",AdjacentDomainIdx, &
                      !  & " DerivativeIdx=",DerivativeIdx, &
                      !  & " NumberVersions=",NumberVersions

                      SendBuffer3(DerivativeIdx,FaceSendIdx,AdjacentDomainIdx) = NumberVersions
                    ENDDO  ! DerivativeIdx
                  ENDDO  ! FaceSendIdx

                  !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send buffer to adj idx ", AdjacentDomainIdx,": ", &
                  !  & SendBuffer3(:,:,AdjacentDomainIdx)

                  ! post receive calls
                  CALL MPI_IRECV(ReceiveBuffer3(:,:,AdjacentDomainIdx),MaximumNumberFacesCommunicate* &
                    & (MaxNumberDerivativesAtGhostFace+1), &
                    & MPI_INTEGER,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                  ! post send calls
                  CALL MPI_ISEND(SendBuffer3(:,:,AdjacentDomainIdx),MaximumNumberFacesCommunicate* &
                    & (MaxNumberDerivativesAtGhostFace+1), &
                    & MPI_INTEGER,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

                ENDDO  ! AdjacentDomainIdx

                ! wait for all communication to finish
                CALL MPI_WAITALL(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                CALL MPI_WAITALL(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                ! deallocate request handles
                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(SendRequestHandle)) DEALLOCATE(SendRequestHandle)

                ! copy received ghost face value sets received from different adjacent domains to unified array, which collects all values for ghost faces
                ! allocate FaceDofSpecification
                ALLOCATE(FaceDofSpecification(0:MaxNumberDerivativesAtGhostFace,FirstGhostFaceLocalNo:LastGhostFaceLocalNo), &
                 & STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate FaceDofSpecification",ERR,ERROR,*999)
                ! FaceDofSpecification(0,FaceLocalNo) = first dof global no at this face
                ! FaceDofSpecification(1:MaxNumberDerivativesAtGhostFace,FaceLocalNo) = number of versions for derivatives at this face

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information from receive buffer
                  DO FaceReceiveIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    FaceLocalNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(FaceReceiveIdx)

                    !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": recv buffer from adj idx ", AdjacentDomainIdx,": ", &
                    !  & ReceiveBuffer3(:,:,AdjacentDomainIdx)

                    ! copy entry in receive buffer to entry of face
                    DO I = 0,MaxNumberDerivativesAtGhostFace
                      FaceDofSpecification(I,FaceLocalNo) = ReceiveBuffer3(I,FaceReceiveIdx,AdjacentDomainIdx)
                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": local face ",FaceLocalNo, &
                      !  & ", I=",I,", FaceReceiveIdx=",FaceReceiveIdx,", value=",FaceDofSpecification(I,FaceLocalNo)
                    ENDDO
                    !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": local face ",FaceLocalNo, &
                    !  & ", received (first dof,n versions): ", FaceDofSpecification(:,FaceLocalNo)


                    ! FaceDofSpecification(0,FaceLocalNo) = first dof global no at this face
                    ! FaceDofSpecification(1:MaxNumberDerivativesAtGhostFace,FaceLocalNo) = number of versions for derivatives at this face

                  ENDDO  ! FaceReceiveIdx
                ENDDO  ! AdjacentDomainIdx

                ! set dof indices at ghost faces from FaceDofSpecification
                ! loop over ghost faces
                DO LocalFaceIdx = FACES_MAPPING%GHOST_START,FACES_MAPPING%GHOST_FINISH
                  faceLocalNo=FACES_MAPPING%DOMAIN_LIST(LocalFaceIdx)
                  ! find adjacent domain where current face resides
                  AdjacentDomainFound = .FALSE.
                  DO AdjacentDomainIdx = 1, FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                    ! check if face is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == FaceLocalNo) THEN
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF
                    ENDDO
                    !exit if adjacent domain was found so adjacentDomainIdx is correct
                    IF(AdjacentDomainFound) EXIT
                  ENDDO  ! DO WHILE

                  IF (.NOT. AdjacentDomainFound) THEN
                    localError="face local number "//TRIM(NumberToVString(FaceLocalNo,"*",err,error))// &
                    & " was not found an the local ghost recieve indices of adjacent domains. For rank number" &
                    & //TRIM(NumberToVString(myComputationalNodeNumber,"*",err,error))
                    CALL FlagError(localError,err,error,*999)
                  ENDIF

                  ! get dof information for current ghost face
                  StartDofGlobalNo = FaceDofSpecification(0,FaceLocalNo)
                  CurrentDofGlobalNo = StartDofGlobalNo


                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": ghost face local",FaceLocalNo,", start dof global",&
                    & StartDofGlobalNo, ", n versions for ",NumberDerivativesAtGhostFace(FaceLocalNo),"derivatives: ", &
                    & FaceDofSpecification(1:NumberDerivativesAtGhostFace(FaceLocalNo),FaceLocalNo)

                  ! allocate parameter to dof map for faces
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(&
                    & NumberDerivativesAtGhostFace(FaceLocalNo)),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative map.",ERR,ERROR,*999)

                  ! loop over derivatives at ghost face
                  DO DerivativeIdx = 1, NumberDerivativesAtGhostFace(FaceLocalNo)

                    NumberVersions = FaceDofSpecification(DerivativeIdx,FaceLocalNo)

                    ! allocate parameter to dof map for face, derivative, versions
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(DerivativeIdx)% &
                      & VERSIONS(NumberVersions),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative map.",ERR,ERROR,*999)

                    ! loop over versions of derivatives
                    DO VersionIdx = 1,NumberVersions

                      ! add global dof no to LOCAL_TO_GLOBAL_MAP
                      FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

                      FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                      InternalDofIdx = InternalDofIdx + 1

                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    dof idx",InternalDofIdx-1,&
                        & ", local",CurrentDofLocalNo,", global",CurrentDofGlobalNo, ", faceDofIdx=",faceDofIdx

                      ! setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_FACE_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=faceDofIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(1,faceDofIdx)=VersionIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(2,faceDofIdx)=DerivativeIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(3,faceDofIdx)=FaceLocalNo
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(4,faceDofIdx)=component_idx
                      faceDofIdx = faceDofIdx + 1   ! this is the index when iterating over all face dofs of this field variable

                      ! setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(DerivativeIdx)% &
                        & VERSIONS(VersionIdx) = CurrentDofLocalNo

                      ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS &
                        = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS + 1

                      ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                        ! array does not yet exist, allocate with size 1
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                          & STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                        FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                          & = CurrentDofLocalNo
                      ELSE
                        ! array already exists, increase size by 1
                        FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                          & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES, &
                          & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS], &
                          & [CurrentDofLocalNo])
                      ENDIF

                      CurrentDofLocalNo = CurrentDofLocalNo + 1
                      CurrentDofGlobalNo = CurrentDofGlobalNo + 1

                    ENDDO  ! VersionIdx
                  ENDDO ! DerivativeIdx

                ENDDO  ! FaceLocalNo


                ! deallocate send and receive buffers
                IF(ALLOCATED(FaceDofSpecification)) DEALLOCATE(FaceDofSpecification)
                IF(ALLOCATED(SendBuffer2)) DEALLOCATE(SendBuffer2)
                IF(ALLOCATED(ReceiveBuffer2)) DEALLOCATE(ReceiveBuffer2)

                IF(ALLOCATED(SendBuffer3)) DEALLOCATE(SendBuffer3)
                IF(ALLOCATED(ReceiveBuffer3)) DEALLOCATE(ReceiveBuffer3)
                IF(ALLOCATED(NumberDerivativesAtGhostFace)) DEALLOCATE(NumberDerivativesAtGhostFace)

              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)

                !Again this part is the same as the elements and the face part is done after this do-select loop

                ! loop over ghost elements
                DO ElementIdx = ELEMENTS_MAPPING%GHOST_START,ELEMENTS_MAPPING%GHOST_FINISH
                  ElementLocalNo = ELEMENTS_MAPPING%DOMAIN_LIST(ElementIdx)
                  ElementGlobalNo = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(ElementLocalNo)

                  ! compute the dof global no from the element global no
                  DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - 1
                  !DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - Element1GlobalNo(component_idx)

                  ! add global dof no to LOCAL_TO_GLOBAL_MAP
                  FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = DofGlobalNo

                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                  InternalDofIdx = InternalDofIdx + 1

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    dof idx",InternalDofIdx-1,&
                    & ", local",CurrentDofLocalNo,", global",DofGlobalNo, ", CurrentElementDofIdx=",CurrentElementDofIdx

                  ! setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_ELEMENT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=CurrentElementDofIdx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,CurrentElementDofIdx)=ElementLocalNo
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,CurrentElementDofIdx)=component_idx
                  CurrentElementDofIdx = CurrentElementDofIdx + 1   ! this is the index when iterating over all element dofs of this field variable

                  ! setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ElementLocalNo) = CurrentDofLocalNo

                  ! find the adjacent domain that has the boundary element for this ghost element
                  AdjacentDomainIdx = 1
                  AdjacentDomainFound = .FALSE.
                  DO WHILE(.NOT. AdjacentDomainFound)

                    ! check if node is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == ElementLocalNo) THEN
                        AdjacentDomainNo = ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF

                    ENDDO
                    IF (.NOT. AdjacentDomainFound) AdjacentDomainIdx = AdjacentDomainIdx + 1
                  ENDDO

                  ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                  DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                      EXIT
                    ENDIF
                  ENDDO

                  ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                  FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS &
                    = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS + 1

                  ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                  IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                    ! array does not yet exist, allocate with size 1
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                      & = CurrentDofLocalNo
                  ELSE
                    ! array already exists, increase size by 1
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                      & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES, &
                      & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS], &
                      & [CurrentDofLocalNo])
                  ENDIF

                  CurrentDofLocalNo = CurrentDofLocalNo + 1
                ENDDO  ! ElementIdx

              CASE(FIELD_LINE_BASED_INTERPOLATION)

                ! set ghost dofs, use lines boundary/ghost information and communicate global dof no.s

                ! determine maximum number of lines to send and receive for all adjacent domains
                MaximumNumberLinesSend = 0
                MaximumNumberLinesReceive = 0

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                  MaximumNumberLinesSend = MAX(MaximumNumberLinesSend, &
                    & LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS)
                  MaximumNumberLinesReceive = MAX(MaximumNumberLinesReceive, &
                    & LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS)
                ENDDO
                MaximumNumberLinesCommunicate = MAX(MaximumNumberLinesSend,MaximumNumberLinesReceive)

                ! reduce over all processes
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaximumNumberLinesCommunicate,1,MPI_INT,MPI_MAX, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": MaximumNumberLinesSend=",MaximumNumberLinesSend, &
                  & ", MaximumNumberLinesReceive=",MaximumNumberLinesReceive, &
                  & ", MaximumNumberLinesCommunicate=",MaximumNumberLinesCommunicate

                ! allocate send and receive buffers
                ALLOCATE(SendBuffer2(MaximumNumberLinesCommunicate,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer2",ERR,ERROR,*999)

                SendBuffer2=0 !FIXTHIS: temporary for debugging

                ALLOCATE(ReceiveBuffer2(MaximumNumberLinesCommunicate,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer2",ERR,ERROR,*999)

                ReceiveBuffer2=0 !FIXTHIS: temporary for debugging

                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

                ! exchange number of derivatives
                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO LineSendIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    LineLocalNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(LineSendIdx)
                    LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send to adj domain ",LINES_MAPPING%ADJACENT_DOMAINS(&
                      & AdjacentDomainIdx)%DOMAIN_NUMBER,"idx ", AdjacentDomainIdx, &
                      & " (LineSendIdx=",LineSendIdx,"), line global ",LineGlobalNo,&
                      & ", n derivatives: ",1!TOPOLOGY%LINES%LINES(LineGlobalNo)%numberOfDerivatives
                    SendBuffer2(LineSendIdx,AdjacentDomainIdx) = 1  !TOPOLOGY%LINES%LINES(LineGlobalNo)%numberOfDerivatives (lines currently don't have derivatives so leave this as 1)
                  ENDDO

                  ! post receive calls
                  CALL MPI_IRECV(ReceiveBuffer2(:,AdjacentDomainIdx),MaximumNumberLinesCommunicate,MPI_INTEGER, &
                    & LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                  ! post send calls
                  CALL MPI_ISEND(SendBuffer2(:,AdjacentDomainIdx),MaximumNumberLinesCommunicate,MPI_INTEGER, &
                    & LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

                ENDDO   ! AdjacentDomainIdx

                ! wait for all communication to finish
                CALL MPI_WAITALL(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                CALL MPI_WAITALL(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                ! deallocate request handles
                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(SendRequestHandle)) DEALLOCATE(SendRequestHandle)

                ! copy received number of derivatives at lines to unified array, which collects all values for ghost lines
                FirstGhostLineLocalNo = LINES_MAPPING%DOMAIN_LIST(LINES_MAPPING%GHOST_START)
                LastGhostLineLocalNo = LINES_MAPPING%DOMAIN_LIST(LINES_MAPPING%GHOST_FINISH)

                ! allocate array for number of derivatives at every ghost line, index is the local line no.
                ALLOCATE(NumberDerivativesAtGhostLine(FirstGhostLineLocalNo:LastGhostLineLocalNo),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate NumberDerivativesAtGhostLine",ERR,ERROR,*999)

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information from receive buffer
                  DO LineReceiveIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    LineLocalNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(LineReceiveIdx)


                    IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": recv from adj domain ", &
                      & LINES_MAPPING%ADJACENT_DOMAINS( &
                      & AdjacentDomainIdx)%DOMAIN_NUMBER,", idx", AdjacentDomainIdx, &
                      & ", line local ",LineLocalNo,", n derivatives: ",ReceiveBuffer2(LineReceiveIdx,AdjacentDomainIdx)

                    ! get entry in receive buffer
                    NumberDerivativesAtGhostLine(LineLocalNo) = ReceiveBuffer2(LineReceiveIdx,AdjacentDomainIdx)
                  ENDDO  ! LineReceiveIdx
                ENDDO   ! AdjacentDomainIdx

                ! find out maximum number of derivatives at a line
                MaxNumberDerivativesAtGhostLine = 0
                DO GhostLineNo = FirstGhostLineLocalNo,LastGhostLineLocalNo
                  MaxNumberDerivativesAtGhostLine = MAX(MaxNumberDerivativesAtGhostLine, NumberDerivativesAtGhostLine(GhostLineNo))

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": NumberDerivativesAtGhostLine(local ",GhostLineNo,")=",&
                    & NumberDerivativesAtGhostLine(GhostLineNo)

                ENDDO  ! GhostLineNo

                ! reduce over all processes
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaxNumberDerivativesAtGhostLine,1,MPI_INT,MPI_MAX, &
                  & computationalEnvironment%mpiCommunicator,MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)

                ! transfer information that reproduces all global ghost numbers at ghost lines to the domains where it is a boundary line, each
                ! allocate send and receive buffers
                ALLOCATE(SendBuffer3(0:MaxNumberDerivativesAtGhostLine, MaximumNumberLinesCommunicate,&
                  & LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer",ERR,ERROR,*999)

                IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": allocate send buffer for ", &
                  & MaxNumberDerivativesAtGhostLine, " derivatives"
                ! SendBuffer(0,LineSendIdx,AdjacentDomainIdx) = global dof no of first dof at this line
                ! SendBuffer(1:DerivativeIdx,LineSendIdx,AdjacentDomainIdx) = for each derivative the number of versions

                ALLOCATE(ReceiveBuffer3(0:MaxNumberDerivativesAtGhostLine,MaximumNumberLinesCommunicate,&
                  & LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer",ERR,ERROR,*999)

                ! allocate request handles
                ALLOCATE(ReceiveRequestHandle(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

                ALLOCATE(SendRequestHandle(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

                ! prepare send buffer and start send commands
                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO LineSendIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                    LineLocalNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(LineSendIdx)
                    LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                    DerivativeIdx = 1
                    VersionIdx = 1

                    ! get first dof at this line
                    DofLocalNo = FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)% &
                      & DERIVATIVES(DerivativeIdx)%VERSIONS(VersionIdx)

                    IF (DIAGNOSTICS2) PRINT "(4(I0,A),I0)", MyComputationalNodeNumber, ": line local ",LineLocalNo, &
                      ", global ",LineGlobalNo, " first dof at this line local: ", DofLocalNo

                    DofGlobalNo = FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo)

                    IF (DIAGNOSTICS2) PRINT "(5(I0,A),I0)", MyComputationalNodeNumber, ": get dof(",LineLocalNo,",",DerivativeIdx, &
                      & ",",VersionIdx,")=local ",DofLocalNo, " global ",DofGlobalNo

                    ! store in send buffer
                    SendBuffer3(0,LineSendIdx,AdjacentDomainIdx) = DofGlobalNo

                    ! fill send buffer with number of versions for each derivative
                    DO DerivativeIdx=1,1 !TOPOLOGY%LINES%LINES(LineGlobalNo)%numberOfDerivatives (lines currently don't have derivatives so leave this as 1)
                      NumberVersions = 1 !TOPOLOGY%LINES%LINES(LineGlobalNo)%DERIVATIVES(DerivativeIdx)%numberOfVersions (lines currently don't have derivatives so leave this as 1)

                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": line global ",LineGlobalNo," has ", 1, !&TOPOLOGY%LINES%LINES(LineGlobalNo)%numberOfDerivatives,
                      !  & " derivatives, sendbuffer ",AdjacentDomainIdx, &
                      !  & " DerivativeIdx=",DerivativeIdx, &
                      !  & " NumberVersions=",NumberVersions

                      SendBuffer3(DerivativeIdx,LineSendIdx,AdjacentDomainIdx) = NumberVersions
                    ENDDO  ! DerivativeIdx
                  ENDDO  ! LineSendIdx

                  !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send buffer to adj idx ", AdjacentDomainIdx,": ", &
                  !  & SendBuffer3(:,:,AdjacentDomainIdx)

                  ! post receive calls
                  CALL MPI_IRECV(ReceiveBuffer3(:,:,AdjacentDomainIdx),MaximumNumberLinesCommunicate* &
                    & (MaxNumberDerivativesAtGhostLine+1), &
                    & MPI_INTEGER,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                  ! post send calls
                  CALL MPI_ISEND(SendBuffer3(:,:,AdjacentDomainIdx),MaximumNumberLinesCommunicate* &
                    & (MaxNumberDerivativesAtGhostLine+1), &
                    & MPI_INTEGER,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                    & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle(AdjacentDomainIdx),MPI_IERROR)
                  CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

                ENDDO  ! AdjacentDomainIdx

                ! wait for all communication to finish
                CALL MPI_WAITALL(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                CALL MPI_WAITALL(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle, MPI_STATUSES_IGNORE, MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

                ! deallocate request handles
                IF(ALLOCATED(ReceiveRequestHandle)) DEALLOCATE(ReceiveRequestHandle)
                IF(ALLOCATED(SendRequestHandle)) DEALLOCATE(SendRequestHandle)

                ! copy received ghost line value sets received from different adjacent domains to unified array, which collects all values for ghost lines
                ! allocate LineDofSpecification
                ALLOCATE(LineDofSpecification(0:MaxNumberDerivativesAtGhostLine,FirstGhostLineLocalNo:LastGhostLineLocalNo), &
                 & STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate LineDofSpecification",ERR,ERROR,*999)
                ! LineDofSpecification(0,LineLocalNo) = first dof global no at this line
                ! LineDofSpecification(1:MaxNumberDerivativesAtGhostLine,LineLocalNo) = number of versions for derivatives at this line

                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information from receive buffer
                  DO LineReceiveIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    LineLocalNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(LineReceiveIdx)

                    !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": recv buffer from adj idx ", AdjacentDomainIdx,": ", &
                    !  & ReceiveBuffer3(:,:,AdjacentDomainIdx)

                    ! copy entry in receive buffer to entry of line
                    DO I = 0,MaxNumberDerivativesAtGhostLine
                      LineDofSpecification(I,LineLocalNo) = ReceiveBuffer3(I,LineReceiveIdx,AdjacentDomainIdx)
                      !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": local line ",LineLocalNo, &
                      !  & ", I=",I,", LineReceiveIdx=",LineReceiveIdx,", value=",LineDofSpecification(I,LineLocalNo)
                    ENDDO
                    !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": local line ",LineLocalNo, &
                    !  & ", received (first dof,n versions): ", LineDofSpecification(:,LineLocalNo)


                    ! LineDofSpecification(0,LineLocalNo) = first dof global no at this line
                    ! LineDofSpecification(1:MaxNumberDerivativesAtGhostLine,LineLocalNo) = number of versions for derivatives at this line

                  ENDDO  ! LineReceiveIdx
                ENDDO  ! AdjacentDomainIdx

                ! set dof indices at ghost lines from LineDofSpecification
                ! loop over ghost lines
                DO LocalLineIdx = LINES_MAPPING%GHOST_START,LINES_MAPPING%GHOST_FINISH
                  lineLocalNo=LINES_MAPPING%DOMAIN_LIST(LocalLineIdx)
                  ! find adjacent domain where current line resides
                  AdjacentDomainFound = .FALSE.
                  DO AdjacentDomainIdx = 1, LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                    ! check if line is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == LineLocalNo) THEN
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF
                    ENDDO
                    !exit if adjacent domain was found so adjacentDomainIdx is correct
                    IF(AdjacentDomainFound) EXIT
                  ENDDO  ! DO WHILE

                  IF (.NOT. AdjacentDomainFound) THEN
                    localError="line local number "//TRIM(NumberToVString(LineLocalNo,"*",err,error))// &
                    & " was not found an the local ghost recieve indices of adjacent domains. For rank number" &
                    & //TRIM(NumberToVString(myComputationalNodeNumber,"*",err,error))
                    CALL FlagError(localError,err,error,*999)
                  ENDIF

                  ! get dof information for current ghost line
                  StartDofGlobalNo = LineDofSpecification(0,LineLocalNo)
                  CurrentDofGlobalNo = StartDofGlobalNo


                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": ghost line local",LineLocalNo,", start dof global",&
                    & StartDofGlobalNo, ", n versions for ",NumberDerivativesAtGhostLine(LineLocalNo),"derivatives: ", &
                    & LineDofSpecification(1:NumberDerivativesAtGhostLine(LineLocalNo),LineLocalNo)

                  ! allocate parameter to dof map for lines
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(&
                    & NumberDerivativesAtGhostLine(LineLocalNo)),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative map.",ERR,ERROR,*999)

                  ! loop over derivatives at ghost line
                  DO DerivativeIdx = 1, NumberDerivativesAtGhostLine(LineLocalNo)

                    NumberVersions = LineDofSpecification(DerivativeIdx,LineLocalNo)

                    ! allocate parameter to dof map for line, derivative, versions
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(DerivativeIdx)% &
                      & VERSIONS(NumberVersions),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative map.",ERR,ERROR,*999)

                    ! loop over versions of derivatives
                    DO VersionIdx = 1,NumberVersions

                      ! add global dof no to LOCAL_TO_GLOBAL_MAP
                      FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = CurrentDofGlobalNo

                      FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                      InternalDofIdx = InternalDofIdx + 1

                      IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    dof idx",InternalDofIdx-1,&
                        & ", local",CurrentDofLocalNo,", global",CurrentDofGlobalNo, ", lineDofIdx=",lineDofIdx

                      ! setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_LINE_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=lineDofIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(1,lineDofIdx)=LineLocalNo
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(2,lineDofIdx)=component_idx
                      lineDofIdx = lineDofIdx + 1   ! this is the index when iterating over all line dofs of this field variable

                      ! setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(DerivativeIdx)% &
                        & VERSIONS(VersionIdx) = CurrentDofLocalNo

                      ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                      FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS &
                        = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS + 1

                      ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                      IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                        ! array does not yet exist, allocate with size 1
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                          & STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                        FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                          & = CurrentDofLocalNo
                      ELSE
                        ! array already exists, increase size by 1
                        FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                          & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES, &
                          & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS], &
                          & [CurrentDofLocalNo])
                      ENDIF

                      CurrentDofLocalNo = CurrentDofLocalNo + 1
                      CurrentDofGlobalNo = CurrentDofGlobalNo + 1

                    ENDDO  ! VersionIdx
                  ENDDO ! DerivativeIdx

                ENDDO  ! LineLocalNo


                ! deallocate send and receive buffers
                IF(ALLOCATED(LineDofSpecification)) DEALLOCATE(LineDofSpecification)
                IF(ALLOCATED(SendBuffer2)) DEALLOCATE(SendBuffer2)
                IF(ALLOCATED(ReceiveBuffer2)) DEALLOCATE(ReceiveBuffer2)

                IF(ALLOCATED(SendBuffer3)) DEALLOCATE(SendBuffer3)
                IF(ALLOCATED(ReceiveBuffer3)) DEALLOCATE(ReceiveBuffer3)
                IF(ALLOCATED(NumberDerivativesAtGhostLine)) DEALLOCATE(NumberDerivativesAtGhostLine)

              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !Again this part is the same as the elements and the line part is done after this do-select loop

                ! loop over ghost elements
                DO ElementIdx = ELEMENTS_MAPPING%GHOST_START,ELEMENTS_MAPPING%GHOST_FINISH
                  ElementLocalNo = ELEMENTS_MAPPING%DOMAIN_LIST(ElementIdx)
                  ElementGlobalNo = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(ElementLocalNo)

                  ! compute the dof global no from the element global no
                  DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - 1
                  !DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - Element1GlobalNo(component_idx)

                  ! add global dof no to LOCAL_TO_GLOBAL_MAP
                  FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = DofGlobalNo

                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                  InternalDofIdx = InternalDofIdx + 1

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    dof idx",InternalDofIdx-1,&
                    & ", local",CurrentDofLocalNo,", global",DofGlobalNo, ", CurrentElementDofIdx=",CurrentElementDofIdx

                  ! setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_ELEMENT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=CurrentElementDofIdx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,CurrentElementDofIdx)=ElementLocalNo
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,CurrentElementDofIdx)=component_idx
                  CurrentElementDofIdx = CurrentElementDofIdx + 1   ! this is the index when iterating over all element dofs of this field variable

                  ! setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ElementLocalNo) = CurrentDofLocalNo

                  ! find the adjacent domain that has the boundary element for this ghost element
                  AdjacentDomainIdx = 1
                  AdjacentDomainFound = .FALSE.
                  DO WHILE(.NOT. AdjacentDomainFound)

                    ! check if node is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == ElementLocalNo) THEN
                        AdjacentDomainNo = ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF

                    ENDDO
                    IF (.NOT. AdjacentDomainFound) AdjacentDomainIdx = AdjacentDomainIdx + 1
                  ENDDO

                  ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                  DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                      EXIT
                    ENDIF
                  ENDDO

                  ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                  FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS &
                    = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS + 1

                  ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                  IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                    ! array does not yet exist, allocate with size 1
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                      & = CurrentDofLocalNo
                  ELSE
                    ! array already exists, increase size by 1
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                      & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES, &
                      & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS], &
                      & [CurrentDofLocalNo])
                  ENDIF

                  CurrentDofLocalNo = CurrentDofLocalNo + 1
                ENDDO  ! ElementIdx

              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)

                ! loop over ghost elements
                DO ElementIdx = ELEMENTS_MAPPING%GHOST_START,ELEMENTS_MAPPING%GHOST_FINISH
                  ElementLocalNo = ELEMENTS_MAPPING%DOMAIN_LIST(ElementIdx)
                  ElementGlobalNo = ELEMENTS_MAPPING%LOCAL_TO_GLOBAL_MAP(ElementLocalNo)

                  ! compute the dof global no from the element global no
                  DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - 1
                  !DofGlobalNo = FirstDofGlobalNo(component_idx) + ElementGlobalNo - Element1GlobalNo(component_idx)

                  ! add global dof no to LOCAL_TO_GLOBAL_MAP
                  FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(CurrentDofLocalNo) = DofGlobalNo

                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo
                  InternalDofIdx = InternalDofIdx + 1

                  IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ":    dof idx",InternalDofIdx-1,&
                    & ", local",CurrentDofLocalNo,", global",DofGlobalNo, ", CurrentElementDofIdx=",CurrentElementDofIdx

                  ! setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,CurrentDofLocalNo)=FIELD_ELEMENT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,CurrentDofLocalNo)=CurrentElementDofIdx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,CurrentElementDofIdx)=ElementLocalNo
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,CurrentElementDofIdx)=component_idx
                  CurrentElementDofIdx = CurrentElementDofIdx + 1   ! this is the index when iterating over all element dofs of this field variable

                  ! setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(ElementLocalNo) = CurrentDofLocalNo

                  ! find the adjacent domain that has the boundary element for this ghost element
                  AdjacentDomainIdx = 1
                  AdjacentDomainFound = .FALSE.
                  DO WHILE(.NOT. AdjacentDomainFound)

                    ! check if node is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == ElementLocalNo) THEN
                        AdjacentDomainNo = ELEMENTS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF

                    ENDDO
                    IF (.NOT. AdjacentDomainFound) AdjacentDomainIdx = AdjacentDomainIdx + 1
                  ENDDO

                  ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                  DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                      EXIT
                    ENDIF
                  ENDDO

                  ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                  FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS &
                    = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS + 1

                  ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                  IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                    ! array does not yet exist, allocate with size 1
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                      & = CurrentDofLocalNo
                  ELSE
                    ! array already exists, increase size by 1
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                      & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES, &
                      & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS], &
                      & [CurrentDofLocalNo])
                  ENDIF

                  CurrentDofLocalNo = CurrentDofLocalNo + 1
                ENDDO  ! ElementIdx

              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Do nothing
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)

              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)

              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)

              CASE DEFAULT
                LOCAL_ERROR="The interpolation type of "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                  & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                  & " of variable type  "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT

            ENDDO  ! component_idx
          ENDIF  ! IF (NumberComputationalNodes /= 1)


          !Here we loop over components again for faces or lines IF the interpolation type is ELEMENTS_AND_EXT_FACES or _LINES to assign ghost external faces or lines
          IF(FIELD_COMPONENT%INTERPOLATION_TYPE==FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION) THEN
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
              !TOPOLOGY=>FIELD_COMPONENT%DOMAIN%TOPOLOGY
              domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
              ELEMENTS_MAPPING=>domainMappings%ELEMENTS
              FACES_MAPPING=>domainMappings%FACES


              ! set ghost dofs, use faces boundary/ghost information and communicate global dof no.s

              ! determine maximum number of faces to send and receive for all adjacent domains
              MaximumNumberFacesSend = 0
              MaximumNumberFacesReceive = 0

              ! loop over adjacent domains
              DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                MaximumNumberFacesSend = MAX(MaximumNumberFacesSend, &
                  & FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS)
                MaximumNumberFacesReceive = MAX(MaximumNumberFacesReceive, &
                  & FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS)
              ENDDO
              MaximumNumberFacesCommunicate = MAX(MaximumNumberFacesSend,MaximumNumberFacesReceive)

              ! reduce over all processes
              CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaximumNumberFacesCommunicate,1,MPI_INT,MPI_MAX, &
                & computationalEnvironment%mpiCommunicator,MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)


              ! transfer information that reproduces all global dof numbers at ghost faces to the domains where it is a boundary face, each
              ! allocate send and receive buffers
              ALLOCATE(SendBuffer2(MaximumNumberFacesCommunicate, FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer",ERR,ERROR,*999)

              !FIXTHIS MaxNumberOfFacesCommunicate can be reduced from knowledge that only some faces are boundary faces, atm assumes all faces could be transferred.
              ALLOCATE(ReceiveBuffer2(MaximumNumberFacesCommunicate,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer",ERR,ERROR,*999)

              ! allocate request handles
              ALLOCATE(ReceiveRequestHandle2(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

              ALLOCATE(SendRequestHandle2(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

              ! prepare send buffer and start send commands
              ! loop over adjacent domains
              DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                ! copy information to send buffer
                DO FaceSendIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                  FaceLocalNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(FaceSendIdx)
                  FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(FaceLocalNo)%BOUNDARY_LINE) THEN
                    ! get first dof at this face
                    DofLocalNo = FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)% &
                      & DERIVATIVES(1)%VERSIONS(1)

                    DofGlobalNo = FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo)

                    ! store in send buffer
                    SendBuffer2(FaceSendIdx,AdjacentDomainIdx) = DofGlobalNo
                  ELSE
                    SendBuffer2(FaceSendIdx,AdjacentDomainIdx) =-1
                  ENDIF
                ENDDO  ! FaceSendIdx

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send buffer to adj idx ", AdjacentDomainIdx,": ", &
                !  & SendBuffer3(:,:,AdjacentDomainIdx)

                ! post receive calls
                CALL MPI_IRECV(ReceiveBuffer2(:,AdjacentDomainIdx),MaximumNumberFacesCommunicate, &
                  & MPI_INTEGER,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                  & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle2(AdjacentDomainIdx),MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                ! post send calls
                CALL MPI_ISEND(SendBuffer2(:,AdjacentDomainIdx),MaximumNumberFacesCommunicate, &
                  & MPI_INTEGER,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                  & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle2(AdjacentDomainIdx),MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

              ENDDO  ! AdjacentDomainIdx

              ! wait for all communication to finish
              CALL MPI_WAITALL(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle2, MPI_STATUSES_IGNORE, MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

              CALL MPI_WAITALL(FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle2, MPI_STATUSES_IGNORE, MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

              ! deallocate request handles
              IF(ALLOCATED(ReceiveRequestHandle2)) DEALLOCATE(ReceiveRequestHandle2)
              IF(ALLOCATED(SendRequestHandle2)) DEALLOCATE(SendRequestHandle2)



              !get the first and last ghost face local numbers, these will be in order
              FirstGhostFaceLocalNo = FACES_MAPPING%DOMAIN_LIST(FACES_MAPPING%GHOST_START)
              LastGhostFaceLocalNo = FACES_MAPPING%DOMAIN_LIST(FACES_MAPPING%GHOST_FINISH)


              DofLocalNo=CurrentDofLocalNo-1


              ALLOCATE(dofGlobalNumberFromFaceLocalNumber(FirstGhostFaceLocalNo:LastGhostFaceLocalNo))

              ! loop over adjacent domains
              DO AdjacentDomainIdx=1,FACES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                ! copy information to send buffer
                DO FaceSendIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                  FaceLocalNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(FaceSendIdx)
                  FaceGlobalNo = FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)


                  dofGlobalNumberFromFaceLocalNumber(FaceLocalNo)=ReceiveBuffer2(FaceSendIdx,AdjacentDomainIdx)

                ENDDO !FaceSendIdx
              ENDDO !AdjacentDomainIdx


              DO faceIdx=FACES_MAPPING%GHOST_START,FACES_MAPPING%GHOST_FINISH
                FaceLocalNo=FACES_MAPPING%DOMAIN_LIST(faceIdx)
                FaceGlobalNo=FACES_MAPPING%LOCAL_TO_GLOBAL_MAP(FaceLocalNo)

                !If this face isn't an external face then we exit the do loop.
                IF(.NOT.FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(FaceLocalNo)%BOUNDARY_LINE) CYCLE


                !DofGlobalNo = FirstDofGlobalNo(component_idx) + FaceGlobalNo - Face1GlobalNo(component_idx)
                DofLocalNo = DofLocalNo+1

                DofGlobalNo = dofGlobalNumberFromFaceLocalNumber(FaceLocalNo)
                ! add global dof no to LOCAL_TO_GLOBAL_MAP
                FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo
                FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo

                InternalDofIdx = InternalDofIdx + 1

                ! setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_FACE_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=faceDofIdx
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(1,faceDofIdx)=FaceLocalNo
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(2,faceDofIdx)=component_idx


                ! setup reverse parameter to dof map


                !Not sure if we want this to be componentFaceDofIdx or faceLocalNo, id it is faceLocal Number we would have to allocate a lot more FACES for face_param2dof_map
                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(&
                  & NumberDerivatives),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative map for FaceLocalNo "//&
                  & TRIM(NUMBER_TO_VSTRING(FaceLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)% &
                  & DERIVATIVES(NumberDerivatives)%VERSIONS(NumberVersions),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate param to dof faces derivative versions map for FaceLocalNo"//&
                  & TRIM(NUMBER_TO_VSTRING(FaceLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)



                FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(FaceLocalNo)%DERIVATIVES(1)%VERSIONS(1) =  &
                  & DofLocalNo
                faceDofIdx = faceDofIdx + 1   ! counter of number of faceDofIdx used


                ! find the adjacent domain that has the boundary face for this ghost face
                AdjacentDomainIdx = 1
                AdjacentDomainFound = .FALSE.
                DO WHILE(.NOT. AdjacentDomainFound)

                  ! check if face is in current adjacent domain
                  ! loop over receive ghost local numbers
                  DO GhostReceiveIdx = 1,FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                    IF (FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                      & == FaceLocalNo) THEN
                      AdjacentDomainNo = FACES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                      AdjacentDomainFound = .TRUE.
                      EXIT
                    ENDIF

                  ENDDO
                  IF (.NOT. AdjacentDomainFound) AdjacentDomainIdx = AdjacentDomainIdx + 1
                ENDDO

                ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                  IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                    EXIT
                  ENDIF
                ENDDO

                ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS &
                  = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS + 1

                ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                  ! array does not yet exist, allocate with size 1
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                    & STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                  FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                    & = CurrentDofLocalNo
                ELSE
                  ! array already exists, increase size by 1
                  FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                    & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES, &
                    & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS], &
                    & [CurrentDofLocalNo])
                ENDIF

                CurrentDofLocalNo=CurrentDofLocalNo+1


              ENDDO !faceIdx
              IF(ALLOCATED(SendBuffer2)) DEALLOCATE(SendBuffer2)
              IF(ALLOCATED(ReceiveBuffer2)) DEALLOCATE(ReceiveBuffer2)
              IF(ALLOCATED(dofGlobalNumberFromFaceLocalNumber)) DEALLOCATE(dofGlobalNumberFromFaceLocalNumber)
            ENDDO !component_idx

          ELSE IF(FIELD_COMPONENT%INTERPOLATION_TYPE==FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION) THEN
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              TOPOLOGY=>FIELD%DECOMPOSITION%MESH%TOPOLOGY(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR
              !TOPOLOGY=>FIELD_COMPONENT%DOMAIN%TOPOLOGY
              domainMappings=>FIELD_COMPONENT%DOMAIN%MAPPINGS
              ELEMENTS_MAPPING=>domainMappings%ELEMENTS
              LINES_MAPPING=>domainMappings%LINES


              ! set ghost dofs, use lines boundary/ghost information and communicate global dof no.s

              ! determine maximum number of lines to send and receive for all adjacent domains
              MaximumNumberLinesSend = 0
              MaximumNumberLinesReceive = 0

              ! loop over adjacent domains
              DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                MaximumNumberLinesSend = MAX(MaximumNumberLinesSend, &
                  & LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS)
                MaximumNumberLinesReceive = MAX(MaximumNumberLinesReceive, &
                  & LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS)
              ENDDO
              MaximumNumberLinesCommunicate = MAX(MaximumNumberLinesSend,MaximumNumberLinesReceive)

              ! reduce over all processes
              CALL MPI_ALLREDUCE(MPI_IN_PLACE,MaximumNumberLinesCommunicate,1,MPI_INT,MPI_MAX, &
                & computationalEnvironment%mpiCommunicator,MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)


              ! transfer information that reproduces all global dof numbers at ghost lines to the domains where it is a boundary line, each
              ! allocate send and receive buffers
              ALLOCATE(SendBuffer2(MaximumNumberLinesCommunicate, LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate SendBuffer",ERR,ERROR,*999)

              !FIXTHIS MaxNumberOfLinesCommunicate can be reduced from knowledge that only some lines are boundary lines, atm assumes all lines could be transferred.
              ALLOCATE(ReceiveBuffer2(MaximumNumberLinesCommunicate,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate ReceiveBuffer",ERR,ERROR,*999)

              ! allocate request handles
              ALLOCATE(ReceiveRequestHandle2(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate ReceiveRequest",ERR,ERROR,*999)

              ALLOCATE(SendRequestHandle2(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate SendRequest",ERR,ERROR,*999)

              ! prepare send buffer and start send commands
              ! loop over adjacent domains
              DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                ! copy information to send buffer
                DO LineSendIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_SEND_GHOSTS
                  LineLocalNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_SEND_INDICES(LineSendIdx)
                  LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                  IF(FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(LineLocalNo)%BOUNDARY_LINE) THEN
                    ! get first dof at this line
                    DofLocalNo = FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)% &
                      & DERIVATIVES(1)%VERSIONS(1)

                    DofGlobalNo = FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo)

                    ! store in send buffer
                    SendBuffer2(LineSendIdx,AdjacentDomainIdx) = DofGlobalNo
                  ELSE
                    SendBuffer2(LineSendIdx,AdjacentDomainIdx) =-1
                  ENDIF
                ENDDO  ! LineSendIdx

                !IF (DIAGNOSTICS2) PRINT *, MyComputationalNodeNumber, ": send buffer to adj idx ", AdjacentDomainIdx,": ", &
                !  & SendBuffer3(:,:,AdjacentDomainIdx)

                ! post receive calls
                CALL MPI_IRECV(ReceiveBuffer2(:,AdjacentDomainIdx),MaximumNumberLinesCommunicate, &
                  & MPI_INTEGER,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                  & 0,computationalEnvironment%mpiCommunicator,ReceiveRequestHandle2(AdjacentDomainIdx),MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_IRECV",MPI_IERROR,ERR,ERROR,*999)

                ! post send calls
                CALL MPI_ISEND(SendBuffer2(:,AdjacentDomainIdx),MaximumNumberLinesCommunicate, &
                  & MPI_INTEGER,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER, &
                  & 0,computationalEnvironment%mpiCommunicator,SendRequestHandle2(AdjacentDomainIdx),MPI_IERROR)
                CALL MPI_ERROR_CHECK("MPI_ISEND",MPI_IERROR,ERR,ERROR,*999)

              ENDDO  ! AdjacentDomainIdx

              ! wait for all communication to finish
              CALL MPI_WAITALL(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, SendRequestHandle2, MPI_STATUSES_IGNORE, MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

              CALL MPI_WAITALL(LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS, ReceiveRequestHandle2, MPI_STATUSES_IGNORE, MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_WAITALL",MPI_IERROR,ERR,ERROR,*999)

              ! deallocate request handles
              IF(ALLOCATED(ReceiveRequestHandle2)) DEALLOCATE(ReceiveRequestHandle2)
              IF(ALLOCATED(SendRequestHandle2)) DEALLOCATE(SendRequestHandle2)



              !get the first and last ghost line local numbers, these will be in order

              !\TODO this if statmenet should be around more of the code above
              IF(LINES_MAPPING%NUMBER_OF_GHOST>0) THEN
                FirstGhostLineLocalNo = LINES_MAPPING%DOMAIN_LIST(LINES_MAPPING%GHOST_START)
                LastGhostLineLocalNo = LINES_MAPPING%DOMAIN_LIST(LINES_MAPPING%GHOST_FINISH)
                ALLOCATE(dofGlobalNumberFromLineLocalNumber(FirstGhostLineLocalNo:LastGhostLineLocalNo))


                DofLocalNo=CurrentDofLocalNo-1




                ! loop over adjacent domains
                DO AdjacentDomainIdx=1,LINES_MAPPING%NUMBER_OF_ADJACENT_DOMAINS

                  ! copy information to send buffer
                  DO LineSendIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS
                    LineLocalNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(LineSendIdx)
                    LineGlobalNo = LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)


                    dofGlobalNumberFromLineLocalNumber(LineLocalNo)=ReceiveBuffer2(LineSendIdx,AdjacentDomainIdx)

                  ENDDO !LineSendIdx
                ENDDO !AdjacentDomainIdx


                DO lineIdx=LINES_MAPPING%GHOST_START,LINES_MAPPING%GHOST_FINISH
                  LineLocalNo=LINES_MAPPING%DOMAIN_LIST(lineIdx)
                  LineGlobalNo=LINES_MAPPING%LOCAL_TO_GLOBAL_MAP(LineLocalNo)

                  !If this line isn't an external line then we exit the do loop.
                  IF(.NOT.FIELD_COMPONENT%DOMAIN%TOPOLOGY%LINES%LINES(LineLocalNo)%BOUNDARY_LINE) CYCLE


                  !DofGlobalNo = FirstDofGlobalNo(component_idx) + LineGlobalNo - Line1GlobalNo(component_idx)
                  DofLocalNo = DofLocalNo+1

                  DofGlobalNo = dofGlobalNumberFromLineLocalNumber(LineLocalNo)
                  ! add global dof no to LOCAL_TO_GLOBAL_MAP
                  FIELD_VARIABLE_DOFS_MAPPING%LOCAL_TO_GLOBAL_MAP(DofLocalNo) = DofGlobalNo
                  FIELD_VARIABLE_DOFS_MAPPING%DOMAIN_LIST(InternalDofIdx) = CurrentDofLocalNo

                  InternalDofIdx = InternalDofIdx + 1

                  ! setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,DofLocalNo)=FIELD_LINE_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,DofLocalNo)=lineDofIdx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(1,lineDofIdx)=LineLocalNo
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%LINE_DOF2PARAM_MAP(2,lineDofIdx)=component_idx


                  ! setup reverse parameter to dof map


                  !Not sure if we want this to be componentLineDofIdx or lineLocalNo, id it is lineLocal Number we would have to allocate a lot more LINES for line_param2dof_map
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(&
                    & NumberDerivatives),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative map for LineLocalNo "//&
                    & TRIM(NUMBER_TO_VSTRING(LineLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)

                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)% &
                    & DERIVATIVES(NumberDerivatives)%VERSIONS(NumberVersions),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate param to dof lines derivative versions map for LineLocalNo"//&
                    & TRIM(NUMBER_TO_VSTRING(LineLocalNo,"*",ERR,ERROR)),ERR,ERROR,*999)



                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(LineLocalNo)%DERIVATIVES(1)%VERSIONS(1) =  &
                    & DofLocalNo
                  lineDofIdx = lineDofIdx + 1   ! counter of number of lineDofIdx used


                  ! find the adjacent domain that has the boundary line for this ghost line
                  AdjacentDomainIdx = 1
                  AdjacentDomainFound = .FALSE.
                  DO WHILE(.NOT. AdjacentDomainFound)

                    ! check if line is in current adjacent domain
                    ! loop over receive ghost local numbers
                    DO GhostReceiveIdx = 1,LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%NUMBER_OF_RECEIVE_GHOSTS

                      IF (LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%LOCAL_GHOST_RECEIVE_INDICES(GhostReceiveIdx) &
                        & == LineLocalNo) THEN
                        AdjacentDomainNo = LINES_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx)%DOMAIN_NUMBER
                        AdjacentDomainFound = .TRUE.
                        EXIT
                      ENDIF

                    ENDDO
                    IF (.NOT. AdjacentDomainFound) AdjacentDomainIdx = AdjacentDomainIdx + 1
                  ENDDO

                  ! find adjacent domain idx of AdjacentDomainNo of FIELD_VARIABLE_DOFS_MAPPING (can be different from AdjacentDomainIdx)
                  DO AdjacentDomainIdx2 = 1,FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_ADJACENT_DOMAINS
                    IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%DOMAIN_NUMBER == AdjacentDomainNo) THEN
                      EXIT
                    ENDIF
                  ENDDO

                  ! add current local dof no to adjacent domains array (LOCAL_GHOST_RECEIVE_INDICES)
                  FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS &
                    = FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS + 1

                  ! add CurrentDofLocalNo to LOCAL_GHOST_RECEIVE_INDICES
                  IF (FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS == 1) THEN
                    ! array does not yet exist, allocate with size 1
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate LOCAL_GHOST_RECEIVE_INDICES.",ERR,ERROR,*999)

                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES(1) &
                      & = CurrentDofLocalNo
                  ELSE
                    ! array already exists, increase size by 1
                    FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES = RESHAPE(&
                      & FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%LOCAL_GHOST_RECEIVE_INDICES, &
                      & [FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS(AdjacentDomainIdx2)%NUMBER_OF_RECEIVE_GHOSTS], &
                      & [CurrentDofLocalNo])
                  ENDIF

                  CurrentDofLocalNo=CurrentDofLocalNo+1


                ENDDO !lineIdx
              ENDIF
              IF(ALLOCATED(SendBuffer2)) DEALLOCATE(SendBuffer2)
              IF(ALLOCATED(ReceiveBuffer2)) DEALLOCATE(ReceiveBuffer2)
              IF(ALLOCATED(dofGlobalNumberFromLineLocalNumber)) DEALLOCATE(dofGlobalNumberFromLineLocalNumber)
            ENDDO !component_idx
          ENDIF


          ! compute ghost_finish and number of ghost dofs
          FIELD_VARIABLE_DOFS_MAPPING%GHOST_FINISH = InternalDofIdx-1
          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_GHOST = FIELD_VARIABLE_DOFS_MAPPING%GHOST_FINISH + 1 &
            & - FIELD_VARIABLE_DOFS_MAPPING%GHOST_START

          ! exchange NUMBER_OF_DOMAIN_LOCAL and NUMBER_OF_DOMAIN_GHOST
          ! allocate number_of_domain_local
          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL(0:NumberComputationalNodes-1),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate NUMBER_OF_DOMAIN_LOCAL.",ERR,ERROR,*999)

          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL(MyComputationalNodeNumber) &
            & = FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_LOCAL

          CALL MPI_ALLGATHER(MPI_IN_PLACE,1,MPI_INTEGER,FIELD_VARIABLE_DOFS_MAPPING%&
            & NUMBER_OF_DOMAIN_LOCAL(0:NumberComputationalNodes-1), &
            & 1,MPI_INTEGER,computationalEnvironment%mpiCommunicator,MPI_IERROR)
          CALL MPI_ERROR_CHECK("MPI_ALLGATHER",MPI_IERROR,ERR,ERROR,*999)

          ! allocate number_of_domain_ghost
          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_DOMAIN_GHOST(0:NumberComputationalNodes-1),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate NUMBER_OF_DOMAIN_GHOST.",ERR,ERROR,*999)

          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_DOMAIN_GHOST(MyComputationalNodeNumber) &
            & = FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_GHOST

          CALL MPI_ALLGATHER(MPI_IN_PLACE,1,MPI_INTEGER,FIELD_VARIABLE_DOFS_MAPPING%&
            & NUMBER_OF_DOMAIN_GHOST(0:NumberComputationalNodes-1), &
            & 1,MPI_INTEGER,computationalEnvironment%mpiCommunicator,MPI_IERROR)
          CALL MPI_ERROR_CHECK("MPI_ALLGATHER",MPI_IERROR,ERR,ERROR,*999)





          !No need! We access this %ADJACENT_DOMAIN_PTR and _LIST directly from the decomposition.
          !allocate and assign domainMappings%ADJACENT_DOMAIN_PTR and domainMappings%ADJACENT_DOMAIN_LIST
          !Currently for elements and nodes this is done in DOMAIN_MAPPINGS_LOCAL_FROM_GLOBAL_CALCULATE
          !ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS_PTR(0:ELEMENTS_MAPPING%NUMBER_OF_DOMAINS),STAT=ERR)
          !IF(ERR/=0) CALL FlagError("Could not allocate adjacent domains ptr.",ERR,ERROR,*999)
          !FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS_PTR=ELEMENTS_MAPPING%ADJACENT_DOMAINS_PTR
          !ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS_LIST(ELEMENTS_MAPPING% &
          !  & ADJACENT_DOMAINS_PTR(ELEMENTS_MAPPING%NUMBER_OF_DOMAINS-1)),STAT=ERR)
          !IF(ERR/=0) CALL FlagError("Could not allocate adjacent domains list.",ERR,ERROR,*999)
          !FIELD_VARIABLE_DOFS_MAPPING%ADJACENT_DOMAINS_LIST=ELEMENTS_MAPPING%ADJACENT_DOMAINS_LIST



          ! deallocate used arrays
          IF(ALLOCATED(NumberBreaksNode)) DEALLOCATE(NumberBreaksNode)
          IF(ALLOCATED(NumberBreaksDoubleNode)) DEALLOCATE(NumberBreaksDoubleNode)
          IF(ALLOCATED(RowOffsetNode)) DEALLOCATE(RowOffsetNode)
          IF(ALLOCATED(RowOffsetZeroBasedNode)) DEALLOCATE(RowOffsetZeroBasedNode)
          IF(ALLOCATED(NumberBreaksFace)) DEALLOCATE(NumberBreaksFace)
          IF(ALLOCATED(NumberBreaksDoubleFace)) DEALLOCATE(NumberBreaksDoubleFace)
          IF(ALLOCATED(RowOffsetFace)) DEALLOCATE(RowOffsetFace)
          IF(ALLOCATED(RowOffsetZeroBasedFace)) DEALLOCATE(RowOffsetZeroBasedFace)
          IF(ALLOCATED(NumberBreaksLine)) DEALLOCATE(NumberBreaksLine)
          IF(ALLOCATED(NumberBreaksDoubleLine)) DEALLOCATE(NumberBreaksDoubleLine)
          IF(ALLOCATED(RowOffsetLine)) DEALLOCATE(RowOffsetLine)
          IF(ALLOCATED(RowOffsetZeroBasedLine)) DEALLOCATE(RowOffsetZeroBasedLine)
          IF(ALLOCATED(FirstDofGlobalNo)) DEALLOCATE(FirstDofGlobalNo)
          IF(ALLOCATED(Element1GlobalNo)) DEALLOCATE(Element1GlobalNo)
          IF(ALLOCATED(FirstDofLocalNo)) DEALLOCATE(FirstDofLocalNo)
          IF(ALLOCATED(FirstElementDofIdx)) DEALLOCATE(FirstElementDofIdx)

        ENDDO  ! variable_idx



! -------------------------------------------------



      ELSE
        !This is the old global implementation
        !IF (USE_OLD_GLOBAL_IMPLEMENTATION) THEN


        !Calculate the number of global and local degrees of freedom for the field variables and components. Each field variable
        !component has a set of DOFs so loop over the components for each variable component and count up the DOFs.
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          NUMBER_OF_CONSTANT_DOFS=0
          NUMBER_OF_ELEMENT_DOFS=0
          NUMBER_OF_FACE_DOFS=0
          NUMBER_OF_NODE_DOFS=0
          NUMBER_OF_GRID_POINT_DOFS=0
          NUMBER_OF_GAUSS_POINT_DOFS=0
          NUMBER_OF_DATA_POINT_DOFS=0
          NUMBER_OF_LOCAL_VARIABLE_DOFS=0
          TOTAL_NUMBER_OF_VARIABLE_DOFS=0
          NUMBER_OF_GLOBAL_VARIABLE_DOFS=0
          DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
            FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
            SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              NUMBER_OF_CONSTANT_DOFS=NUMBER_OF_CONSTANT_DOFS+1
              NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+1
              TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+1
              NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+1
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              DOMAIN=>FIELD_COMPONENT%DOMAIN
              DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
              NUMBER_OF_ELEMENT_DOFS=NUMBER_OF_ELEMENT_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
              NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS
              TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
              NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_GLOBAL_ELEMENTS
            CASE(FIELD_FACE_BASED_INTERPOLATION)
              DOMAIN=>FIELD_COMPONENT%DOMAIN
              domainMappings=>DOMAIN%MAPPINGS
              NUMBER_OF_FACE_DOFS=NUMBER_OF_FACE_DOFS+domainMappings%FACES%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+domainMappings%FACES%NUMBER_OF_LOCAL
              TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+domainMappings%FACES%TOTAL_NUMBER_OF_LOCAL
              NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+domainMappings%FACES%NUMBER_OF_GLOBAL
            CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
              !!!!!FIXTHIS
              CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
              !!!!!
              CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
              !!!!!
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              DOMAIN=>FIELD_COMPONENT%DOMAIN
              DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
              NUMBER_OF_NODE_DOFS=NUMBER_OF_NODE_DOFS+DOMAIN_TOPOLOGY%DOFS%TOTAL_NUMBER_OF_DOFS
              NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%DOFS%NUMBER_OF_DOFS
              TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+DOMAIN_TOPOLOGY%DOFS%TOTAL_NUMBER_OF_DOFS
              NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%DOFS%NUMBER_OF_GLOBAL_DOFS
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FlagError("Not implemented.",ERR,ERROR,*999)
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              DOMAIN=>FIELD_COMPONENT%DOMAIN
              DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
              MAX_NGP = -1
              DO element_idx=1,DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS
                BASIS=>DOMAIN_TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%BASIS
                NGP=BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
                MAX_NGP=MAX(MAX_NGP,NGP)
              ENDDO !element_idx
              CALL MPI_ALLREDUCE(MPI_IN_PLACE,MAX_NGP,1,MPI_INTEGER,MPI_MAX,computationalEnvironment%mpiCommunicator,MPI_IERROR)
              CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)
              NUMBER_OF_GAUSS_POINT_DOFS=NUMBER_OF_GAUSS_POINT_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS*MAX_NGP
              NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS*MAX_NGP
              TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS*MAX_NGP
              NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+ &
                & DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_GLOBAL_ELEMENTS*MAX_NGP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              ! Data points do not have domain topology or mappings, since they're the same across all mesh components
              decompositionTopology=>FIELD%DECOMPOSITION%TOPOLOGY
              NUMBER_OF_DATA_POINT_DOFS=NUMBER_OF_DATA_POINT_DOFS+decompositionTopology%dataPoints%totalNumberOfDataPoints
              NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+decompositionTopology%dataPoints%numberOfDataPoints
              TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+decompositionTopology% &
                & dataPoints%totalNumberOfDataPoints
              NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+decompositionTopology%dataPoints% &
                & numberOfGlobalDataPoints
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "// &
                & TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))// &
                & " of variable type  "//TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDDO !component_idx
          !Allocate the DOF to parameters (nodes, elements, gauss, components etc.) maps.
          FIELD%VARIABLES(variable_idx)%NUMBER_OF_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS
          FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS
          FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,TOTAL_NUMBER_OF_VARIABLE_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS
          IF(NUMBER_OF_CONSTANT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(NUMBER_OF_CONSTANT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter constant map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=NUMBER_OF_CONSTANT_DOFS
          ENDIF
          IF(NUMBER_OF_ELEMENT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,NUMBER_OF_ELEMENT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter element map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=NUMBER_OF_ELEMENT_DOFS
          ENDIF
          IF(NUMBER_OF_FACE_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%FACE_DOF2PARAM_MAP(2,NUMBER_OF_FACE_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter face map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_FACE_DOFS=NUMBER_OF_FACE_DOFS
          ENDIF
          IF(NUMBER_OF_NODE_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,NUMBER_OF_NODE_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter node map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=NUMBER_OF_NODE_DOFS
          ENDIF
          IF(NUMBER_OF_GRID_POINT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GRID_POINT_DOF2PARAM_MAP(2,NUMBER_OF_GRID_POINT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter grid point map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS=NUMBER_OF_GRID_POINT_DOFS
          ENDIF
          IF(NUMBER_OF_GAUSS_POINT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
              & GAUSS_POINT_DOF2PARAM_MAP(3,NUMBER_OF_GAUSS_POINT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter Gauss point map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS=NUMBER_OF_GAUSS_POINT_DOFS
          ENDIF
          IF(NUMBER_OF_DATA_POINT_DOFS>0) THEN
            ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(3,NUMBER_OF_DATA_POINT_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate dof to parameter Gauss point map.",ERR,ERROR,*999)
            FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS=NUMBER_OF_DATA_POINT_DOFS
          ENDIF
        ENDDO !variable_idx


        !Allocate the mapping arrays
        DECOMPOSITION=>FIELD%DECOMPOSITION
        ALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate variable local dofs offsets.",ERR,ERROR,*999)
        ALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate variable ghost dofs offsets.",ERR,ERROR,*999)
        !We want to ensure that the ghost DOFs are at the end so loop over the DOFs in two passes. The first pass will process
        !the local DOFs for each variable component and the second pass will process the ghost DOFs for each variable component.
        IF(NumberComputationalNodes==1) THEN
          domain_type_stop=1 !Local only
        ELSE
          domain_type_stop=2 !Local+Ghosts
        ENDIF
        !Calculate the local and global numbers and set up the mappings
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          constant_nyy=0
          element_nyy=0
          face_nyy=0
          node_nyy=0
          grid_point_nyy=0
          Gauss_point_nyy=0
          data_point_nyy=0
          variable_local_ny=0
          FIELD_VARIABLE_DOFS_MAPPING=>FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING
          IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
            ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate variable dofs mapping global to local map.",ERR,ERROR,*999)
            FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_GLOBAL=FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS

            !Allocate hash table
            ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%domainMappingHashes(1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate hash tables.",ERR,ERROR,*999)
            ALLOCATE(hashKeysList(1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate hash keys list.",ERR,ERROR,*999)
            ALLOCATE(hashValuesMatrix(DECOMPOSITION%NUMBER_OF_DOMAINS*3+1, &
              & FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_GLOBAL),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate hashValuesMatrix.",ERR,ERROR,*999)
            hashValuesMatrix=0

            NULLIFY(hashKeysList(1)%PTR)
            CALL LIST_CREATE_START(hashKeysList(1)%PTR,ERR,ERROR,*999)
            CALL LIST_DATA_TYPE_SET(hashKeysList(1)%PTR,LIST_INTG_TYPE,ERR,ERROR,*999)
            CALL LIST_CREATE_FINISH(hashKeysList(1)%PTR,ERR,ERROR,*999)

            ! Define the pointer to the decomposition
            IF(.NOT.ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING%DECOMPOSITION)) THEN
              FIELD_VARIABLE_DOFS_MAPPING%DECOMPOSITION=>FIELD%DECOMPOSITION
            ELSE
              CALL FlagError("FIELD_VARIABLE_DOFS_MAPPING%DECOMPOSITION already associated!",ERR,ERROR,*999)
            END IF

            PRINT *, "Testing field dofs calculation."
            STOP

          ENDIF
          !The ordering of the DOFs with respect to components is arbitrary. Allow for two orderings: The first ordering is that
          !all the DOFs from one component are processed before all the DOFs of the next component. This is known as "separated"
          !component DOF ordering. The second ordering is to process all the components for a particular parameter (e.g., node)
          !and then process all the components for the next parameter. This is known as "contiguous" component DOF ordering.
          !Continguous component ordering only works if each of the components has the same DOF structure. For this reason
          !separate component ordering is the default.
          SELECT CASE(FIELD%VARIABLES(variable_idx)%DOF_ORDER_TYPE)
          CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
            !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
            VARIABLE_GHOST_DOFS_OFFSETS=0
            DO domain_type_idx=1,domain_type_stop
              VARIABLE_GLOBAL_DOFS_OFFSET=0
              VARIABLE_LOCAL_DOFS_OFFSETS=0
              DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                NUMBER_OF_LOCAL=0
                FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  !Only process the non-ghosted dofs for constant interpolation
                  IF(domain_type_idx==1) THEN
                    variable_local_ny=variable_local_ny+1
                    !Allocate and set up global to local domain map for variable mapping
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=1+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=NumberComputationalNodes !Constant is in all domains
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & ERR,ERROR,*999)
                      !A constant dof is mapped to all domains.
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      !Add values and key
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=domain_idx-1
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & 1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)=domain_no
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOMAIN_LOCAL_INTERNAL

                        !This info should be collected in a different way once gtl does not exist any more!
                        !VARIABLE_LOCAL_DOFS_OFFSETS and local numbering most probably WRONG!
                        hashValuesMatrix(domain_idx*3-1:domain_idx*3+1,variable_global_ny)= &
                          & [domain_no,1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no),DOMAIN_LOCAL_INTERNAL]
                      ENDDO !domain_idx
                      CALL LIST_ITEM_ADD (hashKeysList(1)%PTR, variable_global_ny, err, error,*999)
                      hashValuesMatrix(1,variable_global_ny)=NUMBER_OF_DOMAINS
                      !Delete WRITE statements!!!
                      WRITE (*,*) "Constant global ny"
                      WRITE (*,*) variable_global_ny

                    ENDIF !associated dofs mapping
                    constant_nyy=constant_nyy+1
                    !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_CONSTANT_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=constant_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(constant_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=1
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP=variable_local_ny
                    !Adjust the offsets
                    VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+1
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+1
                  ENDIF
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  elementsMapping=>DOMAIN%MAPPINGS%ELEMENTS
                  IF(domain_type_idx==1) THEN
                    !Allocate parameter to dof map for this field variable component
                    DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(DOMAIN_TOPOLOGY%ELEMENTS% &
                      & TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof element map.",ERR,ERROR,*999)
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS= &
                      & DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                    !Handle global dofs domain mapping
                    DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                      !Handle field variable mappings
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                        CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                          & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)

                        !Copy hash of ELEMENTS (global# ny) to field dofs mapping (global# variable_global_ny)
                        CALL HashTable_GetKey(DOFS_MAPPING%domainMappingHashes(1)%PTR, &
                          ny, indexHash, isHashFound, ERR, ERROR, *999)
                        IF (isHashFound) THEN
                          CALL HashTable_GetValue(DOFS_MAPPING%domainMappingHashes(1)%PTR, &
                            & indexHash, hashArray, ERR, ERROR, *999)
                          !Add local offset (probably WRONG) to total local
                          DO domain_idx=1,hashArray(1)
                            domain_no=hashArray(domain_idx*3-1)
                            hashArray(domain_idx*3) = &
                              & hashArray(domain_idx*3)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          END DO
                          hashValuesMatrix(:,variable_global_ny)=hashArray
                          CALL LIST_ITEM_ADD (hashKeysList(1)%PTR, variable_global_ny, err, error,*999)
                          IF (ALLOCATED(hashArray)) DEALLOCATE (hashArray)
                          !Write statements to delete!
                          WRITE (*,*) "Element global ny"
                          WRITE (*,*) variable_global_ny
                        END IF

                        NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_TYPE(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                          & ERR,ERROR,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !ny
                    start_idx=1
                    stop_idx=elementsMapping%NUMBER_OF_LOCAL
                    !Adjust the local and ghost offsets
                    IF(component_idx>1) &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+elementsMapping%NUMBER_OF_DOMAIN_LOCAL
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                      & elementsMapping%NUMBER_OF_DOMAIN_LOCAL+elementsMapping%NUMBER_OF_DOMAIN_GHOST
                  ELSE !domain_type_idx==2 (ghost)
                    !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                    !dofs are at the end of the local dofs.
                    !Adjust the ghost offsets
                    IF(component_idx>1) &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-elementsMapping%NUMBER_OF_DOMAIN_LOCAL
                    DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                      !Adjust variable mapping local numbers
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                        NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)
                          IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                        ENDDO !domain_idx
                        ! Redo for hash:
                        DO domain_idx=1,hashValuesMatrix(1,variable_global_ny) ! number of domains
                          domain_no=hashValuesMatrix(domain_idx*3-1,variable_global_ny)
                          IF(hashValuesMatrix(domain_idx*3+1,variable_global_ny) &
                            & == DOMAIN_LOCAL_GHOST) THEN
                            hashValuesMatrix(domain_idx*3,variable_global_ny) = &
                              & hashValuesMatrix(domain_idx*3,variable_global_ny)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            hashValuesMatrix(domain_idx*3,variable_global_ny) = &
                              & hashValuesMatrix(domain_idx*3,variable_global_ny)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          END IF
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !ny (global)
                    start_idx=elementsMapping%NUMBER_OF_LOCAL+1
                    stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL
                    !Adjust the local offsets
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-elementsMapping%NUMBER_OF_DOMAIN_GHOST
                  ENDIF ! local or ghost
                  !Adjust the global offset
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+elementsMapping%NUMBER_OF_GLOBAL
                  !Handle local dofs domain mapping
                  DO element_idx=start_idx,stop_idx
                    variable_local_ny=variable_local_ny+1
                    element_nyy=element_nyy+1
                    !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_ELEMENT_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=element_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,element_nyy)=element_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,element_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)=variable_local_ny
                  ENDDO !element_idx

                CASE(FIELD_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                  !!!!!
                  CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                  !!!!!
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  DOFS_MAPPING=>DOMAIN%MAPPINGS%DOFS
                  IF(domain_type_idx==1) THEN
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES( &
                      DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof node map (nodes).", &
                      & ERR,ERROR,*999)
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS = &
                      & DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                    !Loop through and allocate number of derivatives for each node in the domain
                    DO node_idx=1,DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                      ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES( &
                        & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof node map (derivatives).", &
                        & ERR,ERROR,*999)
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES = &
                        & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                      DO derivative_idx=1,DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                        ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                          & VERSIONS(DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof node map (versions).", &
                          & ERR,ERROR,*999)
                        FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                          & NUMBER_OF_VERSIONS = DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      ENDDO !derivative_idx
                    ENDDO !node_idx
                    DO ny=1,DOFS_MAPPING%NUMBER_OF_GLOBAL
                      !Handle variable mapping
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                        CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                          & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                        NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_TYPE(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                          & ERR,ERROR,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !ny (global)
                    start_idx=1
                    stop_idx=DOFS_MAPPING%NUMBER_OF_LOCAL
                    !Adjust the local and ghost offsets
                    IF(component_idx>1) &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                      & DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL+DOFS_MAPPING%NUMBER_OF_DOMAIN_GHOST
                  ELSE
                    !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                    !dofs are at the end of the local dofs.
                    !Adjust the ghost offsets
                    IF(component_idx>1) &
                      VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL
                    DO ny=1,DOFS_MAPPING%NUMBER_OF_GLOBAL
                      !Adjust variable mapping local numbers
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                        NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)
                          IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                           ENDIF
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !ny (global)
                    start_idx=DOFS_MAPPING%NUMBER_OF_LOCAL+1
                    stop_idx=DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
                    !Adjust the local offsets
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-DOFS_MAPPING%NUMBER_OF_DOMAIN_GHOST
                  ENDIF
                  !Adjust the global offset
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+DOFS_MAPPING%NUMBER_OF_GLOBAL
                  !Handle local dofs domain mapping
                  DO ny=start_idx,stop_idx
                    variable_local_ny=variable_local_ny+1
                    node_nyy=node_nyy+1
                    version_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(1,ny)
                    derivative_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(2,ny)
                    node_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(3,ny)
                    !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_NODE_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=node_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(1,node_nyy)=version_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(2,node_nyy)=derivative_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(3,node_nyy)=node_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,node_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                      & VERSIONS(version_idx) = variable_local_ny
                  ENDDO !ny
                CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  elementsMapping=>DOMAIN%MAPPINGS%ELEMENTS
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  IF(domain_type_idx==1) THEN ! domain_type_idx==1 --> non ghosts
                    !Allocate parameter to dof map for this field variable component
                    DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                    ! GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(ng,element_idx). The field variable dof number of ng'th Gauss point in the element_idx'th element based parameter for this field variable component.
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(&
                     & MAX_NGP,DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof Gauss point map.",ERR,ERROR,*999)
                    ! this might be wasteful in worst case, but should generally be ok
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS= &
                    &  DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS*MAX_NGP
                    !Handle global dofs domain mapping
                    DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                     DO gp=1,MAX_NGP !
                      !Handle field variable mappings
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny= (ny-1) * MAX_NGP + gp + VARIABLE_GLOBAL_DOFS_OFFSET
                        CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                          & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                        NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_TYPE(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & ERR,ERROR,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          ! elt local number = 1 -> gp local = 1..max_ngp, etc
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & (DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx) - 1) * MAX_NGP + gp  &
                            & + VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ! domain and type same as element
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                     ENDDO ! gp
                    ENDDO !ny
                    start_idx=1
                    stop_idx=elementsMapping%NUMBER_OF_LOCAL
                    !Adjust the local and ghost offsets
                    IF(component_idx>1) &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                      & elementsMapping%NUMBER_OF_DOMAIN_LOCAL*MAX_NGP
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                      & (elementsMapping%NUMBER_OF_DOMAIN_LOCAL+elementsMapping%NUMBER_OF_DOMAIN_GHOST)*MAX_NGP
                  ELSE !domain_type_idx==2 --> ghosts
                    !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                    !dofs are at the end of the local dofs.
                    !Adjust the ghost offsets
                    IF(component_idx>1) &
                      VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                      & elementsMapping%NUMBER_OF_DOMAIN_LOCAL*MAX_NGP
                    DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                     DO gp=1,MAX_NGP !
                      !Adjust variable mapping local numbers
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny= (ny-1) * MAX_NGP + gp + VARIABLE_GLOBAL_DOFS_OFFSET
                        NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)
                          IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                        ENDDO !domain_idx
                      ENDIF
                     ENDDO ! gp
                    ENDDO !ny (global)
                    start_idx=elementsMapping%NUMBER_OF_LOCAL+1
                    stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL
                    !Adjust the local offsets
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                      & elementsMapping%NUMBER_OF_DOMAIN_GHOST*MAX_NGP
                  ENDIF ! 2 passes for normal, ghost
                  !Adjust the global offset
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+elementsMapping%NUMBER_OF_GLOBAL*MAX_NGP
                  !Handle local dofs domain mapping
                  DO element_idx=start_idx,stop_idx
                   DO gp=1,MAX_NGP !
                    variable_local_ny= variable_local_ny+1
                    Gauss_point_nyy  = Gauss_point_nyy+1
                     !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_GAUSS_POINT_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=Gauss_point_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(1,Gauss_point_nyy)=gp
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(2,Gauss_point_nyy)=element_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(3,Gauss_point_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gp,element_idx)=variable_local_ny
                   ENDDO !gp
                  ENDDO !element_idx
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  domain=>FIELD_COMPONENT%DOMAIN
                  elementsMapping=>domain%MAPPINGS%ELEMENTS
                  decompositionTopology=>domain%DECOMPOSITION%TOPOLOGY
                  IF(domain_type_idx==1) THEN ! domain_type_idx==1 -> non ghosts
                    !Allocate parameter to dof map for this field variable component
                    !including both local and ghost data points on this computational domain.
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionTopology% &
                      & dataPoints%totalNumberOfDataPoints),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof data point map.",ERR,ERROR,*999)
                    ! Number of data points
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS= &
                      & decompositionTopology%dataPoints%totalNumberOfDataPoints
                    ALLOCATE(localDataParamCount(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate data point parameter local count.",ERR,ERROR,*999)
                    ALLOCATE(ghostDataParamCount(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate data point parameter ghost count.",ERR,ERROR,*999)
                    localDataParamCount=0
                    ghostDataParamCount(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)=decompositionTopology%dataPoints%numberOfDomainLocal
                    !Looping through global elements and data points in the elements
                    variable_global_ny=VARIABLE_GLOBAL_DOFS_OFFSET
                    DO elementIdx=1,elementsMapping%NUMBER_OF_GLOBAL
                      DO dataPointIdx=1,decompositionTopology%dataPoints%numberOfelementDataPoints(elementIdx)
                        IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                          variable_global_ny=variable_global_ny+1
                          CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                            & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                          NUMBER_OF_DOMAINS=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%NUMBER_OF_DOMAINS
                          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                            & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                          IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                            & ERR,ERROR,*999)
                          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                            & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                          IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                            & ERR,ERROR,*999)
                          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                            & LOCAL_TYPE(NUMBER_OF_DOMAINS),STAT=ERR)
                          IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                            & ERR,ERROR,*999)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                          DO domain_idx=1,NUMBER_OF_DOMAINS
                            domain_no=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%DOMAIN_NUMBER(domain_idx)
                            IF(elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%LOCAL_TYPE(domain_idx)== &
                              & DOMAIN_LOCAL_GHOST) THEN
                              ghostDataParamCount(domain_no)=ghostDataParamCount(domain_no)+1
                              FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & ghostDataParamCount(domain_no)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                            ELSE
                              localDataParamCount(domain_no)=localDataParamCount(domain_no)+1
                              FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & localDataParamCount(domain_no)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                            ENDIF
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                              & elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%DOMAIN_NUMBER(domain_idx)
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                              & elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%LOCAL_TYPE(domain_idx)
                          ENDDO !domain_idx
                        ENDIF
                      ENDDO !dataPointIdx
                    ENDDO !elementIdx
                    IF(ALLOCATED(localDataParamCount)) DEALLOCATE(localDataParamCount)
                    IF(ALLOCATED(ghostDataParamCount)) DEALLOCATE(ghostDataParamCount)
                    start_idx=1 !the start idx for the elements
                    stop_idx=elementsMapping%NUMBER_OF_LOCAL !the end idx for local elements
                    !Adjust the local and ghost offsetsFIELD_VARIABLE_DOFS_MAPPING
                    IF(component_idx>1) THEN
                      VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                        & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                        & decompositionTopology%dataPoints%numberOfDomainLocal
                    ENDIF
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                      & decompositionTopology%dataPoints%numberOfDomainLocal+decompositionTopology%dataPoints%numberOfDomainGhost
                  ELSE  ! domain_type_idx == 2 -> ghosts
                    !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                    !dofs are at the end of the local dofs.
                    !Adjust the ghost offsets
                    IF(component_idx>1) THEN
                      VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                        & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                        & decompositionTopology%dataPoints%numberOfDomainLocal
                    ENDIF
                    !Looping through global elements and data points in the elements
                    variable_global_ny=VARIABLE_GLOBAL_DOFS_OFFSET
                    DO elementIdx=1,elementsMapping%NUMBER_OF_GLOBAL
                      DO dataPointIdx=1,decompositionTopology%dataPoints%numberOfelementDataPoints(elementIdx)
                        IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                          variable_global_ny=variable_global_ny+1
                          NUMBER_OF_DOMAINS=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%NUMBER_OF_DOMAINS
                          DO domain_idx=1,NUMBER_OF_DOMAINS
                            domain_no=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%DOMAIN_NUMBER(domain_idx)
                            IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                              & DOMAIN_LOCAL_GHOST) THEN
                              FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                                & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                                & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                            ELSE
                              FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                                & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                                & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                            ENDIF
                          ENDDO
                        ENDIF
                      ENDDO !dataPointIdx
                    ENDDO !elementIdx
                    !Adjust the local offsets
                    VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                      & decompositionTopology%dataPoints%numberOfDomainGhost
                    start_idx=elementsMapping%NUMBER_OF_LOCAL+1 !The start index for ghost elements
                    stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL !The end index for local elements
                  ENDIF
                  !Adjust the global offset
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+decompositionTopology%dataPoints%&
                    & numberOfGlobalDataPoints
                  !Handle local dofs domain mapping
                  DO elementIdx=start_idx,stop_idx
                    globalElementNumber=elementsMapping%LOCAL_TO_GLOBAL_MAP(elementIdx)
                    DO dataPointIdx=1,decompositionTopology%dataPoints%numberOfelementDataPoints(globalElementNumber)
                      variable_local_ny=variable_local_ny+1 !reinitialise for every field variable, field variable dof idx
                      data_point_nyy=data_point_nyy+1 !reinitialise for every field variable, field variable data point dof idx
                      localDataNumber=decompositionTopology%dataPoints%elementDataPoint(elementIdx)%dataIndices(dataPointIdx)% &
                        & localNumber
                      !Setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_DATA_POINT_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=data_point_nyy
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(1,data_point_nyy)=localDataNumber
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(2,data_point_nyy)=elementIdx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(3,data_point_nyy)=component_idx
                      !Setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(localDataNumber)=variable_local_ny
                    ENDDO !dataPointIdx
                  ENDDO !elementIdx
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "// &
                    & TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                    & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NumberToVString(component_idx,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDDO !component_idx
            ENDDO !domain_type_idx
          CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
            !Handle the case where all components for a particular DOF parameter are processed before all the component of the next
            !parameter.
            VARIABLE_LOCAL_DOFS_OFFSETS=0
            VARIABLE_GLOBAL_DOFS_OFFSET=0
            VARIABLE_GHOST_DOFS_OFFSETS=0
            IF(FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS>=1) THEN
              SELECT CASE(FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                  FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                  variable_local_ny=1+VARIABLE_LOCAL_DOFS_OFFSETS(myComputationalNodeNumber)
                  !Allocate and set up global to local domain map for variable mapping
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    variable_global_ny=1+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                      & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                    NUMBER_OF_DOMAINS=NumberComputationalNodes !Constant is in all domains
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                      & ERR,ERROR,*999)
                    !A constant dof is mapped to all domains.
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=domain_idx-1
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                        & 1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)=domain_no
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                        & DOMAIN_LOCAL_INTERNAL
                    ENDDO !domain_idx
                  ENDIF
                  constant_nyy=constant_nyy+1
                  !Setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_CONSTANT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=constant_nyy
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(constant_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=1
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP=variable_local_ny
                  !Adjust the offsets
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+1
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+1
                ENDDO !component_idx
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                  FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  !Allocate parameter to dof map for this field variable component
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(DOMAIN_TOPOLOGY%ELEMENTS% &
                    & TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof element map.",ERR,ERROR,*999)
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS= &
                    & DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                ENDDO !component_idx
                !Handle global dofs domain mapping
                element_ny=0
                DO ny=1,elementsMapping%NUMBER_OF_GLOBAL ! elementsMapping has not been associated for this case !?!
                  DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                    FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                    DOMAIN=>FIELD_COMPONENT%DOMAIN
                    DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                    !Handle field variable mappings
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      element_ny=element_ny+1
                      variable_global_ny=element_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & ERR,ERROR,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !component_idx
                ENDDO !ny
                !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
                DO domain_type_idx=1,domain_type_stop
                  IF(domain_type_idx==1) THEN
                    start_idx=1
                    stop_idx=elementsMapping%NUMBER_OF_LOCAL
                  ELSE
                    start_idx=elementsMapping%NUMBER_OF_LOCAL+1
                    stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL
                  ENDIF
                  !Handle local dofs domain mapping
                  element_ny=0
                  DO element_idx=start_idx,stop_idx
                    DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                      FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                      element_ny=element_ny+1
                      variable_local_ny=element_ny+VARIABLE_LOCAL_DOFS_OFFSETS(myComputationalNodeNumber)
                      element_nyy=element_nyy+1
                      !Setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_ELEMENT_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=element_nyy
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,element_nyy)=element_idx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,element_nyy)=component_idx
                      !Setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)=variable_local_ny
                    ENDDO !component_idx
                  ENDDO !element_idx
                  !Adjust the offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    &  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                    & elementsMapping%NUMBER_OF_DOMAIN_LOCAL
                  IF(domain_type_idx==1) THEN
                    VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                      & elementsMapping%NUMBER_OF_GLOBAL
                  ENDIF
                ENDDO !domain_type_idx
              CASE(FIELD_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                !!!!!
                CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                !!!!!
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                  FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES), &
                    & STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof node map (nodes).",ERR,ERROR,*999)
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS = &
                    & DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                  !Loop through and allocate number of derivatives for each node in the domain
                  DO node_idx=1,DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES( &
                      & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES),STAT=ERR)
                    IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof node map (derivatives).", &
                      & ERR,ERROR,*999)
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES = &
                      & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                    DO derivative_idx=1,DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                      ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                        & VERSIONS(DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof node map (versions).", &
                        & ERR,ERROR,*999)
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                        NUMBER_OF_VERSIONS = DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                    ENDDO !derivative_idx
                  ENDDO !node_idx
                ENDDO !component_idx
                !Handle global dofs domain mapping
                !Should the contiguous components have an inner groupping for derivatives??? i.e., loop over nodes, components then
                !derivatives????
                node_ny=0
                NUMBER_OF_GLOBAL_DOFS=FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%DOMAIN%MAPPINGS%DOFS%NUMBER_OF_GLOBAL
                DO ny=1,NUMBER_OF_GLOBAL_DOFS
                  DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                    FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                    DOMAIN=>FIELD_COMPONENT%DOMAIN
                    DOFS_MAPPING=>DOMAIN%MAPPINGS%DOFS
                    !Handle variable mapping
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      node_ny=node_ny+1
                      variable_global_ny=node_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                        & ERR,ERROR,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !component_idx
                ENDDO !ny (global)
                !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
                DO domain_type_idx=1,domain_type_stop
                  IF(domain_type_idx==1) THEN
                    start_idx=1
                    stop_idx=DOFS_MAPPING%NUMBER_OF_LOCAL
                  ELSE
                    start_idx=DOFS_MAPPING%NUMBER_OF_LOCAL+1
                    stop_idx=DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
                  ENDIF
                  !Handle local dofs domain mapping
                  node_ny=0
                  DO ny=start_idx,stop_idx
                    DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                      FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                      DOMAIN=>FIELD_COMPONENT%DOMAIN
                      node_ny=node_ny+1
                      variable_local_ny=node_ny+VARIABLE_LOCAL_DOFS_OFFSETS(myComputationalNodeNumber)
                      node_nyy=node_nyy+1
                      version_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(1,ny)
                      derivative_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(2,ny)
                      node_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(3,ny)
                      !Setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_NODE_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=node_nyy
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(1,node_nyy)=version_idx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(2,node_nyy)=derivative_idx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(3,node_nyy)=node_idx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,node_nyy)=component_idx
                      !Setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                        & VERSIONS(version_idx) = variable_local_ny
                    ENDDO !component_idx
                  ENDDO !ny
                  !Adjust the offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                    & DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL
                  IF(domain_type_idx==1) THEN
                    VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                      & DOFS_MAPPING%NUMBER_OF_GLOBAL
                  ENDIF
                ENDDO !domain_type_idx
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                  FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  !>todo find a better way than assuming NGP=MAX_NGP for all elements TODO
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(MAX_NGP,DOMAIN_TOPOLOGY% &
                    & ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                  IF(ERR/=0) CALL FlagError("Could not allocate field component parameter to dof gauss point map (gauss points).", &
                    & ERR,ERROR,*999)
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS= &
                    & MAX_NGP*DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                ENDDO
                !Handle global dofs domain mapping
                element_ny=0
                NUMBER_OF_GLOBAL_DOFS=FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%DOMAIN%MAPPINGS%ELEMENTS%NUMBER_OF_GLOBAL
                DO ny=1,NUMBER_OF_GLOBAL_DOFS
                  DO gauss_point_idx=1,MAX_NGP
                    DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                      FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                      DOMAIN=>FIELD_COMPONENT%DOMAIN
                      DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                      !Handle variable mapping
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        element_ny=element_ny+1
                        variable_global_ny=element_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                        CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                          & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                        NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map domain number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_TYPE(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FlagError("Could not allocate field variable dofs global to local map local type.", &
                          & ERR,ERROR,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                            & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !component_idx
                  ENDDO !gauss_point_idx
                ENDDO !ny (global)
                !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
                DO domain_type_idx=1,domain_type_stop
                  IF(domain_type_idx==1) THEN
                    start_idx=1
                    stop_idx=DOFS_MAPPING%NUMBER_OF_LOCAL
                  ELSE
                    start_idx=DOFS_MAPPING%NUMBER_OF_LOCAL+1
                    stop_idx=DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
                  ENDIF
                  !Handle local dofs domain mapping
                  element_ny=0
                  DO ny=start_idx,stop_idx
                    DO gauss_point_idx=1,MAX_NGP
                      DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                        FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                        DOMAIN=>FIELD_COMPONENT%DOMAIN
                        element_ny=element_ny+1
                        variable_local_ny=element_ny+VARIABLE_LOCAL_DOFS_OFFSETS(myComputationalNodeNumber)
                        node_nyy=node_nyy+1
                        !Setup dof to parameter map
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_GAUSS_POINT_DOF_TYPE
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=node_nyy
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(1,node_nyy)=gauss_point_idx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(2,node_nyy)=ny !element_idx
                        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(3,node_nyy)=component_idx
                        !Setup reverse parameter to dof map
                        FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,ny)= &
                          & variable_local_ny
                      ENDDO !component_idx
                    ENDDO !gauss_point_idx
                  ENDDO !ny
                  !Adjust the offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                    & DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL*MAX_NGP
                  IF(domain_type_idx==1) THEN
                    VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                      & DOFS_MAPPING%NUMBER_OF_GLOBAL*MAX_NGP
                  ENDIF
                ENDDO !domain_type_idx
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FlagError("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The interpolation type of "// &
                  & TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                  & "*",ERR,ERROR))//" is invalid for component number 1 of variable type "//TRIM(NumberToVString( &
                  & FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              CALL FlagError("The field must have at least one component.",ERR,ERROR,*999)
            ENDIF
          CASE DEFAULT
            LOCAL_ERROR="The DOF order type of "//TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%DOF_ORDER_TYPE, &
                & "*",ERR,ERROR))//" is invalid for variable type "//TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)% &
                & VARIABLE_TYPE,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT

          !Compute hash table and local to global
          IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
            !If we created the values needed for the table, create it.
            CALL LIST_NUMBER_OF_ITEMS_GET(hashKeysList(1)%PTR,numberOfHashKeys,ERR,ERROR,*999)
            IF (numberOfHashKeys /=0) THEN
              CALL LIST_DETACH_AND_DESTROY(hashKeysList(1)%PTR,numberOfHashKeys, &
                & hashIntegerArray,ERR,ERROR,*999)

              ALLOCATE(hashKeysArray(numberOfHashKeys))
              hashKeysArray=hashIntegerArray(1:numberOfHashKeys)
              IF(ALLOCATED(hashIntegerArray)) DEALLOCATE(hashIntegerArray)
              ALLOCATE(hashValuesSubMatrix(DECOMPOSITION%NUMBER_OF_DOMAINS*3+1,numberOfHashKeys),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate hashValuesMatrix.",ERR,ERROR,*999)
              hashValuesSubMatrix=0

              hashValuesSubMatrix = hashValuesMatrix(:,hashKeysArray)

              !Finally compute the table
              NULLIFY(FIELD_VARIABLE_DOFS_MAPPING%domainMappingHashes(1)%PTR)
              CALL HashTable_CreateStart(FIELD_VARIABLE_DOFS_MAPPING%domainMappingHashes(1)% &
                & PTR,ERR,ERROR,*999)
              ! define some parameters here if needed
              CALL HashTable_CreateFinish(FIELD_VARIABLE_DOFS_MAPPING%domainMappingHashes(1)% &
                & PTR,ERR,ERROR,*999)

              CALL HashTable_ValuesSetAndInsert(FIELD_VARIABLE_DOFS_MAPPING%domainMappingHashes(1)%PTR, &
                & hashKeysArray,hashValuesSubMatrix, .FALSE., ERR, ERROR, *999)

              IF(ALLOCATED(hashValuesSubMatrix)) DEALLOCATE(hashValuesSubMatrix)
              IF(ALLOCATED(hashKeysArray)) DEALLOCATE(hashKeysArray)
              IF(ALLOCATED(hashValuesMatrix)) DEALLOCATE(hashValuesMatrix)
              IF(ALLOCATED(hashKeysList)) DEALLOCATE(hashKeysList)
            END IF !Hash table computed

            CALL DOMAIN_MAPPINGS_LOCAL_FROM_GLOBAL_CALCULATE(FIELD_VARIABLE_DOFS_MAPPING,ERR,ERROR,*999)
          ENDIF ! dofs mapping associated
        ENDDO !variable_idx
        IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
        IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)

        IF(DIAGNOSTICS1) THEN
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Field DOF mappings:",ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Field user number = ",FIELD%USER_NUMBER,ERR,ERROR,*999)
          CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",FIELD%NUMBER_OF_VARIABLES,ERR,ERROR,*999)
          DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Variable : ",variable_idx,ERR,ERROR,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Variable type = ",FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE, &
              & ERR,ERROR,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of local DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & NUMBER_OF_DOFS,ERR,ERROR,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Total number of local DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & TOTAL_NUMBER_OF_DOFS,ERR,ERROR,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of global DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & NUMBER_OF_GLOBAL_DOFS,ERR,ERROR,*999)
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"    DOF to parameter map:",ERR,ERROR,*999)
            DO variable_local_ny=1,FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      DOF : ",variable_local_ny,ERR,ERROR,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                & DOF_TYPE(:,variable_local_ny),'("        DOF type :",2(X,I8))','(18X,2(X,I8))',ERR,ERROR,*999)
            ENDDO !variable_local_ny
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of constant DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOFs:",ERR,ERROR,*999)
              DO constant_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOF : ",constant_nyy,ERR,ERROR,*999)
                CALL WRITE_STRING_FMT_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          DOF 2 Parameters : ", &
                  & FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(constant_nyy),'(I8)',ERR,ERROR,*999)
              ENDDO !constant_nyy
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of element DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Element DOFs:",ERR,ERROR,*999)
              DO element_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Element DOF : ",element_nyy,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & ELEMENT_DOF2PARAM_MAP(:,element_nyy),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))',ERR,ERROR,*999)
              ENDDO !element_nyy
            END IF ! any element dof

            ! Check hash table for element dofs
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Hash Element DOFs:",ERR,ERROR,*999)
            DO variable_local_ny=1,FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS
              IF (FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny) &
                & == FIELD_ELEMENT_BASED_INTERPOLATION) THEN
                element_nyy= FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(variable_local_ny)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Param2dof map Local Number"// &
                  & " on rank for element-based:", &
                  & variable_local_ny,ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Global Number (=key) for element-based:", &
                  & element_nyy,ERR,ERROR,*999)
                !Error!
                !- local number of dof2param map is CORRECT
                !- local number of ltg map (calculated from gtl map) is WRONG due to wrong offset.
                CALL HashTable_GetKey(FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING &
                  & %domainMappingHashes(1)%PTR, element_nyy, indexHash, isHashFound, ERR, ERROR, *999)
                IF (isHashFound) THEN
                  CALL HashTable_GetValue(FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING% &
                    & domainMappingHashes(1)%PTR, indexHash, hashArray, ERR, ERROR, *999)
                  CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,SIZE(hashArray,1),1,3,hashArray(:), &
                    &'("      El-based On number of domains :",(X,I8))','(28X,3(X,I8))',ERR,ERROR,*999)
                ELSE
                  CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Error! Not found in hash!",ERR,ERROR,*999)
                END IF
              END IF
            END DO

            ! Check hash table for constant dofs
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Hash Const DOFs:",ERR,ERROR,*999)
            !DO element_nyy = 1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS
            DO variable_local_ny=1,FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS
              IF (FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny) &
                & == FIELD_CONSTANT_INTERPOLATION) THEN
                element_nyy= FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(variable_local_ny)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Param2dof map Local Number"// &
                  & " on rank for constant-based:", &
                  & variable_local_ny,ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Global Number (=key) for constant-based:", &
                  & element_nyy,ERR,ERROR,*999)
                CALL HashTable_GetKey(FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING &
                  & %domainMappingHashes(1)%PTR, element_nyy, indexHash, isHashFound, ERR, ERROR, *999)
                IF (isHashFound) THEN
                  CALL HashTable_GetValue(FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING% &
                    & domainMappingHashes(1)%PTR, indexHash, hashArray, ERR, ERROR, *999)
                  CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,SIZE(hashArray,1),1,3,hashArray(:), &
                    &'("     Con-based On number of domains :",(X,I8))','(28X,3(X,I8))',ERR,ERROR,*999)
                ELSE
                  CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Error! Not found in hash!",ERR,ERROR,*999)
                END IF
              END IF
            END DO

            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of face DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_FACE_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_FACE_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Face DOFs:",ERR,ERROR,*999)
              DO faceIdx=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_FACE_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Face DOF : ",faceIdx,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & FACE_DOF2PARAM_MAP(:,faceIdx),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))',ERR,ERROR,*999)
              ENDDO !faceIdx
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of line DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_LINE_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_LINE_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Face DOFs:",ERR,ERROR,*999)
              DO lineIdx=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_LINE_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Line DOF : ",lineIdx,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & LINE_DOF2PARAM_MAP(:,lineIdx),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))',ERR,ERROR,*999)
              ENDDO !lineIdx
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of nodal DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Nodal DOFs:",ERR,ERROR,*999)
              DO node_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Node DOF : ",node_nyy,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,4,4,4,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & NODE_DOF2PARAM_MAP(:,node_nyy),'("          DOF 2 Parameters :",4(X,I8))','(28X,4(X,I8))',ERR,ERROR,*999)
              ENDDO !node_nyy
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of grid point DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Grid point DOFs:",ERR,ERROR,*999)
              DO grid_point_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Grid point DOF : ",grid_point_nyy,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & GRID_POINT_DOF2PARAM_MAP(:,grid_point_nyy),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))', &
                  & ERR,ERROR,*999)
              ENDDO !node_nyy
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of Gauss point DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      Gauss point DOFs:",ERR,ERROR,*999)
              DO Gauss_point_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Gauss point DOF : ",Gauss_point_nyy,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & GAUSS_POINT_DOF2PARAM_MAP(:,Gauss_point_nyy),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
                  & ERR,ERROR,*999)
              ENDDO !node_nyy
            ENDIF
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of data point DOFs = ",FIELD%VARIABLES(variable_idx)% &
              & DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS,ERR,ERROR,*999)
            IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS>0) THEN
              CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"      data point DOFs:",ERR,ERROR,*999)
              DO data_point_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        data point DOF : ",data_point_nyy,ERR,ERROR,*999)
                CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                  & DATA_POINT_DOF2PARAM_MAP(:,data_point_nyy),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
                  & ERR,ERROR,*999)
              ENDDO !node_nyy
            ENDIF
            CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"    Parameter to DOF map:",ERR,ERROR,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",FIELD%VARIABLES(variable_idx)% &
              & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              FIELD_COMPONENT => FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Component : ",component_idx,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of constant parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Constant DOF = ", &
                  & FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP,ERR,ERROR,*999)
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of element parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS>0) THEN
                DO element_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Element : ",element_idx,ERR,ERROR,*999)
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"            Element DOF = ", &
                    & FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx), &
                    & ERR,ERROR,*999)
                ENDDO !element_idx
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of face parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS>0) THEN
                DO faceIdx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%NUMBER_OF_FACE_PARAMETERS
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Face : ",faceIdx,ERR,ERROR,*999)
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Number of Derivatives = ", &
                    & FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(faceIdx)%NUMBER_OF_DERIVATIVES,ERR,ERROR,*999)
                  DO derivative_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(faceIdx)%NUMBER_OF_DERIVATIVES
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Derivative : ",derivative_idx,ERR,ERROR,*999)
                    CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,FIELD_COMPONENT%PARAM_TO_DOF_MAP% &
                      & FACE_PARAM2DOF_MAP%FACES(faceIdx)%DERIVATIVES(derivative_idx)%NUMBER_OF_VERSIONS,8,8,FIELD_COMPONENT% &
                      & PARAM_TO_DOF_MAP%FACE_PARAM2DOF_MAP%FACES(faceIdx)%DERIVATIVES(derivative_idx)%VERSIONS(:), &
                      & '("              Version DOFs :",8(X,I8))','(23X,8(X,I8))',ERR,ERROR,*999)
                  ENDDO !derivative_idx
                ENDDO !faceIdx
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of line parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS>0) THEN
                DO lineIdx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%NUMBER_OF_LINE_PARAMETERS
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Line : ",lineIdx,ERR,ERROR,*999)
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Number of Derivatives = ", &
                    & FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(lineIdx)%NUMBER_OF_DERIVATIVES,ERR,ERROR,*999)
                  DO derivative_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(lineIdx)%NUMBER_OF_DERIVATIVES
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Derivative : ",derivative_idx,ERR,ERROR,*999)
                    CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,FIELD_COMPONENT%PARAM_TO_DOF_MAP% &
                      & LINE_PARAM2DOF_MAP%LINES(lineIdx)%DERIVATIVES(derivative_idx)%NUMBER_OF_VERSIONS,8,8,FIELD_COMPONENT% &
                      & PARAM_TO_DOF_MAP%LINE_PARAM2DOF_MAP%LINES(lineIdx)%DERIVATIVES(derivative_idx)%VERSIONS(:), &
                      & '("              Version DOFs :",8(X,I8))','(23X,8(X,I8))',ERR,ERROR,*999)
                  ENDDO !derivative_idx
                ENDDO !lineIdx
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of node parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS>0) THEN
                DO node_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Node : ",node_idx,ERR,ERROR,*999)
                  CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Number of Derivatives = ", &
                    & FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES,ERR,ERROR,*999)
                  DO derivative_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                    CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"          Derivative : ",derivative_idx,ERR,ERROR,*999)
                    CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,FIELD_COMPONENT%PARAM_TO_DOF_MAP% &
                      & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%NUMBER_OF_VERSIONS,8,8,FIELD_COMPONENT% &
                      & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(:), &
                      & '("              Version DOFs :",8(X,I8))','(23X,8(X,I8))',ERR,ERROR,*999)
                  ENDDO !derivative_idx
                ENDDO !node_idx
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of grid point parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS>0) THEN
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of Gauss point parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS>0) THEN
              ENDIF
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"        Number of data point parameters = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS,ERR,ERROR,*999)
              IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS>0) THEN
              ENDIF
            ENDDO !component_idx
          ENDDO !variable_idx
        ENDIF
      ENDIF !countIfFace, should be select case with USE_NEW_LOCAL_IMPLEMENTATION
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
    IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)

    EXITS("FIELD_MAPPINGS_CALCULATE")
    RETURN
999 IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
    IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)
    IF(ALLOCATED(hashValuesSubMatrix)) DEALLOCATE(hashValuesSubMatrix)
    IF(ALLOCATED(hashKeysArray)) DEALLOCATE(hashKeysArray)
    IF(ALLOCATED(hashValuesMatrix)) DEALLOCATE(hashValuesMatrix)
    IF(ALLOCATED(hashKeysList)) DEALLOCATE(hashKeysList)
    IF(ALLOCATED(hashArray)) DEALLOCATE (hashArray)

    ERRORSEXITS("FIELD_MAPPINGS_CALCULATE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_MAPPINGS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the dofs to parameters mapping for a field varaible and deallocates all memory.
  SUBROUTINE FIELD_DOF_TO_PARAM_MAP_FINALISE(DOF_TO_PARAM_MAP,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE) :: DOF_TO_PARAM_MAP !<The dof to parameter map to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_DOF_TO_PARAM_MAP_FINALISE",ERR,ERROR,*999)

    IF(ALLOCATED(DOF_TO_PARAM_MAP%DOF_TYPE)) DEALLOCATE(DOF_TO_PARAM_MAP%DOF_TYPE)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%GRID_POINT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%GRID_POINT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP)
    DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS=0

    EXITS("FIELD_DOF_TO_PARAM_MAP_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_DOF_TO_PARAM_MAP_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DOF_TO_PARAM_MAP_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the dofs to parameters mappings for a field.
  SUBROUTINE FIELD_DOF_TO_PARAM_MAP_INITIALISE(DOF_TO_PARAM_MAP,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE) :: DOF_TO_PARAM_MAP !<The dof to parameter map to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_DOF_TO_PARAM_MAP_INITIALISE",ERR,ERROR,*999)

    DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS=0

    EXITS("FIELD_DOF_TO_PARAM_MAP_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_DOF_TO_PARAM_MAP_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_DOF_TO_PARAM_MAP_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the geometric field for a field identified by a pointer. \see OpenCMISS::Iron::cmfe_FieldGeometricFieldGet
  SUBROUTINE FIELD_GEOMETRIC_FIELD_GET(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the geometric field for
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<On return, a pointer to the geometric field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_GEOMETRIC_FIELD_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL FlagError("Geometric field is already associated.",ERR,ERROR,*999)
        ELSE
          GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_FIELD_GET")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_FIELD_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_FIELD_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field. \see OpenCMISS::Iron::cmfe_FieldGeometricFieldSet
  SUBROUTINE FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the geometric field for
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_GEOMETRIC_FIELD_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%GEOMETRIC_FIELD_LOCKED) THEN
            LOCAL_ERROR="The geometric field has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD)) THEN
              LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                & " already has a geometric field associated."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ELSE
              IF(ASSOCIATED(FIELD%DECOMPOSITION)) THEN
                IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
                  IF(GEOMETRIC_FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                    IF(GEOMETRIC_FIELD%FIELD_FINISHED) THEN
                      IF(FIELD%DECOMPOSITION%MESH%USER_NUMBER==GEOMETRIC_FIELD%DECOMPOSITION%MESH%USER_NUMBER) THEN
                        SELECT CASE(FIELD%TYPE)
                        CASE(FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
                          FIELD%GEOMETRIC_FIELD=>GEOMETRIC_FIELD
                        CASE(FIELD_GEOMETRIC_TYPE)
                          CALL FlagError("Can not set the geometric field for a geometric field.",ERR,ERROR,*999)
                        CASE DEFAULT
                          LOCAL_ERROR="The field type "//TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))//" is invalid."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        END SELECT
                      ELSE
                        LOCAL_ERROR="The specified field is decomposed on mesh user number "// &
                          & TRIM(NumberToVString(FIELD%DECOMPOSITION%MESH%USER_NUMBER,"*",ERR,ERROR))// &
                          & " and the geometric field is decomposed on mesh user number "// &
                          & TRIM(NumberToVString(GEOMETRIC_FIELD%DECOMPOSITION%MESH%USER_NUMBER,"*",ERR,ERROR))// &
                          & ". The two fields must use the same mesh."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("The specified geometric field has not been finished.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FlagError("The specified geometric field is not a geometric field.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FlagError("Geometric field is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("The field does not have a decomposition associated.",ERR,ERROR,*999)
              ENDIF
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_FIELD_SET")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_FIELD_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_FIELD_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the geometric field for
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%GEOMETRIC_FIELD_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Calculates the geometric parameters (line lengths, areas, volumes, scaling etc.) for a field.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
            CALL Field_GeometricParametersLineLengthsCalculate(FIELD,ERR,ERROR,*999)
          ENDIF
!          IF(FIELD%DECOMPOSITION%CALCULATE_FACES) THEN !temporarily commented out
!            CALL Field_GeometricParametersFaceAreasCalculate(FIELD,ERR,ERROR,*999)
!          ENDIF
          IF(FIELD%DECOMPOSITION%CALCULATE_CENTROIDS) THEN
            CALL Field_GeometricParametersCentroidsCalculate(FIELD,ERR,ERROR,*999)
          ENDIF
          IF(FIELD%DECOMPOSITION%CALCULATE_CENTRE_LENGTHS) THEN
            CALL Field_GeometricParametersCentreLengthsCalculate(FIELD,ERR,ERROR,*999)
          ENDIF
          CALL Field_GeometricParametersElementVolumesCalculate(FIELD,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not a geometric field."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the geometric parameters and deallocates all memory.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FINALISE(GEOMETRIC_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: GEOMETRIC_PARAMETERS !<A pointer to the geometric field parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx
    TYPE(FIELD_TYPE), POINTER :: FIELD2

    ENTERS("FIELD_GEOMETRIC_PARAMETERS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(GEOMETRIC_PARAMETERS)) THEN
      !Nullify the geometric field pointer of those fields using this geometric field.
      DO field_idx=1,GEOMETRIC_PARAMETERS%NUMBER_OF_FIELDS_USING
        FIELD2=>GEOMETRIC_PARAMETERS%FIELDS_USING(field_idx)%PTR
        IF(ASSOCIATED(FIELD2)) NULLIFY(FIELD2%GEOMETRIC_FIELD)
      ENDDO !field_idx
      IF(ASSOCIATED(GEOMETRIC_PARAMETERS%FIELDS_USING)) DEALLOCATE(GEOMETRIC_PARAMETERS%FIELDS_USING)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%LENGTHS)) DEALLOCATE(GEOMETRIC_PARAMETERS%LENGTHS)
!      IF(ALLOCATED(GEOMETRIC_PARAMETERS%AREAS)) DEALLOCATE(GEOMETRIC_PARAMETERS%AREAS) !temporarily commented out
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%VOLUMES)) DEALLOCATE(GEOMETRIC_PARAMETERS%VOLUMES)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%CENTROID_POSITION)) DEALLOCATE(GEOMETRIC_PARAMETERS%CENTROID_POSITION)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%HALFLENGTH)) DEALLOCATE(GEOMETRIC_PARAMETERS%HALFLENGTH)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%CENTRE_TO_CENTRE_VEC)) DEALLOCATE(GEOMETRIC_PARAMETERS%CENTRE_TO_CENTRE_VEC)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%SURFACE_VECTOR)) DEALLOCATE(GEOMETRIC_PARAMETERS%SURFACE_VECTOR)
      DEALLOCATE(GEOMETRIC_PARAMETERS)
    ENDIF

    EXITS("FIELD_GEOMETRIC_PARAMETERS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_GEOMETRIC_PARAMETERS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the geometric parameters for a geometric field
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx
    TYPE(FIELD_PTR_TYPE), POINTER :: NEW_FIELDS_USING(:)

    NULLIFY(NEW_FIELDS_USING)

    ENTERS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        !Field is a geometric field
        ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate geometric field parameters.",ERR,ERROR,*999)
        IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
          FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_LINES=FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES
          !Also lengths of adjacent lines must be computed, then allocate to total number of lines.
          !This fixes the error for Hermite elements at (computation of scalings):
          !LENGTH2=LENGTH2+GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(adjacent_local_node_line_idx)
          !since lines adjacent to a node could be ghost lines.
          !ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_LINES),STAT=ERR)
          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(FIELD%DECOMPOSITION%TOPOLOGY%LINES%TOTAL_NUMBER_OF_LINES), &
            & STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate lengths.",ERR,ERROR,*999)
          FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS=0.0_DP
        ENDIF
!        IF(FIELD%DECOMPOSITION%CALCULATE_FACES) THEN !temporarily commented out
!          FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_AREAS=FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES
!          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%AREAS(FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_AREAS),STAT=ERR)
!          IF(ERR/=0) CALL FlagError("Could not allocate areas.",ERR,ERROR,*999)
!          FIELD%GEOMETRIC_FIELD_PARAMETERS%AREAS=0.0_DP
!        ENDIF
        FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_VOLUMES=FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS
        ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%VOLUMES(FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_VOLUMES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate volumes.",ERR,ERROR,*999)
        IF(FIELD%DECOMPOSITION%CALCULATE_CENTROIDS) THEN
          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS% &
            & TOTAL_NUMBER_OF_ELEMENTS,FIELD%DECOMPOSITION%numberOfDimensions),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate Centroids.",ERR,ERROR,*999)
            FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION=0.0_DP
        ENDIF
        IF(FIELD%DECOMPOSITION%CALCULATE_CENTRE_LENGTHS) THEN
          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%HALFLENGTH(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS% &
            & TOTAL_NUMBER_OF_ELEMENTS,-FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
            & ELEMENTS%ELEMENTS(1)%BASIS%NUMBER_OF_XI_COORDINATES:FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION% &
            & MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS%ELEMENTS(1)%BASIS%NUMBER_OF_XI_COORDINATES, &
            & FIELD%DECOMPOSITION%numberOfDimensions),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate HALFLENGTH.",ERR,ERROR,*999)
          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTRE_TO_CENTRE_VEC(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS% &
            & TOTAL_NUMBER_OF_ELEMENTS,-FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
            & ELEMENTS%ELEMENTS(1)%BASIS%NUMBER_OF_XI_COORDINATES:FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION% &
            & MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS%ELEMENTS(1)%BASIS%NUMBER_OF_XI_COORDINATES, &
            & FIELD%DECOMPOSITION%numberOfDimensions),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate CENTRE_TO_CENTRE_VEC.",ERR,ERROR,*999)
          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%SURFACE_VECTOR(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS% &
            & TOTAL_NUMBER_OF_ELEMENTS,-FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
            & ELEMENTS%ELEMENTS(1)%BASIS%NUMBER_OF_XI_COORDINATES:FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION% &
            & MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS%ELEMENTS(1)%BASIS%NUMBER_OF_XI_COORDINATES, &
            & FIELD%DECOMPOSITION%numberOfDimensions),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate SURFACE_VECTOR.",ERR,ERROR,*999)
          !ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%HALFLINE_VECTOR(FIELD%DECOMPOSITION%numberOfElements &
          !  & , 2*FIELD%DECOMPOSITION%numberOfDimensions, FIELD%DECOMPOSITION%numberOfDimensions),STAT=ERR) !THIS WILL ONLY WORK FOR QUADS

          FIELD%GEOMETRIC_FIELD_PARAMETERS%HALFLENGTH=0.0_DP
          FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTRE_TO_CENTRE_VEC=0.0_DP
          FIELD%GEOMETRIC_FIELD_PARAMETERS%SURFACE_VECTOR=0.0_DP
          FIELD%GEOMETRIC_FIELD_PARAMETERS%VOLUMES=0.0_DP
        ENDIF
        FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_VOLUMES=0

        !The field is a geometric field so it must use itself initiallly
        ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(1),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate fields using.",ERR,ERROR,*999)
        FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(1)%PTR=>FIELD
        FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING=1
      ELSE
        !Field is not a geometric field
        NULLIFY(FIELD%GEOMETRIC_FIELD_PARAMETERS)
        IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD)) THEN
          !Set the geometric field so that it knows that this field is using it
          ALLOCATE(NEW_FIELDS_USING(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1),STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate new fields using.",ERR,ERROR,*999)
          DO field_idx=1,FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
            NEW_FIELDS_USING(field_idx)%PTR=>FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
          ENDDO !field_idx
          NEW_FIELDS_USING(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1)%PTR=>FIELD
          FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING=FIELD%GEOMETRIC_FIELD% &
            & GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)) &
            & DEALLOCATE(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)
          FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING=>NEW_FIELDS_USING
        ELSE
          CALL FlagError("Field does not have a geometric field associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE")
    RETURN
999 IF(ASSOCIATED(NEW_FIELDS_USING)) DEALLOCATE(NEW_FIELDS_USING)
    ERRORSEXITS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number.
  SUBROUTINE Field_GeometricParametersElementLineLengthGet(field,elementNumber,elementLineNumber,lineLength,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the line length for
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: decompositionElement
    TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: domainElement
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: globalLineNumber

    ENTERS("Field_GeometricParametersElementLineLengthGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(field%GEOMETRIC_FIELD_PARAMETERS)) THEN
            !\todo user to global element maps not in OpenCMISS?
            IF(elementNumber>=1.AND.elementNumber<=field%DECOMPOSITION%TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS) THEN
              domainElement=>field%DECOMPOSITION%DOMAIN(field%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                & TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              decompositionElement=>field%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              IF(elementLineNumber>=1.AND.elementLineNumber<=domainElement%BASIS%NUMBER_OF_LOCAL_LINES) THEN
                globalLineNumber=decompositionElement%ELEMENT_LINES(elementLineNumber)
                lineLength=Field%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(globalLineNumber)
              ELSE
                localError="Element basis line number  "//TRIM(NumberToVString(elementNumber,"*",err,error))// &
                  & " is not valid and needs to be >=1 and <="//TRIM(NumberToVString( &
                  & domainElement%BASIS%NUMBER_OF_LOCAL_LINES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="Element number "//TRIM(NumberToVString(elementNumber,"*",err,error))// &
                & " is not present in this fields decomposition"
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" is not a geometric field."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN
999 ERRORS("Field_GeometricParametersElementLineLengthGet",err,error)
    EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementLineLengthGet

  !
  !================================================================================================================================
  !


  !>Gets the volume of  geometric field for a given element number .
  SUBROUTINE Field_GeometricParametersElementVolumeGet(field,elementNumber,elementVolume,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the line length for
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    REAL(DP), INTENT(OUT) :: elementVolume !<The volume of the chosen element number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: decompositionElement
    TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: domainElement
    TYPE(VARYING_STRING) :: localError
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: coordinateSystem
    ENTERS("Field_GeometricParametersElementVolumeGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(field%GEOMETRIC_FIELD_PARAMETERS)) THEN
            !\todo user to global element maps not in OpenCMISS?

            IF(elementNumber>=1.AND.elementNumber<=field%DECOMPOSITION%TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS) THEN
              domainElement=>field%DECOMPOSITION%DOMAIN(field%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                & TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              decompositionElement=>field%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              NULLIFY(coordinateSystem)
              CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
              IF(coordinateSystem%NUMBER_OF_DIMENSIONS.EQ.3) THEN
                elementVolume = field%GEOMETRIC_FIELD_PARAMETERS%VOLUMES(elementNumber)
              ELSE
                localError = "Volumes can only be calculated for 3D elements."
                CALL FlagError(localError,err,error,*999)
              ENDIF

            ELSE
              localError="Element number "//TRIM(NumberToVString(elementNumber,"*",err,error))// &
                & " is not present in this fields decomposition"
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" is not a geometric field."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_GeometricParametersElementVolumeGet")
    RETURN
999 ERRORS("Field_GeometricParametersElementVolumeGet",err,error)
    EXITS("Field_GeometricParametersElementVolumeGet")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementVolumeGet

  !
  !================================================================================================================================
  !

  !>Calculates the element volumes from the parameters of a geometric field.
  SUBROUTINE Field_GeometricParametersElementVolumesCalculate(field,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dummyErr,elementIdx,gaussPointIdx,maxNumberOfGauss,numberOfGaussPoints,order

    REAL(DP) :: elementVolume
    REAL(DP), ALLOCATABLE :: gaussPoints(:,:),gaussWeights(:)
    TYPE(BASIS_TYPE), POINTER:: basis
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: coordinateSystem
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: decompositionElements
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: interpolationParameters(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: interpolatedPoint(:)
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: interpolatedPointMetrics(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: dummyError,localError

    ENTERS("Field_GeometricParametersElementVolumesCalculate",err,error,*996)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*996)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*996)
    ENDIF
    IF(field%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" is not a geometric field."
      CALL FlagError(localError,err,error,*996)
    ENDIF
    IF(.NOT.ASSOCIATED(field%GEOMETRIC_FIELD_PARAMETERS)) THEN
      localError="Geometric parameters are not associated for field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
      CALL FlagError(localError,err,error,*996)
    ENDIF

    NULLIFY(coordinateSystem)
    NULLIFY(interpolationParameters)
    NULLIFY(interpolatedPoint)
    NULLIFY(interpolatedPointMetrics)
    CALL Field_CoordinateSystemGet(field,coordinateSystem,err,error,*999)
    IF(coordinateSystem%NUMBER_OF_DIMENSIONS==3) THEN !only calculate volumes if the object is in 3D
      CALL Field_InterpolationParametersInitialise(field,interpolationParameters,err,error,*999)
      CALL Field_InterpolatedPointsInitialise(interpolationParameters,interpolatedPoint,err,error,*999)
      CALL Field_InterpolatedPointsMetricsInitialise(interpolatedPoint,interpolatedPointMetrics,err,error,*999)
      !Get basis type for the first component of the mesh defined with this geometric field
      NULLIFY(fieldVariable)
      CALL Field_VariableGet(field,FIELD_U_VARIABLE_TYPE,fieldVariable,err,error,*999)
      NULLIFY(decomposition)
      CALL Field_DecompositionGet(field,decomposition,err,error,*999)
      NULLIFY(decompositionTopology)
      CALL Decomposition_TopologyGet(decomposition,decompositionTopology,err,error,*999)
      NULLIFY(decompositionElements)
      CALL DecompositionTopology_ElementsGet(decompositionTopology,decompositionElements,err,error,*999)
      NULLIFY(domain)
      CALL Decomposition_DomainGet(decomposition,0,domain,err,error,*999)
      NULLIFY(domainTopology)
      CALL Domain_TopologyGet(domain,domainTopology,err,error,*999)
      NULLIFY(domainElements)
      CALL DomainTopology_ElementsGet(domainTopology,domainElements,err,error,*999)
      NULLIFY(basis)
      CALL DomainElements_BasisGet(domainElements,1,basis,err,error,*999)
      !Allocate Gauss points
      order=2
      maxNumberOfGauss=order*order*order
      ALLOCATE(gaussPoints(3,maxNumberOfGauss),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocated gauss points.",err,error,*999)
      ALLOCATE(gaussWeights(maxNumberOfGauss),STAT=err)
      IF(err/=0) CALL FlagError("Could not allocated gauss weights.",err,error,*999)
      !Calculate Gauss points
      CALL Basis_GaussPointsCalculate(basis,order,3,numberOfGaussPoints,gaussPoints,gaussWeights,err,error,*999)
      !Loop over the elements
      DO elementIdx=1,decompositionElements%NUMBER_OF_ELEMENTS
        CALL Field_InterpolationParametersElementGet(FIELD_VALUES_SET_TYPE,elementIdx, &
          & interpolationParameters(FIELD_U_VARIABLE_TYPE)%PTR,err,error,*999)
        elementVolume=0.0_DP
        DO gaussPointIdx=1,numberOfGaussPoints
          CALL Field_InterpolateXi(FIRST_PART_DERIV,gaussPoints(1:3,gaussPointIdx),interpolatedPoint(FIELD_U_VARIABLE_TYPE)%PTR, &
            & err,error,*999)
          CALL Field_InterpolatedPointMetricsCalculate(COORDINATE_JACOBIAN_VOLUME_TYPE, &
            & interpolatedPointMetrics(FIELD_U_VARIABLE_TYPE)%PTR,err,error,*999)
          elementVolume=elementVolume+InterpolatedPointMetrics(FIELD_U_VARIABLE_TYPE)%ptr%jacobian*gaussWeights(gaussPointIdx)
        ENDDO !gaussPointIdx
        field%GEOMETRIC_FIELD_PARAMETERS%volumes(elementIdx)=elementVolume
      ENDDO !elementIdx
      !Finalise
      DEALLOCATE(gaussWeights)
      DEALLOCATE(gaussPoints)
      CALL Field_InterpolatedPointsMetricsFinalise(interpolatedPointMetrics,err,error,*999)
      CALL Field_InterpolatedPointsFinalise(interpolatedPoint,err,error,*999)
      CALL Field_InterpolationParametersFinalise(interpolationParameters,err,error,*999)
    ENDIF

    IF(diagnostics1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Element volumes:",err,error,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of elements = ",decompositionElements%NUMBER_OF_ELEMENTS, &
        & err,error,*999)
      DO elementIdx=1,decompositionElements%NUMBER_OF_ELEMENTS
        CALL WriteStringFmtTwoValue(DIAGNOSTIC_OUTPUT_TYPE,"    Element ",elementIdx,"(I8)"," volume = ",field% &
          & GEOMETRIC_FIELD_PARAMETERS%VOLUMES(elementIdx),"*",err,error,*999)
      ENDDO !elementIdx
    ENDIF

    EXITS("Field_GeometricParametersElementVolumesCalculate")
    RETURN
999 IF(ALLOCATED(gaussWeights)) DEALLOCATE(gaussWeights)
    IF(ALLOCATED(gaussPoints)) DEALLOCATE(gaussPoints)
    IF(ASSOCIATED(interpolatedPointMetrics)) &
      & CALL Field_InterpolatedPointsMetricsFinalise(interpolatedPointMetrics,dummyErr,dummyError,*998)
998 IF(ASSOCIATED(interpolatedPoint)) &
      & CALL Field_InterpolatedPointsFinalise(interpolatedPoint,dummyErr,dummyError,*997)
997 IF(ASSOCIATED(interpolationParameters)) &
      & CALL Field_InterpolationParametersFinalise(interpolationParameters,dummyErr,dummyError,*996)
996 ERRORS("Field_GeometricParametersElementVolumesCalculate",err,error)
    EXITS("Field_GeometricParametersElementVolumesCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersElementVolumesCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the line lengths from the parameters of a geometric field. Old CMISS name LINSCA
  !>https://www.google.com/search?client=ubuntu&channel=fs&q=symplectic&ie=utf-8&oe=utf-8
  SUBROUTINE Field_GeometricParametersLineLengthsCalculate(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the line lengths for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,ITERATION_NUMBER,MAXIMUM_DIFFERENCE_LINE,ng,nl
    INTEGER(INTG), PARAMETER :: LINES_MAXIMUM_NUMBER_OF_ITERATIONS=20
    INTEGER(INTG) :: GAUSS_START(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: NUMBER_OF_GAUSS_POINTS=4
    REAL(DP) :: LAST_MAXIMUM_LENGTH_DIFFERENCE,LENGTH_DIFFERENCE,MAXIMUM_LENGTH_DIFFERENCE,XI(1),W,DERIV_NORM,LINE_LENGTH, &
      & OLD_LINE_LENGTH
! Doxygen doesn't like this
!    REAL(DP) :: XIG(10) = [ 0.500000000000000_DP, &
!      &                     0.211324865405187_DP,0.788675134594813_DP, &
!      &                     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
!      &                     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
!    REAL(DP) :: WIG(10) = [ 1.000000000000000_DP, &
!      &                     0.500000000000000_DP,0.500000000000000_DP, &
!      &                     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP,
!      &                     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    REAL(DP) :: XIG(10),WIG(10)
    REAL(DP), PARAMETER :: LINE_INCREMENT_TOLERANCE=CONVERGENCE_TOLERANCE
    LOGICAL :: ITERATE,UPDATE_FIELDS_USING
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    XIG = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    WIG = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]

    NULLIFY(INTERPOLATED_POINT)
    NULLIFY(INTERPOLATION_PARAMETERS)

    ENTERS("Field_GeometricParametersLineLengthsCalculate",ERR,ERROR,*997)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            !Iterate to find the line lengths as the line lengths depend on the scaling factors and vise versa.
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
            ITERATE=.TRUE.
            ITERATION_NUMBER=0
            LAST_MAXIMUM_LENGTH_DIFFERENCE=0.0_DP
            DO WHILE(ITERATE.AND.ITERATION_NUMBER<=LINES_MAXIMUM_NUMBER_OF_ITERATIONS)
              MAXIMUM_LENGTH_DIFFERENCE=0.0_DP
              MAXIMUM_DIFFERENCE_LINE=1
              !Loop over the lines
              !DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES
              !Compute lengths of ghost lines as well.
              DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%TOTAL_NUMBER_OF_LINES
                CALL FIELD_INTERPOLATION_PARAMETERS_LINE_GET(FIELD_VALUES_SET_TYPE,nl, &
                  & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                OLD_LINE_LENGTH=FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(nl)
                LINE_LENGTH=0.0_DP
                !Integrate || dr(xi)/dt || from xi=0 to 1 to determine the arc length.
                DO ng=1,NUMBER_OF_GAUSS_POINTS
                  XI(1)=XIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                  W=WIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI,INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                  CALL COORDINATE_DERIVATIVE_NORM(COORDINATE_SYSTEM,PART_DERIV_S1, &
                    & INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%PTR,DERIV_NORM,ERR,ERROR,*999)
                  LINE_LENGTH=LINE_LENGTH+W*DERIV_NORM
                ENDDO !ng
                FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(nl)=LINE_LENGTH
                LENGTH_DIFFERENCE=ABS(LINE_LENGTH-OLD_LINE_LENGTH)/(1.0_DP+OLD_LINE_LENGTH)
                IF(LENGTH_DIFFERENCE>MAXIMUM_LENGTH_DIFFERENCE) THEN
                  MAXIMUM_LENGTH_DIFFERENCE=LENGTH_DIFFERENCE
                  MAXIMUM_DIFFERENCE_LINE=nl
                ENDIF
              ENDDO !nl
              ITERATE=MAXIMUM_LENGTH_DIFFERENCE>LINE_INCREMENT_TOLERANCE
              IF(ITERATE) THEN
                IF(ITERATION_NUMBER==1) THEN
                  LAST_MAXIMUM_LENGTH_DIFFERENCE=MAXIMUM_LENGTH_DIFFERENCE
                ELSE IF(MAXIMUM_LENGTH_DIFFERENCE<LOOSE_TOLERANCE.AND. &
                  & MAXIMUM_LENGTH_DIFFERENCE>=LAST_MAXIMUM_LENGTH_DIFFERENCE) THEN
                  !Seems to be at a numerical limit
                  ITERATE=.FALSE.
                ELSE
                  LAST_MAXIMUM_LENGTH_DIFFERENCE=MAXIMUM_LENGTH_DIFFERENCE
                ENDIF
              ENDIF
              ITERATION_NUMBER=ITERATION_NUMBER+1
              IF(DIAGNOSTICS2) THEN
                CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Line iteration report:",ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",ITERATION_NUMBER,ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",MAXIMUM_LENGTH_DIFFERENCE, &
                  & ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",LINE_INCREMENT_TOLERANCE, &
                  ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",MAXIMUM_DIFFERENCE_LINE, &
                  ERR,ERROR,*999)
              ENDIF
              IF(.NOT.ITERATE.OR.ITERATION_NUMBER==LINES_MAXIMUM_NUMBER_OF_ITERATIONS) THEN
                UPDATE_FIELDS_USING=.TRUE.
              ELSE
                UPDATE_FIELDS_USING=.FALSE.
              ENDIF
              CALL Field_GeometricParametersScaleFactorsUpdate(FIELD,UPDATE_FIELDS_USING,ERR,ERROR,*999)
            ENDDO !iterate
            CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not a geometric field."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Line lengths:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",ITERATION_NUMBER,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",MAXIMUM_LENGTH_DIFFERENCE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",LINE_INCREMENT_TOLERANCE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",MAXIMUM_DIFFERENCE_LINE,ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of lines = ",FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES, &
        & ERR,ERROR,*999)
      !Include ghosts.
!     DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES
      DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%TOTAL_NUMBER_OF_LINES
        CALL WRITE_STRING_FMT_TWO_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Line ",nl,"(I8)"," length = ",FIELD% &
          & GEOMETRIC_FIELD_PARAMETERS% LENGTHS(nl),"*",ERR,ERROR,*999)
      ENDDO !nl
    ENDIF

    EXITS("Field_GeometricParametersLineLengthsCalculate")
    RETURN
999 IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS, &
      & DUMMY_ERR,DUMMY_ERROR,*997)
997 ERRORS("Field_GeometricParametersLineLengthsCalculate",ERR,ERROR)
    EXITS("Field_GeometricParametersLineLengthsCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersLineLengthsCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the face areas from the parameters of a geometric field.
  SUBROUTINE Field_GeometricParametersFaceAreasCalculate(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    INTEGER(INTG) :: DUMMY_ERR,ng,nf
    INTEGER(INTG) :: GAUSS_START(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: NUMBER_OF_GAUSS_POINTS=4
    REAL(DP) :: XI(1),W,FACE_AREA
    REAL(DP) :: XIG(10),WIG(10)
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: INTERPOLATED_POINT_METRICS(:)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    XIG = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    WIG = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    NULLIFY(INTERPOLATED_POINT)
    NULLIFY(INTERPOLATED_POINT_METRICS)
    NULLIFY(INTERPOLATION_PARAMETERS)

    ENTERS("Field_GeometricParametersFaceAreasCalculate",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
            CALL Field_InterpolatedPointsMetricsInitialise(INTERPOLATED_POINT,INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)

            !Loop over the faces
            DO nf=1,FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES
              CALL FIELD_INTERPOLATION_PARAMETERS_FACE_GET(FIELD_VALUES_SET_TYPE,nf, &
                & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
              FACE_AREA=0.0_DP
              DO ng=1,NUMBER_OF_GAUSS_POINTS
                XI(1)=XIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                W=WIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI,INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                CALL FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(COORDINATE_JACOBIAN_AREA_TYPE, &
                  & INTERPOLATED_POINT_METRICS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                FACE_AREA=FACE_AREA+W*INTERPOLATED_POINT_METRICS(FIELD_U_VARIABLE_TYPE)%PTR%JACOBIAN
              ENDDO !ng
              FIELD%GEOMETRIC_FIELD_PARAMETERS%AREAS(nf)=FACE_AREA
            ENDDO !nf

            CALL Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="Geometric parameters are not associated for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not a geometric field."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Face areas:",ERR,ERROR,*999)
      CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of faces = ",FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES, &
        & ERR,ERROR,*999)
      DO nf=1,FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES
        CALL WRITE_STRING_FMT_TWO_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Face ",nf,"(I8)"," area = ",FIELD% &
          & GEOMETRIC_FIELD_PARAMETERS%AREAS(nf),"*",ERR,ERROR,*999)
      ENDDO !nf
    ENDIF

    EXITS("Field_GeometricParametersFaceAreasCalculate")
    RETURN
999 IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) CALL Field_InterpolatedPointsMetricsFinalise(INTERPOLATED_POINT_METRICS, &
      & DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS, &
      & DUMMY_ERR,DUMMY_ERROR,*999)
    ERRORSEXITS("Field_GeometricParametersFaceAreasCalculate",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersFaceAreasCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the centroids for a field.
  SUBROUTINE Field_GeometricParametersCentroidsCalculate(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the geometric field to calculate the element centroids for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    REAL(DP) :: Node_pos,positionSum
    INTEGER(INTG) :: element_idx,dimension_idx,domainNode,elementNode
    INTEGER(INTG) :: NUMBER_OF_NODES_PER_ELEMENT=4 !Fix this so it extracts this value from the field


    ENTERS("Field_GeometricParametersCentroidsCalculate",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN
            !Loop over the elements
            DO element_idx=1,FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
              Do dimension_idx=1,FIELD%DECOMPOSITION%numberOfDimensions
                positionSum=0
                DO elementNode=1,NUMBER_OF_NODES_PER_ELEMENT
                  domainNode=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS% &
                    & ELEMENTS(element_idx)%ELEMENT_NODES(elementNode)

                  CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1,domainNode, &
                    & dimension_idx,Node_pos,ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number

                  positionSum=positionSum + Node_pos
                ENDDO

                FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(element_idx,dimension_idx)= &
                  & positionSum/NUMBER_OF_NODES_PER_ELEMENT

              ENDDO
            ENDDO
          ENDIF
        ENDIF
      ENDIF
    ENDIF




    EXITS("Field_GeometricParametersCentroidsCalculate")
    RETURN
999 ERRORS("Field_GeometricParametersCentroidsCalculate",ERR,ERROR)
    EXITS("Field_GeometricParametersCentroidsCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersCentroidsCalculate

  !
  !================================================================================================================================
  !

  !>Calculates the lengths from centroid to face and centroid to neighbouring centroids for a field.
  SUBROUTINE Field_GeometricParametersCentreLengthsCalculate(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the geometric field to calculate the CENTRE LENGTHS for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    !REAL(DP) ::

    INTEGER(INTG) :: element_idx,faceElementNodeNumbers(4),faceDomainNodeNumber1,faceDomainNodeNumber2, dimension_idx, &
      & neighbourElement,faceDomainNodeNumber3, faceDomainNodeNumber4, nic, start_nic,localLineNumber, localfaceNumber, &
      & mesh_component_idx, numberOfDimensions
    REAL(DP) :: xVec_centroidP(3)=[0,0,0], xVec_centroidN(3)=[0,0,0],xVec_faceNode1(3)=[0,0,0],xVec_faceNode2(3)=[0,0,0]
    REAL(DP) :: xVec_faceNode4(3)=[0,0,0], faceVec_1_2(3)=[0,0,0], faceVec_1_3(3)=[0,0,0], faceNormal(3)=[0,0,0]
    REAL(DP) :: xVec_faceNode3(3)=[0,0,0], interceptPos(3)=[0,0,0], surfaceVector(3)=[0,0,0]
    REAL(DP) :: faceArea


    ENTERS("Field_GeometricParametersCentreLengthsCalculate",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN

          mesh_component_idx=FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER
          numberOfDimensions = FIELD%DECOMPOSITION%numberOfDimensions

          SELECT CASE(FIELD%DECOMPOSITION%DOMAIN(mesh_component_idx)%PTR%TOPOLOGY% &
            & ELEMENTS%ELEMENTS(mesh_component_idx)%BASIS%TYPE)!Assumes all elements have the same basis
          CASE(BASIS_SIMPLEX_TYPE)
            start_nic=1
          CASE(BASIS_LAGRANGE_HERMITE_TP_TYPE)
            start_nic=-FIELD%DECOMPOSITION%DOMAIN(mesh_component_idx)%PTR%TOPOLOGY%ELEMENTS% &
              & ELEMENTS(mesh_component_idx)%BASIS%NUMBER_OF_XI_COORDINATES
          CASE DEFAULT
            !do nothing
          END SELECT

          !Loop over the elements
          DO element_idx=1,FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
            !iterate first through three negative xi directions then 3 negative xi directions
            DO nic=start_nic,FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION% &
              & MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%BASIS%NUMBER_OF_XI_COORDINATES
              IF(nic==0) CYCLE

              !Find the position of the current element centroid.
              xVec_centroidP(1)=FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(element_idx,1)
              xVec_centroidP(2)=FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(element_idx,2)
              IF(numberOfDimensions==3) THEN
                xVec_centroidP(3)=FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(element_idx,3)
              ENDIF
              !Only find neighbouring centroid if there is an element there.
              IF(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ADJACENT_ELEMENTS(nic)% &
                & NUMBER_OF_ADJACENT_ELEMENTS==1) THEN

                neighbourElement=FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ADJACENT_ELEMENTS(nic)% &
                  & ADJACENT_ELEMENTS(1)

                xVec_centroidN(1)=FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(neighbourElement,1)
                xVec_centroidN(2)=FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(neighbourElement,2)
                IF(numberOfDimensions==3) THEN
                  xVec_centroidN(3)=FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTROID_POSITION(neighbourElement,3)
                ENDIF
              ENDIF





              SELECT CASE(numberOfDimensions)
              CASE(2)
                !CALL Field_2D_NodePositionsOnXiDirectionFaceGet(FIELD,element_idx,nic,xVec_faceNode1,xVec_faceNode2, &
                !  & ,ERR,ERROR,*999)

                localLineNumber=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                  & ELEMENTS%ELEMENTS(element_idx)%BASIS%xiNormalsLocalLine(nic,1)

                faceElementNodeNumbers(1:2)=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                  & ELEMENTS%ELEMENTS(element_idx)%BASIS%NODE_NUMBERS_IN_LOCAL_LINE(:,localLineNumber)

                faceDomainNodeNumber1=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                  & TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ELEMENT_NODES(faceElementNodeNumbers(1))
                faceDomainNodeNumber2=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                  & TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ELEMENT_NODES(faceElementNodeNumbers(2))

                DO dimension_idx=1,numberOfDimensions
                  CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1, &
                    & faceDomainNodeNumber1,dimension_idx,xVec_faceNode1(dimension_idx),ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number
                  CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1, &
                    & faceDomainNodeNumber2,dimension_idx,xVec_faceNode2(dimension_idx),ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number
                ENDDO

                SELECT CASE(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ADJACENT_ELEMENTS(nic)% &
                  & NUMBER_OF_ADJACENT_ELEMENTS)
                CASE(1)
                  CALL LineInterceptLine(xVec_centroidP,xVec_centroidN,xVec_faceNode1,xVec_faceNode2,interceptPos, &
                    & ERR, ERROR, *999)
                CASE(0)
                  interceptPos=(xVec_faceNode1+xVec_faceNode2)/2.0_DP !Unsure if this needs to have a case for SP
                END SELECT
                CALL SurfaceVectorFromTwoPoints(xVec_faceNode1,xVec_faceNode2, xVec_centroidP, surfaceVector, ERR, ERROR, *999)
                FIELD%GEOMETRIC_FIELD_PARAMETERS%SURFACE_VECTOR(element_idx,nic,1)=surfaceVector(1) !Unsure if I can fill a whole vector in one call?
                FIELD%GEOMETRIC_FIELD_PARAMETERS%SURFACE_VECTOR(element_idx,nic,2)=surfaceVector(2)

              CASE(3)

                localfaceNumber=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                  & ELEMENTS%ELEMENTS(element_idx)%BASIS%xiNormalsLocalLine(nic,1)

                SELECT CASE(FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                  & ELEMENTS%ELEMENTS(element_idx)%BASIS%TYPE)
                CASE(BASIS_SIMPLEX_TYPE)
                  faceElementNodeNumbers(1:3)=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                    & ELEMENTS%ELEMENTS(element_idx)%BASIS%NODE_NUMBERS_IN_LOCAL_LINE(:,localLineNumber)
                CASE(BASIS_LAGRANGE_HERMITE_TP_TYPE)
                  faceElementNodeNumbers(1:4)=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                    & ELEMENTS%ELEMENTS(element_idx)%BASIS%NODE_NUMBERS_IN_LOCAL_LINE(:,localLineNumber)
                END SELECT



                faceDomainNodeNumber1=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                  & TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ELEMENT_NODES(faceElementNodeNumbers(1))
                faceDomainNodeNumber2=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                  & TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ELEMENT_NODES(faceElementNodeNumbers(2))
                faceDomainNodeNumber3=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                  & TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ELEMENT_NODES(faceElementNodeNumbers(3))
                IF(FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                  & ELEMENTS%ELEMENTS(element_idx)%BASIS%TYPE==BASIS_LAGRANGE_HERMITE_TP_TYPE) THEN
                  faceDomainNodeNumber4=FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                    & TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ELEMENT_NODES(faceElementNodeNumbers(4))
                ENDIF

                Do dimension_idx=1,numberOfDimensions
                  CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1, &
                    & faceDomainNodeNumber1,dimension_idx,xVec_faceNode1(dimension_idx),ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number
                  CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1, &
                    & faceDomainNodeNumber2,dimension_idx,xVec_faceNode2(dimension_idx),ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number
                  CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1, &
                    & faceDomainNodeNumber3,dimension_idx,xVec_faceNode3(dimension_idx),ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number
                  IF(FIELD%DECOMPOSITION%DOMAIN(FIELD%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
                    & ELEMENTS%ELEMENTS(element_idx)%BASIS%TYPE==BASIS_LAGRANGE_HERMITE_TP_TYPE) THEN
                    CALL Field_ParameterSetGetLocalNode(FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,1,1, &
                      & faceDomainNodeNumber4,dimension_idx,xVec_faceNode4(dimension_idx),ERR,ERROR,*999) !not sure if the two 1 values are correct, they are for version number and derivative number
                  ENDIF
                ENDDO


                faceVec_1_2=xVec_faceNode1-xVec_faceNode2
                faceVec_1_3=xVec_faceNode1-xVec_faceNode3
                CALL NormaliseCrossProduct(faceVec_1_2, faceVec_1_3, faceNormal, ERR, ERROR, *999)
                SELECT CASE(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ADJACENT_ELEMENTS(nic) &
                  & %NUMBER_OF_ADJACENT_ELEMENTS)
                CASE(1)
                  CALL LineInterceptPlane(faceNormal, xVec_faceNode1, xVec_centroidP, xVec_centroidN, &
                    & interceptPos, ERR, ERROR, *999) !Make this subroutine in maths.f90
                CASE(0)
                  interceptPos=(xVec_faceNode1+xVec_faceNode2+xVec_faceNode3+xVec_faceNode4)/4.0_DP
                END SELECT


                CALL AreaFromFourPoints(xVec_faceNode1,xVec_faceNode2,xVec_faceNode3,xVec_faceNode4, faceArea, &
                  & ERR, ERROR, *999)
                surfaceVector=faceNormal*faceArea
                FIELD%GEOMETRIC_FIELD_PARAMETERS%SURFACE_VECTOR(element_idx,nic,:)=surfaceVector(:)

              CASE DEFAULT
                !do nothing

              END SELECT


              ! CALL L2Norm(interceptPos-xVec_centroidP,FIELD%GEOMETRIC_FIELD_PARAMETERS%HALFLENGTH(element_idx,nic), &
              !   & err,error,*999)
              FIELD%GEOMETRIC_FIELD_PARAMETERS%HALFLENGTH(element_idx,nic,:) = interceptPos(1:numberOfDimensions) - &
                & xVec_centroidP(1:numberOfDimensions)
              IF(FIELD%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%ADJACENT_ELEMENTS(nic)% &
                & NUMBER_OF_ADJACENT_ELEMENTS==1) THEN
                ! CALL L2Norm(xVec_centroidN-xVec_centroidP, &
                !   & FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTRE_TO_CENTRE_VEC(element_idx,nic),err,error,*999)
                FIELD%GEOMETRIC_FIELD_PARAMETERS%CENTRE_TO_CENTRE_VEC(element_idx,nic,:) = xVec_centroidN(1:numberOfDimensions) - &
                  & xVec_centroidP(1:numberOfDimensions)
              ENDIF

            ENDDO
          ENDDO
        ENDIF
      ENDIF
    ENDIF



    EXITS("Field_GeometricParametersCentreLengthsCalculate")
    RETURN
999 ERRORS("Field_GeometricParametersCentreLengthsCalculate",ERR,ERROR)
    EXITS("Field_GeometricParametersCentreLengthsCalculate")
    RETURN 1

  END SUBROUTINE Field_GeometricParametersCentreLengthsCalculate

  !
  !================================================================================================================
  !

  !>Finalises the geometric parameters for a field and deallocates all memory.
  SUBROUTINE Field_GeometricParametersScaleFactorsUpdate(FIELD,UPDATE_FIELDS_USING,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update the scale factors for
    LOGICAL, INTENT(IN) :: UPDATE_FIELDS_USING !<If .TRUE. then update the fields that use this fields geometric parameters.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx,LAST_FIELD_IDX
    TYPE(FIELD_TYPE), POINTER :: FIELD2

    ENTERS("Field_GeometricParametersScaleFactorsUpdate",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        IF(UPDATE_FIELDS_USING) THEN
          LAST_FIELD_IDX=FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
        ELSE
          LAST_FIELD_IDX=1 !The first field using will be the current field
        ENDIF
        DO field_idx=1,LAST_FIELD_IDX
          FIELD2=>FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
          CALL FIELD_SCALINGS_CALCULATE(FIELD2,ERR,ERROR,*999)
        ENDDO !field_idx
      ELSE
        CALL FlagError("Field is not geometric field.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_GeometricParametersScaleFactorsUpdate")
    RETURN
999 ERRORSEXITS("Field_GeometricParametersScaleFactorsUpdate",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_GeometricParametersScaleFactorsUpdate

  !
  !================================================================================================================================
  !

  !>Gets the field label for a field for character labels. \see OpenCMISS::Iron::cmfe_FieldLabelGet
  SUBROUTINE FIELD_LABEL_GET_C(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field label for the specified field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_LABEL_GET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        C_LENGTH=LEN(LABEL)
        VS_LENGTH=LEN_TRIM(FIELD%LABEL)
        IF(C_LENGTH>VS_LENGTH) THEN
          LABEL=CHAR(LEN_TRIM(FIELD%LABEL))
        ELSE
          LABEL=CHAR(FIELD%LABEL,C_LENGTH)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_GET_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the field label for a field for varying string labels. \see OpenCMISS::Iron::cmfe_FieldLabelGet
  SUBROUTINE FIELD_LABEL_GET_VS(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field label for the specified field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_LABEL_GET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LABEL=FIELD%LABEL
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_GET_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels. \see OpenCMISS::Iron::cmfe_FieldLabelSet
  SUBROUTINE FIELD_LABEL_SET_C(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_LABEL_SET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED) THEN
            LOCAL_ERROR="The field label has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            FIELD%LABEL=LABEL
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_C

 !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels. \see OpenCMISS::Iron::cmfe_FieldLabelSet
  SUBROUTINE FIELD_LABEL_SET_VS(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_LABEL_SET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED) THEN
            LOCAL_ERROR="The field label has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            FIELD%LABEL=LABEL
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels and locks it so that no further changes can be made.
  SUBROUTINE FIELD_LABEL_SET_AND_LOCK_C(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_LABEL_SET_AND_LOCK_C",ERR,ERROR,*999)

    CALL FIELD_LABEL_SET(FIELD,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_LABEL_SET_AND_LOCK_C")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_AND_LOCK_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels and locks it so that no further changes can be made.
  SUBROUTINE FIELD_LABEL_SET_AND_LOCK_VS(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_LABEL_SET_AND_LOCK_VS",ERR,ERROR,*999)

    CALL FIELD_LABEL_SET(FIELD,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_LABEL_SET_AND_LOCK_VS")
    RETURN
999 ERRORSEXITS("FIELD_LABEL_SET_AND_LOCK_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Gets the mesh decomposition for a field. \see OpenCMISS::Iron::cmfe_FieldMeshDecompositionGet
  SUBROUTINE FIELD_MESH_DECOMPOSITION_GET(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the decomposition for
    TYPE(DECOMPOSITION_TYPE), POINTER :: MESH_DECOMPOSITION !<On return, a pointer to the mesh decomposition for the field. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_MESH_DECOMPOSITION_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(ASSOCIATED(MESH_DECOMPOSITION)) THEN
          CALL FlagError("Mesh decomposition is already associated.",ERR,ERROR,*999)
        ELSE
          NULLIFY(MESH_DECOMPOSITION)
          MESH_DECOMPOSITION=>FIELD%DECOMPOSITION
          IF(.NOT.ASSOCIATED(MESH_DECOMPOSITION)) CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_MESH_DECOMPOSITION_GET")
    RETURN
999 ERRORSEXITS("FIELD_MESH_DECOMPOSITION_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_MESH_DECOMPOSITION_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field. \see OpenCMISS::Iron::cmfe_FieldMeshDecompositionSet
  SUBROUTINE FIELD_MESH_DECOMPOSITION_SET(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the decomposition for
    TYPE(DECOMPOSITION_TYPE), POINTER :: MESH_DECOMPOSITION !<A pointer to the mesh decomposition to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(INTERFACE_TYPE), POINTER :: MESH_INTERFACE,FIELD_INTERFACE
    TYPE(REGION_TYPE), POINTER :: MESH_REGION,FIELD_REGION,PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_MESH_DECOMPOSITION_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%DECOMPOSITION_LOCKED) THEN
            LOCAL_ERROR="The mesh decomposition has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(ASSOCIATED(MESH_DECOMPOSITION)) THEN
              MESH=>MESH_DECOMPOSITION%MESH
              IF(ASSOCIATED(MESH)) THEN
                NULLIFY(MESH_INTERFACE)
                MESH_REGION=>MESH%REGION
                IF(ASSOCIATED(MESH_REGION)) THEN
                  NULLIFY(FIELD_INTERFACE)
                  FIELD_REGION=>FIELD%REGION
                  IF(ASSOCIATED(FIELD_REGION)) THEN
                    IF(MESH_REGION%USER_NUMBER==FIELD_REGION%USER_NUMBER) THEN
                      FIELD%DECOMPOSITION=>MESH_DECOMPOSITION
                    ELSE
                      LOCAL_ERROR="Inconsitent regions. The field is defined on region number "// &
                        & TRIM(NumberToVString(FIELD%REGION%USER_NUMBER,"*",ERR,ERROR))// &
                        & " and the mesh decomposition is defined on region number "//&
                        & TRIM(NumberToVString(MESH_DECOMPOSITION%MESH%REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    FIELD_INTERFACE=>FIELD%INTERFACE
                    IF(ASSOCIATED(FIELD_INTERFACE)) THEN
                      PARENT_REGION=>FIELD_INTERFACE%PARENT_REGION
                      IF(ASSOCIATED(PARENT_REGION)) THEN
                        LOCAL_ERROR="Inconsitent setup. The field is defined on interface number "// &
                          & TRIM(NumberToVString(FIELD_INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
                          & " of parent region number "//TRIM(NumberToVString(PARENT_REGION%USER_NUMBER,"*",ERR,ERROR))// &
                          & " and the mesh decomposition is defined on region number "// &
                          & TRIM(NumberToVString(MESH_REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ELSE
                        CALL FlagError("Field interface has no parent region.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="Region or interface is not associated for field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ENDIF
                ELSE
                  MESH_INTERFACE=>MESH%INTERFACE
                  IF(ASSOCIATED(MESH_INTERFACE)) THEN
                    PARENT_REGION=>MESH_INTERFACE%PARENT_REGION
                    IF(ASSOCIATED(PARENT_REGION)) THEN
                      FIELD_REGION=>FIELD%REGION
                      IF(ASSOCIATED(FIELD_REGION)) THEN
                        LOCAL_ERROR="Inconsitent setup. The field is defined on region number "// &
                          & TRIM(NumberToVString(FIELD_REGION%USER_NUMBER,"*",ERR,ERROR))// &
                          & " and the mesh decomposition is defined on interface number "// &
                          & TRIM(NumberToVString(MESH_INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
                          & " of parent region number "//TRIM(NumberToVString(PARENT_REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ELSE
                        FIELD_INTERFACE=>FIELD%INTERFACE
                        IF(ASSOCIATED(FIELD_INTERFACE)) THEN
                          PARENT_REGION=>FIELD_INTERFACE%PARENT_REGION
                          IF(ASSOCIATED(PARENT_REGION)) THEN
                            IF(MESH_INTERFACE%USER_NUMBER==FIELD_INTERFACE%USER_NUMBER) THEN
                              FIELD%DECOMPOSITION=>MESH_DECOMPOSITION
                            ELSE
                              LOCAL_ERROR="Inconsitent interfaces. The field is defined on interface number "// &
                                & TRIM(NumberToVString(FIELD_INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
                                & " of parent region number "// &
                                & TRIM(NumberToVString(PARENT_REGION%USER_NUMBER,"*",ERR,ERROR))// &
                                & " and the mesh decomposition is defined on region number "//&
                                & TRIM(NumberToVString(MESH_REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)

                            ENDIF
                          ELSE
                            CALL FlagError("Field interface parent region is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Region or interface is not associated for field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ENDIF
                    ELSE
                      CALL FlagError("Mesh interface parent region is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Region or interface is not associated for mesh number "// &
                      & TRIM(NumberToVString(MESH%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ENDIF
              ELSE
                CALL FlagError("Mesh is not associated for the mesh decomposition.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FlagError("Mesh decomposition is not assocaited.",ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_MESH_DECOMPOSITION_SET")
    RETURN
999 ERRORSEXITS("FIELD_MESH_DECOMPOSITION_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_MESH_DECOMPOSITION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the decomposition for
    TYPE(DECOMPOSITION_TYPE), POINTER :: MESH_DECOMPOSITION !<A pointer to the mesh decomposition to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DECOMPOSITION_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field. \see OpenCMISS::Iron::cmfe_FieldDataProjectionSet
  SUBROUTINE Field_DataProjectionSet(field,dataProjection,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to set the decomposition for
    TYPE(DataProjectionType), POINTER :: dataProjection !<A pointer to the data projection to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_DataProjectionSet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        localError="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))// &
          & " has been finished."
        CALL FlagError(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(field%CREATE_VALUES_CACHE)) THEN
          IF(field%CREATE_VALUES_CACHE%DataProjectionLocked) THEN
            localError="The data projection has been locked for field number "// &
              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(localError,ERR,ERROR,*999)
          ELSE
            IF(ASSOCIATED(dataProjection)) THEN
              field%DataProjection=>dataProjection
            ELSE
              CALL FlagError("Data projection is not associated.",err,error,*999)
            ENDIF
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_DataProjectionSet")
    RETURN
999 ERRORSEXITS("Field_DataProjectionSet",err,error)
    RETURN 1
  END SUBROUTINE Field_DataProjectionSet

  !
  !================================================================================================================================
  !

  !>Checks the number of field components for a field variable.
  SUBROUTINE Field_NumberOfComponentsCheck(field,variableType,numberOfComponents,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to check the number of components
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !The number of components in the field variable to check
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_NumberOfComponentsCheck",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        IF(field%FIELD_FINISHED) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%NUMBER_OF_COMPONENTS/=numberOfComponents) THEN
              localError="Invalid number of components. The number components for variable type "// &
                & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" is "// &
                & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                & " which does not correspond to the specified number of components of "// &
                & TRIM(NumberToVString(numberOFComponents,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          ENDIF
        ELSE
          !Field has not been finished so check the create values cache.
          IF(ASSOCIATED(field%CREATE_VALUES_CACHE)) THEN
            IF(ALLOCATED(field%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)) THEN
              IF(field%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variableType)/=numberOfComponents) THEN
                fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
                IF(ASSOCIATED(fieldVariable)) THEN
                  localError="Invalid number of components. The number components for variable type "// &
                    & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                    & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" is "// &
                    & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                    & " which does not correspond to the specified number of components of "// &
                    & TRIM(NumberToVString(numberOFComponents,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ELSE
                  localError="Invalid number of components. The number components for variable type "// &
                    & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                    & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
                    & " does not correspond to the specified number of components of "// &
                    & TRIM(NumberToVString(numberOFComponents,"*",err,error))//"."
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ENDIF
            ELSE
              localError="The create values cache number of components is not allocated for field number "// &
                & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
              & " does not have a create values cache associated."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ENDIF
      ELSE
        localError="The supplied variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " is invalid. The field variable type must be > 1 and <= "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_NumberOfComponentsCheck")
    RETURN
999 ERRORSEXITS("Field_NumberOfComponentsCheck",err,error)
    RETURN 1

  END SUBROUTINE Field_NumberOfComponentsCheck

  !
  !================================================================================================================================
  !

  !>Gets the number of field components for a field variable. \see OpenCMISS::Iron::cmfe_FieldNumberOfComponentsGet
  SUBROUTINE Field_NumberOfComponentsGet(field,variableType,numberOfComponents,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the number of components
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_NumberOfComponentsGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        IF(field%FIELD_FINISHED) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%ptr
          IF(ASSOCIATED(fieldVariable)) THEN
            numberOfComponents=fieldVariable%NUMBER_OF_COMPONENTS
          ELSE
            localError="The field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
          ENDIF
        ELSE
          !Field has not been finished so check the create values cache.
          IF(ASSOCIATED(field%CREATE_VALUES_CACHE)) THEN
            IF(ALLOCATED(field%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)) THEN
              numberOfComponents=field%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variableType)
            ELSE
              localError="The create values cache number of components is not allocated for field number "// &
                & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
              & " does not have a create values cache associated."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ENDIF
      ELSE
        localError="The supplied variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
          & " is invalid. The field variable type must be > 1 and <= "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_NumberOfComponentsGet")
    RETURN
999 ERRORSEXITS("Field_NumberOfComponentsGet",err,error)
    RETURN 1
  END SUBROUTINE Field_NumberOfComponentsGet

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable. \see OpenCMISS::Iron::cmfe_FieldNumberOfComponentsSet
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,NEW_NUMBER_OF_COMPONENTS,OLD_NUMBER_OF_COMPONENTS,OVERLAP_NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), ALLOCATABLE :: NEW_INTERPOLATION_TYPE(:,:),NEW_MESH_COMPONENT_NUMBER(:,:)
    LOGICAL, ALLOCATABLE ::NEW_COMPONENT_LABELS_LOCKED(:,:), NEW_INTERPOLATION_TYPE_LOCKED(:,:), &
      & NEW_MESH_COMPONENT_NUMBER_LOCKED(:,:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(VARYING_STRING), ALLOCATABLE :: NEW_COMPONENT_LABELS(:,:)

    ENTERS("FIELD_NUMBER_OF_COMPONENTS_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The number of components has been locked for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE))
                CASE(FIELD_SCALAR_DIMENSION_TYPE)
                  IF(NUMBER_OF_COMPONENTS/=1) THEN
                    LOCAL_ERROR="Scalar fields cannot have "//TRIM(NumberToVString(NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                CASE(FIELD_VECTOR_DIMENSION_TYPE)
                  IF(NUMBER_OF_COMPONENTS>0) THEN
                    IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)/=NUMBER_OF_COMPONENTS) THEN
                      OLD_NUMBER_OF_COMPONENTS=MAXVAL(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)
                      NEW_NUMBER_OF_COMPONENTS=NUMBER_OF_COMPONENTS
                        DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                        IF (FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx) > NEW_NUMBER_OF_COMPONENTS) THEN
                          IF (variable_idx /= VARIABLE_TYPE) THEN
                            NEW_NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx)
                          ENDIF
                        ENDIF
                      ENDDO
                      OVERLAP_NUMBER_OF_COMPONENTS=MIN(OLD_NUMBER_OF_COMPONENTS,NEW_NUMBER_OF_COMPONENTS)
                      ALLOCATE(NEW_COMPONENT_LABELS(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate new component labels.",ERR,ERROR,*999)
                      ALLOCATE(NEW_COMPONENT_LABELS_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate new component labels locked.",ERR,ERROR,*999)
                      ALLOCATE(NEW_INTERPOLATION_TYPE(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate new interpolation type.",ERR,ERROR,*999)
                      ALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate new interpolation type locked.",ERR,ERROR,*999)
                      ALLOCATE(NEW_MESH_COMPONENT_NUMBER(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate new mesh component number.",ERR,ERROR,*999)
                      ALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FlagError("Could not allocate new mesh component number locked.",ERR,ERROR,*999)

                      NEW_COMPONENT_LABELS=''
                      NEW_COMPONENT_LABELS_LOCKED=.FALSE.
                      NEW_INTERPOLATION_TYPE=0
                      NEW_INTERPOLATION_TYPE_LOCKED=.FALSE.
                      NEW_MESH_COMPONENT_NUMBER=0
                      NEW_MESH_COMPONENT_NUMBER_LOCKED=.FALSE.
                      NEW_COMPONENT_LABELS(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_COMPONENT_LABELS_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_INTERPOLATION_TYPE(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_INTERPOLATION_TYPE_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_MESH_COMPONENT_NUMBER(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_MESH_COMPONENT_NUMBER_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      !Update remaining terms
                      IF(OLD_NUMBER_OF_COMPONENTS<NUMBER_OF_COMPONENTS) THEN
                        DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                          DO component_idx=OLD_NUMBER_OF_COMPONENTS+1,NUMBER_OF_COMPONENTS
                            NEW_COMPONENT_LABELS(component_idx,variable_idx)= &
                              & TRIM(NumberToVString(component_idx,"*",ERR,ERROR))
                            IF(ERR/=0) GOTO 999
                          ENDDO
                          NEW_INTERPOLATION_TYPE(OLD_NUMBER_OF_COMPONENTS+1:NUMBER_OF_COMPONENTS,variable_idx) = &
                            & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1,variable_idx)
                          NEW_MESH_COMPONENT_NUMBER(OLD_NUMBER_OF_COMPONENTS+1:NUMBER_OF_COMPONENTS,variable_idx) = &
                            & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1,variable_idx)
                        ENDDO
                      ENDIF

                      CALL MOVE_ALLOC(NEW_COMPONENT_LABELS,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS)
                      CALL MOVE_ALLOC(NEW_COMPONENT_LABELS_LOCKED,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)
                      CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE)
                      CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE_LOCKED,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)
                      CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)
                      CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER_LOCKED,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)

                      FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)=NUMBER_OF_COMPONENTS
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Vector fields cannot have "//TRIM(NumberToVString(NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                CASE(FIELD_TENSOR_DIMENSION_TYPE)
                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="Field dimension "//TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE%DIMENSION( &
                    & VARIABLE_TYPE),"*",ERR,ERROR))//" is not valid."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_COMPONENTS_SET")
    RETURN
999 IF(ALLOCATED(NEW_COMPONENT_LABELS)) DEALLOCATE(NEW_COMPONENT_LABELS)
    IF(ALLOCATED(NEW_COMPONENT_LABELS_LOCKED)) DEALLOCATE(NEW_COMPONENT_LABELS_LOCKED)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE)) DEALLOCATE(NEW_INTERPOLATION_TYPE)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED)
    ERRORSEXITS("FIELD_NUMBER_OF_COMPONENTS_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable and locks so that no further changes can be made.
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the number of variables for a field.
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_CHECK(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables in the specified field to check
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_NUMBER_OF_VARIABLES_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%NUMBER_OF_VARIABLES/=NUMBER_OF_VARIABLES) THEN
          LOCAL_ERROR="Invalid number of variables. The number of variables for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
            & TRIM(NumberToVString(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))// &
            & " which is does correspond to the specified number of variables of "// &
            & TRIM(NumberToVString(NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
       ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_VARIABLES_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the number of variables for a field. \see OpenCMISS::Iron::cmfe_FieldNumberOfVariablesGet
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_GET(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the number of variables for
    INTEGER(INTG), INTENT(OUT) :: NUMBER_OF_VARIABLES !<On return, the number of variables in the specified field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_NUMBER_OF_VARIABLES_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        NUMBER_OF_VARIABLES=FIELD%NUMBER_OF_VARIABLES
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_VARIABLES_GET")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field. \see OpenCMISS::Iron::cmfe_FieldNumberOfVariablesSet
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx,variable_idx2,variable_type
    INTEGER(INTG), ALLOCATABLE :: OLD_VARIABLE_TYPES(:)
    LOGICAL :: FOUND
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_NUMBER_OF_VARIABLES_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_VARIABLES_LOCKED) THEN
            LOCAL_ERROR="The number of variables has been locked field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(NUMBER_OF_VARIABLES>0.AND.NUMBER_OF_VARIABLES<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
              IF(FIELD%NUMBER_OF_VARIABLES/=NUMBER_OF_VARIABLES) THEN
                ALLOCATE(OLD_VARIABLE_TYPES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate old variable types.",ERR,ERROR,*999)
                OLD_VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1: &
                  & FIELD%NUMBER_OF_VARIABLES)
                DEALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES)
                ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(NUMBER_OF_VARIABLES),STAT=ERR)
                IF(ERR/=0) CALL FlagError("Could not allocate variable types.",ERR,ERROR,*999)
                FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES=0
                IF(NUMBER_OF_VARIABLES<FIELD%NUMBER_OF_VARIABLES) THEN
                  FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:NUMBER_OF_VARIABLES)=OLD_VARIABLE_TYPES(1:NUMBER_OF_VARIABLES)
                  DO variable_idx=NUMBER_OF_VARIABLES+1,FIELD%NUMBER_OF_VARIABLES
                    variable_type=OLD_VARIABLE_TYPES(variable_idx)
                    FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)=""
                    FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(:,variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(:,variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(:,variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(:,variable_type)=.FALSE.
                  ENDDO !variable_idx
                ELSE
                  FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)= &
                    & OLD_VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)
                  DO variable_idx=FIELD%NUMBER_OF_VARIABLES+1,NUMBER_OF_VARIABLES
                    !Find the next available variable type
                    DO variable_type=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                      FOUND=.FALSE.
                      DO variable_idx2=1,FIELD%NUMBER_OF_VARIABLES
                        IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(variable_idx2)==variable_type) THEN
                          FOUND=.TRUE.
                          EXIT
                        ENDIF
                      ENDDO !variable_idx2
                      IF(.NOT.FOUND) EXIT
                    ENDDO !variable_type
                    IF(FOUND) THEN
                      CALL FlagError("Could not find free variable type???",ERR,ERROR,*999)
                    ELSE
                      FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(variable_idx)=variable_type
                      SELECT CASE(variable_type)
                      CASE(FIELD_U_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="U"
                      CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del U/del n"
                      CASE(FIELD_DELUDELT_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del U/del t"
                      CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del^2 U/del t^2"
                      CASE(FIELD_V_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="V"
                      CASE(FIELD_DELVDELN_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del V/del n"
                      CASE DEFAULT
                        LOCAL_ERROR="The variable type of "//TRIM(NumberToVString(variable_type,"*",ERR,ERROR))//" is invalid."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      END SELECT
                      FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)=FIELD%CREATE_VALUES_CACHE%DIMENSION( &
                        & OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)=FIELD%CREATE_VALUES_CACHE%DATA_TYPES( &
                        & OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES( &
                        & OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        & NUMBER_OF_COMPONENTS(OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(:,variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        COMPONENT_LABELS(:,FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(OLD_VARIABLE_TYPES(1)))
                      FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(:,variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(:,variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        INTERPOLATION_TYPE(:,FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(OLD_VARIABLE_TYPES(1)))
                      FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(:,variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(:,variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        MESH_COMPONENT_NUMBER(:,FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(OLD_VARIABLE_TYPES(1)))
                      FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(:,variable_type)=.FALSE.
                    ENDIF
                  ENDDO !variable_idx
                ENDIF
                DEALLOCATE(OLD_VARIABLE_TYPES)
                FIELD%NUMBER_OF_VARIABLES=NUMBER_OF_VARIABLES
              ENDIF
            ELSE
              LOCAL_ERROR="The specified number of variables of "//TRIM(NumberToVString(NUMBER_OF_VARIABLES,"*",ERR,ERROR))// &
                & " is invalid. The number of variables must be between 1 and "// &
                & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_VARIABLES_SET")
    RETURN
999 IF(ALLOCATED(OLD_VARIABLE_TYPES)) DEALLOCATE(OLD_VARIABLE_TYPES)
    ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_VARIABLES_LOCKED=.TRUE.

      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add???
  SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP(FIELD,VARIABLE_TYPE,ALPHA,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: ALPHA(:) !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE(:) !<The field parameter set identifier to add the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to add the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx,parameter_set_idx
    REAL(DP) :: VALUE
    TYPE(REAL_DP_PTR_TYPE) :: FIELD_FROM_PARAMETERS(SIZE(FIELD_FROM_SET_TYPE,1))
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_FROM_PARAMETER_SET,FIELD_TO_PARAMETER_SET
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE) :: FIELD_FROM_PARAMETER_SETS(SIZE(FIELD_FROM_SET_TYPE,1))
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SETS_ADD_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the to set type input
            IF(FIELD_TO_SET_TYPE>0.AND.FIELD_TO_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
              FIELD_TO_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_TO_SET_TYPE)%PTR
              IF(ASSOCIATED(FIELD_TO_PARAMETER_SET)) THEN
                IF(SIZE(ALPHA,1)==SIZE(FIELD_FROM_SET_TYPE,1)) THEN
                  DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
                    IF(FIELD_FROM_SET_TYPE(parameter_set_idx)>0.AND. &
                      & FIELD_FROM_SET_TYPE(parameter_set_idx)<FIELD_NUMBER_OF_SET_TYPES) THEN
                      FIELD_FROM_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_FROM_SET_TYPE( &
                      & parameter_set_idx))%PTR
                      IF(ASSOCIATED(FIELD_TO_PARAMETER_SET)) THEN
                        FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%PTR=>FIELD_FROM_PARAMETER_SET
                        NULLIFY(FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR)
                        CALL DistributedVector_DataGet(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%PTR%PARAMETERS, &
                          & FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="The field from set type of "// &
                          & TRIM(NumberToVString(FIELD_FROM_SET_TYPE(parameter_set_idx),"*",ERR,ERROR))// &
                          & " in parameter set index "//TRIM(NumberToVString(parameter_set_idx,"*",ERR,ERROR))// &
                          & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & "."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The field from set type of "// &
                        & TRIM(NumberToVString(FIELD_FROM_SET_TYPE(parameter_set_idx),"*",ERR,ERROR))// &
                        & " for parameter set index "//TRIM(NumberToVString(parameter_set_idx,"*",ERR,ERROR))// &
                        & " is invalid. The field parameter set type must be between 1 and "// &
                        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ENDDO !parameter_set_idx
                  !Do not need to do an update here as each rank already has the values.
                  !Add the field dofs
                  DO dof_idx=1,FIELD_VARIABLE%TOTAL_NUMBER_OF_DOFS
                    VALUE=0.0_DP
                    DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
                      VALUE=VALUE+ALPHA(parameter_set_idx)*FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR(dof_idx)
                    ENDDO !parameter_set_idx
                    CALL DistributedVector_ValuesAdd(FIELD_TO_PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                  ENDDO !dof_idx
                  !Restore the from parameter set transfer
                  DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
                    CALL DistributedVector_DataRestore(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%PTR%PARAMETERS, &
                      & FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR,ERR,ERROR,*999)
                  ENDDO !parameter_set_idx
                ELSE
                  LOCAL_ERROR="The size of the alpha array ("//TRIM(NumberToVString(SIZE(ALPHA,1),"*",ERR,ERROR))// &
                    & ") does not match the size of the from set type array ("// &
                    & TRIM(NumberToVString(SIZE(FIELD_FROM_SET_TYPE,1),"*",ERR,ERROR))//"."
                ENDIF
              ELSE
                LOCAL_ERROR="The field to set type of "//TRIM(NumberToVString(FIELD_TO_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field to set type of "//TRIM(NumberToVString(FIELD_TO_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SETS_ADD_DP")

    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SETS_ADD_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add???
  SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP1(FIELD,VARIABLE_TYPE,ALPHA,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINE
    REAL(DP), INTENT(IN) :: ALPHA !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE !<The field parameter set identifier to add the parameters from
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to add the parameters to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_PARAMETER_SETS_ADD_DP1",ERR,ERROR,*999)

    CALL FIELD_PARAMETER_SETS_ADD_DP(FIELD,VARIABLE_TYPE,[ALPHA],[FIELD_FROM_SET_TYPE],FIELD_TO_SET_TYPE,ERR,ERROR,*999)

    EXITS("FIELD_PARAMETER_SETS_ADD_DP1")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SETS_ADD_DP1",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP1

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type for a field
  SUBROUTINE Field_ParameterSetsCopy(field,variableType,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to copy \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetsCopy",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsCopy(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*999)

    EXITS("Field_ParameterSetsCopy")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsCopy",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsCopy

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type if they exist for a field
  SUBROUTINE Field_ParameterSetsCopyIfExists(field,variableType,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to copy \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetsCopyIfExists",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetsCopyIfExists(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*999)

    EXITS("Field_ParameterSetsCopyIfExists")
    RETURN
999 ERRORSEXITS("Field_ParameterSetsCopyIfExists",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetsCopyIfExists

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  SUBROUTINE Field_ParametersToFieldParametersCopy(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
    & FROM_COMPONENT_NUMBER,TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE,TO_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FROM_FIELD !<A pointer to the field to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_VARIABLE_TYPE !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_PARAMETER_SET_TYPE !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_COMPONENT_NUMBER !<The field variable component number to copy from
    TYPE(FIELD_TYPE), POINTER :: TO_FIELD !<A pointer to the field to copy to
    INTEGER(INTG), INTENT(IN) :: TO_VARIABLE_TYPE !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: TO_PARAMETER_SET_TYPE !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: TO_COMPONENT_NUMBER !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: elem_idx,deriv_idx,version_idx,local_ny,node_idx,VALUE_INTG,gausspoint_idx
    INTEGER(INTG), POINTER :: FROM_PARAMETER_DATA_INTG(:)
    REAL(SP) :: VALUE_SP
    REAL(SP), POINTER :: FROM_PARAMETER_DATA_SP(:)
    REAL(DP) :: VALUE_DP
    REAL(DP), POINTER :: FROM_PARAMETER_DATA_DP(:)
    LOGICAL :: VALUE_L
    LOGICAL, POINTER :: FROM_PARAMETER_DATA_L(:)
    TYPE(DOMAIN_TYPE), POINTER :: FROM_DOMAIN,TO_DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: FROM_DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: FROM_DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: FROM_DOMAIN_TOPOLOGY
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FROM_FIELD_VARIABLE,TO_FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    NULLIFY(FROM_PARAMETER_DATA_INTG)
    NULLIFY(FROM_PARAMETER_DATA_SP)
    NULLIFY(FROM_PARAMETER_DATA_DP)
    NULLIFY(FROM_PARAMETER_DATA_L)

    ENTERS("Field_ParametersToFieldParametersCopy",ERR,ERROR,*999)

    IF(ASSOCIATED(FROM_FIELD)) THEN
      IF(FROM_FIELD%FIELD_FINISHED) THEN
        IF(FROM_VARIABLE_TYPE>0.AND.FROM_VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FROM_FIELD_VARIABLE=>FROM_FIELD%VARIABLE_TYPE_MAP(FROM_VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FROM_FIELD_VARIABLE)) THEN
            IF(FROM_COMPONENT_NUMBER>=1.AND.FROM_COMPONENT_NUMBER<=FROM_FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              IF(ASSOCIATED(TO_FIELD)) THEN
                IF(TO_FIELD%FIELD_FINISHED) THEN
                  IF(TO_VARIABLE_TYPE>0.AND.TO_VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                    TO_FIELD_VARIABLE=>TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR
                    IF(ASSOCIATED(TO_FIELD_VARIABLE)) THEN
                      IF(TO_COMPONENT_NUMBER>=1.AND.TO_COMPONENT_NUMBER<=TO_FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                        FROM_DOMAIN=>FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%DOMAIN
                        TO_DOMAIN=>TO_FIELD_VARIABLE%COMPONENTS(TO_COMPONENT_NUMBER)%DOMAIN
                        IF(ASSOCIATED(FROM_DOMAIN)) THEN
                          IF(ASSOCIATED(FROM_DOMAIN,TO_DOMAIN)) THEN
                            IF(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%INTERPOLATION_TYPE== &
                              & TO_FIELD_VARIABLE%COMPONENTS(TO_COMPONENT_NUMBER)%INTERPOLATION_TYPE) THEN
                              IF(FROM_FIELD_VARIABLE%DATA_TYPE==TO_FIELD_VARIABLE%DATA_TYPE) THEN
                                SELECT CASE(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                                CASE(FIELD_CONSTANT_INTERPOLATION)
                                  SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                  CASE(FIELD_INTG_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_INTG,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                  CASE(FIELD_SP_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_SP,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                  CASE(FIELD_DP_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_DP,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                  CASE(FIELD_L_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_L,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                   CASE DEFAULT
                                    LOCAL_ERROR="The from field variable data type of "// &
                                      & TRIM(NumberToVString(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                      & " is invalid."
                                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                  FROM_DOMAIN_TOPOLOGY=>FROM_DOMAIN%TOPOLOGY
                                  IF(ASSOCIATED(FROM_DOMAIN_TOPOLOGY)) THEN
                                    FROM_DOMAIN_ELEMENTS=>FROM_DOMAIN_TOPOLOGY%ELEMENTS
                                    IF(ASSOCIATED(FROM_DOMAIN_ELEMENTS)) THEN
                                      SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                      CASE(FIELD_INTG_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_INTG,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                      CASE(FIELD_SP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_SP,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                      CASE(FIELD_DP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &

                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_DP,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                      CASE(FIELD_L_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_L,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                      CASE DEFAULT
                                        LOCAL_ERROR="The from field variable data type of "// &
                                          & TRIM(NumberToVString(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                          & " is invalid."
                                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      CALL FlagError("From domain topology elements is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FlagError("From domain topology is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                CASE(FIELD_FACE_BASED_INTERPOLATION)
                                  !!!!!
                                  CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                                  !!!!!
                                CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                                  !!!!!
                                  CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here", &
                                    & ERR,ERROR,*999)
                                  !!!!!
                                CASE(FIELD_LINE_BASED_INTERPOLATION)
                                  !!!!!
                                  CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                                  !!!!!
                                CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                                  !!!!!
                                  CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here", &
                                    & ERR,ERROR,*999)
                                  !!!!!
                                CASE(FIELD_NODE_BASED_INTERPOLATION)
                                  FROM_DOMAIN_TOPOLOGY=>FROM_DOMAIN%TOPOLOGY
                                  IF(ASSOCIATED(FROM_DOMAIN_TOPOLOGY)) THEN
                                    FROM_DOMAIN_NODES=>FROM_DOMAIN_TOPOLOGY%NODES
                                    IF(ASSOCIATED(FROM_DOMAIN_NODES)) THEN
                                      SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                      CASE(FIELD_INTG_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_INTG,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                      CASE(FIELD_SP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_SP,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                      CASE(FIELD_DP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_DP,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                      CASE(FIELD_L_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_L,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                     CASE DEFAULT
                                        LOCAL_ERROR="The from field variable data type of "// &
                                          & TRIM(NumberToVString(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                          & " is invalid."
                                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      CALL FlagError("From domain topology nodes is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FlagError("From domain topology is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                  CALL FlagError("Not implmented.",ERR,ERROR,*999)
                                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                  ! gp based.
                                  FROM_DOMAIN_TOPOLOGY=>FROM_DOMAIN%TOPOLOGY
                                  IF(ASSOCIATED(FROM_DOMAIN_TOPOLOGY)) THEN
                                    FROM_DOMAIN_ELEMENTS=>FROM_DOMAIN_TOPOLOGY%ELEMENTS
                                    IF(ASSOCIATED(FROM_DOMAIN_ELEMENTS)) THEN
                                      SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                      CASE(FIELD_INTG_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                              &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DistributedVector_ValuesSet(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_INTG,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                      CASE(FIELD_SP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                              &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DistributedVector_ValuesSet(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_SP,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                      CASE(FIELD_DP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DistributedVector_ValuesSet(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_DP,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                      CASE(FIELD_L_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                              &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DistributedVector_ValuesSet(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_L,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                      CASE DEFAULT
                                        CALL FlagError("Invalid data type or not implemented.",ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      CALL FlagError("From domain topology elements is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FlagError("From domain topology is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                ! / gp based
                                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                  CALL FlagError("Not implemented.",ERR,ERROR,*999)
                                CASE DEFAULT
                                  LOCAL_ERROR="The from field variable component interpolation type of "// &
                                    & TRIM(NumberToVString(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                    & INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                END SELECT
                              ELSE
                                LOCAL_ERROR="The from field variable data type of "// &
                                  & TRIM(NumberToVString(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                  & " does not match the to variable data type of "// &
                                  & TRIM(NumberToVString(TO_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))//"."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="The from field variable component interpolation type of "// &
                                & TRIM(NumberToVString(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                & INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                & " does not match the to variable component interpolation type of "// &
                                & TRIM(NumberToVString(TO_FIELD_VARIABLE%COMPONENTS(TO_COMPONENT_NUMBER)% &
                                & INTERPOLATION_TYPE,"*",ERR,ERROR))//"."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("The from field variable component domain is not associated with the "// &
                              & "to field variable component domain.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("The from variable component domain is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="To component number "//TRIM(NumberToVString(TO_COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for to variable type "//TRIM(NumberToVString(TO_VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(TO_FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                          & TRIM(NumberToVString(TO_FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                          & " components."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The to field variable type of "//TRIM(NumberToVString(TO_VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " has not been created on field number "//TRIM(NumberToVString(TO_FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The to field variable type of "//TRIM(NumberToVString(TO_VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " is invalid. The variable type must be between 1 and "// &
                      & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="To field number "//TRIM(NumberToVString(TO_FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                    & " has not been finished."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("The to field is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="From component number "//TRIM(NumberToVString(FROM_COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for from variable type "//TRIM(NumberToVString(FROM_VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FROM_FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NumberToVString(FROM_FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The from field variable type of "//TRIM(NumberToVString(FROM_VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FROM_FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The from field variable type of "//TRIM(NumberToVString(FROM_VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="From field number "//TRIM(NumberToVString(FROM_FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("The from field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParametersToFieldParametersCopy")
    RETURN
999 ERRORSEXITS("Field_ParametersToFieldParametersCopy",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_ParametersToFieldParametersCopy


  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user element of the field variable component.\see OpenCMISS::Iron::cmfe_FieldParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &

                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user element of the field variable component.\see OpenCMISS::Iron::cmfe_FieldParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointIntg",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetAddGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointIntg

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(SP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetAddGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointSP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    REAL(DP), INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",err,error,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetAddGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointDP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular Gauss point of a user element of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddGaussPoint
  SUBROUTINE Field_ParameterSetAddGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The Gauss point number in the element to add
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to add
    LOGICAL, INTENT(IN) :: value !<The value to add
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetAddGaussPointL",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",err,error,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesAdd(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetAddGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetAddGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetAddGaussPointL

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*", &
                                  & ERR,ERROR))//" is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_NODE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesAdd(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable. If the field parameter set has already been
  !>created then an error will be raised. \see OpenCMISS::Iron::cmfe_FieldParameterSetCreate
  SUBROUTINE FIELD_PARAMETER_SET_CREATE(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: VARIABLE_TYPE !<The variable type to create the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,parameter_set_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: NEW_PARAMETER_SET
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: NEW_PARAMETER_SETS(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR,DUMMY_ERROR

    NULLIFY(NEW_PARAMETER_SET)
    NULLIFY(NEW_PARAMETER_SETS)

    ENTERS("FIELD_PARAMETER_SET_CREATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          !Check the set type input
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
            !Check if this set type has already been created
            IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE)) THEN
              IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR)) THEN
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " has already been created for variable type of "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDIF
            ALLOCATE(NEW_PARAMETER_SET,STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate new parameter set.",ERR,ERROR,*999)
            CALL FIELD_PARAMETER_SET_INITIALISE(NEW_PARAMETER_SET,ERR,ERROR,*999)
            NEW_PARAMETER_SET%SET_INDEX=FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1
            NEW_PARAMETER_SET%SET_TYPE=FIELD_SET_TYPE
            NULLIFY(NEW_PARAMETER_SET%PARAMETERS)
            CALL DistributedVector_CreateStart(FIELD_VARIABLE%DOMAIN_MAPPING,NEW_PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
            SELECT CASE(FIELD_VARIABLE%DATA_TYPE)
            CASE(FIELD_INTG_TYPE)
              CALL DistributedVector_DataTypeSet(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE, &
                & ERR,ERROR,*999)
            CASE(FIELD_SP_TYPE)
              CALL DistributedVector_DataTypeSet(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_SP_TYPE, &
                & ERR,ERROR,*999)
            CASE(FIELD_DP_TYPE)
              CALL DistributedVector_DataTypeSet(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_DP_TYPE, &
                & ERR,ERROR,*999)
            CASE(FIELD_L_TYPE)
              CALL DistributedVector_DataTypeSet(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_L_TYPE, &
                & ERR,ERROR,*999)
            CASE DEFAULT
              LOCAL_ERROR="The field data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " is invalid for variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
            CALL DistributedVector_CreateFinish(NEW_PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
            SELECT CASE(FIELD_VARIABLE%DATA_TYPE)
            CASE(FIELD_INTG_TYPE)
              CALL DistributedVector_AllValuesSet(NEW_PARAMETER_SET%PARAMETERS,0_INTG,ERR,ERROR,*999)
            CASE(FIELD_SP_TYPE)
              CALL DistributedVector_AllValuesSet(NEW_PARAMETER_SET%PARAMETERS,0.0_SP,ERR,ERROR,*999)
            CASE(FIELD_DP_TYPE)
              CALL DistributedVector_AllValuesSet(NEW_PARAMETER_SET%PARAMETERS,0.0_DP,ERR,ERROR,*999)
            CASE(FIELD_L_TYPE)
              CALL DistributedVector_AllValuesSet(NEW_PARAMETER_SET%PARAMETERS,.FALSE.,ERR,ERROR,*999)
            END SELECT
            !Add the new parameter set to the list of parameter sets
            ALLOCATE(NEW_PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1),STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate new parameter sets.",ERR,ERROR,*999)
            IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)) THEN
              DO parameter_set_idx=1,FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS
                NEW_PARAMETER_SETS(parameter_set_idx)%PTR=>FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR
              ENDDO !parameter_set_idx
              DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)
            ENDIF
            NEW_PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1)%PTR=>NEW_PARAMETER_SET
            ALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1), &
              & STAT=ERR)
            IF(ERR/=0) CALL FlagError("Could not allocate field parameter sets parameter sets.",ERR,ERROR,*999)
            DO parameter_set_idx=1,FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1
              FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR=>NEW_PARAMETER_SETS(parameter_set_idx)%PTR
            ENDDO !parameter_set_idx
            DEALLOCATE(NEW_PARAMETER_SETS)
            FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1
            FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR=>NEW_PARAMETER_SET
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_CREATE")
    RETURN
999 CALL FIELD_PARAMETER_SET_FINALISE(NEW_PARAMETER_SET,DUMMY_ERR,DUMMY_ERROR,*998)
998 IF(ASSOCIATED(NEW_PARAMETER_SETS)) DEALLOCATE(NEW_PARAMETER_SETS)
    ERRORSEXITS("FIELD_PARAMETER_SET_CREATE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_CREATE

  !
  !================================================================================================================================
  !

  !>Checks whether a field parameter set has been created
  SUBROUTINE FIELD_PARAMETER_SET_CREATED(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETER_SET_CREATED,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field
    INTEGER(INTG),  INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check the parameter set creation for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, INTENT(OUT) :: PARAMETER_SET_CREATED
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_CREATED",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          !Check the set type input
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
            !Check if this set type has been created
            IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR)) THEN
              PARAMETER_SET_CREATED=.TRUE.
            ELSE
              PARAMETER_SET_CREATED=.FALSE.
            END IF
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_CREATED")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_CREATED",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_CREATED

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type fieldSetType for a field variable if it does not already exist,
  !>otherwise it will do nothing.
  SUBROUTINE Field_ParameterSetEnsureCreated(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The variable type to create the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    LOGICAL :: parameterSetCreated

    ENTERS("Field_ParameterSetEnsureCreated",err,error,*999)

    CALL FIELD_PARAMETER_SET_CREATED(field,variableType,fieldSetType,parameterSetCreated,err,error,*999)
    IF(.NOT.parameterSetCreated) THEN
      CALL FIELD_PARAMETER_SET_CREATE(field,variableType,fieldSetType,err,error,*999)
    END IF

    EXITS("Field_ParameterSetEnsureCreated")
    RETURN
999 ERRORSEXITS("Field_ParameterSetEnsureCreated",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetEnsureCreated

  !
  !================================================================================================================================
  !

  !>Destroys the parameter set of type set type for a field variable and deallocates all memory. \see OpenCMISS::Iron::cmfe_FieldParameterSetDestroy
  SUBROUTINE FIELD_PARAMETER_SET_DESTROY(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to destroy a parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to destroy the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: parameter_set_idx,SET_INDEX
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: NEW_PARAMETER_SETS(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    NULLIFY(NEW_PARAMETER_SETS)

    ENTERS("FIELD_PARAMETER_SET_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          !Check the set type input
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
            !Check if the set type has been created
            PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
            IF(ASSOCIATED(PARAMETER_SET)) THEN
              SET_INDEX=PARAMETER_SET%SET_INDEX
              ALLOCATE(NEW_PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS-1),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate new parameter sets",ERR,ERROR,*999)
              DO parameter_set_idx=1,FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS
                IF(parameter_set_idx<SET_INDEX) THEN
                  NEW_PARAMETER_SETS(parameter_set_idx)%PTR=>FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR
                ELSE IF(parameter_set_idx>SET_INDEX) THEN
                  NEW_PARAMETER_SETS(parameter_set_idx-1)%PTR=>FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR
                  NEW_PARAMETER_SETS(parameter_set_idx-1)%PTR%SET_INDEX=NEW_PARAMETER_SETS(parameter_set_idx-1)%PTR%SET_INDEX-1
                ENDIF
              ENDDO !parameter_set_idx
              DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)
              FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS=>NEW_PARAMETER_SETS
              FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS-1
              NULLIFY(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR)
              CALL FIELD_PARAMETER_SET_FINALISE(PARAMETER_SET,ERR,ERROR,*999)
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " has not been created for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_PARAMETER_SETS)) DEALLOCATE(NEW_PARAMETER_SETS)
    ERRORSEXITS("FIELD_PARAMETER_SET_DESTROY",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalises the parameter set for a field and deallocates all memory.
  SUBROUTINE FIELD_PARAMETER_SET_FINALISE(FIELD_PARAMETER_SET,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET !<A pointer to the field parameter set to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_PARAMETER_SET_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
      IF(ASSOCIATED(FIELD_PARAMETER_SET%PARAMETERS)) CALL DistributedVector_Destroy(FIELD_PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
      DEALLOCATE(FIELD_PARAMETER_SET)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_FINALISE

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field integer parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FlagError("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the integer data type of the given parameters array."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_GET_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_INTG

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field single precision parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(SP), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FlagError("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the single precision data type of the given parameters array."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_GET_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_SP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field double precision parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FlagError("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given parameters array."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_GET_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_DP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field logical parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_GET_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FlagError("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataGet(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the logical data type of the given parameters array."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_GET_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_GET_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_L

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable integer parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given parameters array."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_INTG

   !
  !================================================================================================================================
  !

  !>Restores the specified field variable single precision parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(SP), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given parameters array."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_SP

   !
  !================================================================================================================================
  !

  !>Restores the specified field variable double precision parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given parameters array."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_DP

   !
  !================================================================================================================================
  !

  !>Restores the specified field variable logical parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OpenCMISS::Iron::cmfe_FieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DistributedVector_DataRestore(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FlagError("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given parameters array."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_DATA_RESTORE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_L

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified parameter set for the field variable.
  SUBROUTINE Field_ParameterSetGet(field,variableType,fieldSetType,parameterSet,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the parameter set for
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to get the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier to get \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet !<On return, a pointer to the specified parameter set. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable

    ENTERS("Field_ParameterSetGet",ERR,ERROR,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) CALL FlagError("Field has not been finished.",err,error,*999)

    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)

    EXITS("Field_ParameterSetGet")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGet",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGet

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)

                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_DP",ERR,ERROR,*999)


    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_CONSTANT_L",ERR,ERROR)

    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetDataPointIntg",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesGet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetGetDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointIntg",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointIntg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetDataPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesGet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetGetDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointSP",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointSP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetDataPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",err,error,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesGet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetGetDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointDP",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetDataPointL",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesGet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetGetDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetDataPointL",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_INTG

  !
  !================================================================================================================================
  !


  !>Returns from the given parameter set a single precision value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)


    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_ELEMENT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Returns the parameter set integer value for a specified local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value of the specified local dof.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Returns the parameter set single precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set double precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set logical value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value of the specified dof.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local face, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalFace_Intg(field,variableType,fieldSetType,versionNumber,derivativeNumber,localFaceNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The face derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The face derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localFaceNumber !<The local face number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_FACES_TYPE), POINTER :: domainFaces
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalFace_Intg",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainFaces=>domainTopology%faces
                          IF(ASSOCIATED(domainFaces)) THEN
                            IF(localFaceNumber>0.AND.localFaceNumber<=domainFaces%TOTAL_NUMBER_OF_FACES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & FACE_PARAM2DOF_MAP%FACES(localFaceNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local face number of "// &
                                & TRIM(NumberToVString(localFaceNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainFaces%TOTAL_NUMBER_OF_FACES,"*",ERR,ERROR))//" local faces."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology faces is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalFace_Intg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalFace_Intg",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalFace_Intg
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local face, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalFace_Sp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localFaceNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The face derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The face derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localFaceNumber !<The local face number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_FACES_TYPE), POINTER :: domainFaces
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalFace_Sp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainFaces=>domainTopology%faces
                          IF(ASSOCIATED(domainFaces)) THEN
                            IF(localFaceNumber>0.AND.localFaceNumber<=domainFaces%TOTAL_NUMBER_OF_FACES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & FACE_PARAM2DOF_MAP%FACES(localFaceNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local face number of "// &
                                & TRIM(NumberToVString(localFaceNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainFaces%TOTAL_NUMBER_OF_FACES,"*",ERR,ERROR))//" local faces."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology faces is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalFace_Sp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalFace_Sp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalFace_Sp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local face, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalFace_Dp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localFaceNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The face derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The face derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localFaceNumber !<The local face number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_FACES_TYPE), POINTER :: domainFaces
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalFace_Dp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainFaces=>domainTopology%faces
                          IF(ASSOCIATED(domainFaces)) THEN
                            IF(localFaceNumber>0.AND.localFaceNumber<=domainFaces%TOTAL_NUMBER_OF_FACES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & FACE_PARAM2DOF_MAP%FACES(localFaceNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local face number of "// &
                                & TRIM(NumberToVString(localFaceNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainFaces%TOTAL_NUMBER_OF_FACES,"*",ERR,ERROR))//" local faces."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology faces is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalFace_Dp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalFace_Dp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalFace_Dp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local face, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalFace_L(field,variableType,fieldSetType,versionNumber,derivativeNumber,localFaceNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The face derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The face derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localFaceNumber !<The local face number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_FACES_TYPE), POINTER :: domainFaces
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalFace_L",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainFaces=>domainTopology%faces
                          IF(ASSOCIATED(domainFaces)) THEN
                            IF(localFaceNumber>0.AND.localFaceNumber<=domainFaces%TOTAL_NUMBER_OF_FACES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & FACE_PARAM2DOF_MAP%FACES(localFaceNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local face number of "// &
                                & TRIM(NumberToVString(localFaceNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainFaces%TOTAL_NUMBER_OF_FACES,"*",ERR,ERROR))//" local faces."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology faces is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by face for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalFace_L")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalFace_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalFace_L


  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local line, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalLine_Intg(field,variableType,fieldSetType,versionNumber,derivativeNumber,localLineNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The line derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The line derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localLineNumber !<The local line number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_LINES_TYPE), POINTER :: domainLines
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalLine_Intg",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainLines=>domainTopology%lines
                          IF(ASSOCIATED(domainLines)) THEN
                            IF(localLineNumber>0.AND.localLineNumber<=domainLines%TOTAL_NUMBER_OF_LINES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & LINE_PARAM2DOF_MAP%LINES(localLineNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local line number of "// &
                                & TRIM(NumberToVString(localLineNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainLines%TOTAL_NUMBER_OF_LINES,"*",ERR,ERROR))//" local lines."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology lines is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalLine_Intg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalLine_Intg",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalLine_Intg
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local line, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalLine_Sp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localLineNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The line derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The line derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localLineNumber !<The local line number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_LINES_TYPE), POINTER :: domainLines
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalLine_Sp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainLines=>domainTopology%lines
                          IF(ASSOCIATED(domainLines)) THEN
                            IF(localLineNumber>0.AND.localLineNumber<=domainLines%TOTAL_NUMBER_OF_LINES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & LINE_PARAM2DOF_MAP%LINES(localLineNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local line number of "// &
                                & TRIM(NumberToVString(localLineNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainLines%TOTAL_NUMBER_OF_LINES,"*",ERR,ERROR))//" local lines."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology lines is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalLine_Sp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalLine_Sp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalLine_Sp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local line, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalLine_Dp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localLineNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The line derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The line derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localLineNumber !<The local line number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_LINES_TYPE), POINTER :: domainLines
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalLine_Dp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainLines=>domainTopology%lines
                          IF(ASSOCIATED(domainLines)) THEN
                            IF(localLineNumber>0.AND.localLineNumber<=domainLines%TOTAL_NUMBER_OF_LINES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & LINE_PARAM2DOF_MAP%LINES(localLineNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local line number of "// &
                                & TRIM(NumberToVString(localLineNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainLines%TOTAL_NUMBER_OF_LINES,"*",ERR,ERROR))//" local lines."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology lines is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalLine_Dp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalLine_Dp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalLine_Dp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local line, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalLine_L(field,variableType,fieldSetType,versionNumber,derivativeNumber,localLineNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The line derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The line derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localLineNumber !<The local line number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_LINES_TYPE), POINTER :: domainLines
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalLine_L",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_NODE_BASED_INTERPOLATION is not implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainLines=>domainTopology%lines
                          IF(ASSOCIATED(domainLines)) THEN
                            IF(localLineNumber>0.AND.localLineNumber<=domainLines%TOTAL_NUMBER_OF_LINES) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & LINE_PARAM2DOF_MAP%LINES(localLineNumber)%derivatives(derivativeNumber)% &
                                & versions(versionNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local line number of "// &
                                & TRIM(NumberToVString(localLineNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainLines%TOTAL_NUMBER_OF_LINES,"*",ERR,ERROR))//" local lines."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology lines is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by line for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalLine_L")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalLine_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalLine_L


  !
  !================================================================================================================================
  !


   !>Returns from the given parameter set a integer value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetNode
 SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_INTG

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetNode
  SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_SP

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetNode
 SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_DP

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetNode
 SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_GET_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DistributedVector_ValuesGet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_GET_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_NODE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_Intg(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalNode_Intg",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NumberToVString(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalNode_Intg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNode_Intg",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_Intg
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_Sp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalNode_Sp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NumberToVString(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalNode_Sp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNode_Sp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_Sp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_Dp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalNode_Dp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NumberToVString(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalNode_Dp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNode_Dp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_Dp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_L(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalNode_L",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NumberToVString(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NumberToVString(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NumberToVString(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalNode_L")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalNode_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_Intg(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalElement_Intg",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION, &
                        FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NumberToVString(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalElement_Intg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElement_Intg",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_Intg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_Sp(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalElement_Sp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION, &
                        FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NumberToVString(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalElement_Sp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElement_Sp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_Sp

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_Dp(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalElement_Dp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION, &
                        FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NumberToVString(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalElement_Dp")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElement_Dp",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_Dp

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_L(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalElement_L",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION, FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION, &
                        FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NumberToVString(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NumberToVString(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalElement_L")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalElement_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a user element of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetGaussPoint
  SUBROUTINE Field_ParameterSetGetGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalElementNumber,dofIdx
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%ptr
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,decompositionLocalElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(gaussPointNumber >= 1 .AND. gaussPointNumber <= SIZE(fieldVariable% & !TODO: check for actual # of gp?
                            & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                            dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,decompositionLocalElementNumber)
                            CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified gauss point number "// &
                              & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                              & " is not within the expected range."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(ComponentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VariableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetGetGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetGaussPointDP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified gauss point of a local element of a field variable component.
  SUBROUTINE Field_ParameterSetGetLocalGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to get the value for
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value of the field parameter set at the Gauss point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetGetLocalGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%ptr
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          IF(ASSOCIATED(decompositionTopology%elements)) THEN
                            IF(localElementNumber>=1.AND. &
                              & localElementNumber<=decompositionTopology%elements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              !!TODO: check for actual # of gp?
                              IF(gaussPointNumber >= 1 .AND. gaussPointNumber <= SIZE(fieldVariable% &
                                & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                                dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                                CALL DistributedVector_ValuesGet(parameterSet%parameters,dofIdx,VALUE,err,error,*999)
                              ELSE
                                localError="The specified gauss point number "// &
                                  & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                  & " is not within the expected range."
                                CALL FlagError(localError,err,error,*999)
                              ENDIF
                            ELSE
                              localError="Local element number "//TRIM(NumberToVString(localElementNumber,"*",err,error))// &
                                & " is invalid. The local element number must be >=1 and <= "// &
                                & TRIM(NumberToVString(decompositionTopology%elements%TOTAL_NUMBER_OF_ELEMENTS,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Decomposition topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(ComponentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VariableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetGetLocalGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetGetLocalGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetGetLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular data point of the field variable component.  \see cmfe_Field_ParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointDP(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
  & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalElementNumber,dataPointLocalNumber,dofIdx
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(DataProjectionType), POINTER :: dataProjection
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateElementDataPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not update by gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          dataProjection=>field%dataProjection
                          IF(ASSOCIATED(dataProjection)) THEN
                            ! Use element topology to check if data point is on current computational node
                            CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                              & userElementExists,decompositionLocalElementNumber,ghostElement,err,error,*999)
                            IF(userElementExists) THEN
                              IF(ghostElement) THEN
                                localError="Cannot update by data point for user element "// &
                                  & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                                CALL FlagError(localError,err,error,*999)
                              ELSE
                                dataPointLocalNumber = decompositionTopology%dataPoints% &
                                  & elementDataPoint(decompositionLocalElementNumber)%dataIndices(dataPointIndex)%localNumber
                                IF(dataPointLocalNumber >= 1 .AND. dataPointLocalNumber <= fieldVariable% &
                                  & COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP% &
                                  & NUMBER_OF_DATA_POINT_PARAMETERS) THEN
                                  dofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(dataPointLocalNumber)
                                  CALL DistributedVector_ValuesSet(parameterSet%PARAMETERS,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="The specified data point index "// &
                                    & TRIM(NumberToVString(dataPointLocalNumber,"*",err,error))// &
                                    & " is not within the expected range."
                                  CALL FlagError(localError,err,error,*999)
                                ENDIF
                              ENDIF
                            ELSE
                              localError="The specified user element number of "// &
                                & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                                & " does not exist in the decomposition for field component number "// &
                                & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                                & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                                & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Data point projection not associated on provided field.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateElementDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateElementDataPointDP",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateElementDataPointDP

  !
  !================================================================================================================================
  !

  !>Initialises the parameter set for a field.
  SUBROUTINE FIELD_PARAMETER_SET_INITIALISE(FIELD_PARAMETER_SET,ERR,ERROR,*)

   !Argument variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET !<The field parameter set to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_PARAMETER_SET_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
      FIELD_PARAMETER_SET%SET_INDEX=0
      FIELD_PARAMETER_SET%SET_TYPE=0
    ELSE
      CALL FlagError("Field parameter set is not associated",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INITIALISE

  !
  !================================================================================================================================
  !

  !>Outputs the parameter set for a field variable.
  SUBROUTINE FIELD_PARAMETER_SET_OUTPUT(ID,FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

   !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the output stream
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to output the parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to output the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to output
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_OUTPUT",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
              PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
              IF(ASSOCIATED(PARAMETER_SET)) THEN
                CALL DistributedVector_Output(ID,PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_OUTPUT")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_OUTPUT",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_OUTPUT

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."

                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointIntg",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesSet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointIntg",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesSet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointSP",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesSet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointDP",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateDataPointL",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopology_DataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                            CALL DistributedVector_ValuesSet(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NumberToVString(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NumberToVString(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FlagError(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateDataPointL",err,error)
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointL

  !
  !================================================================================================================================
  !

  !>Update the given parameter set an integer value for the specified local data point of a field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointIntg(field,variableType,fieldSetType,dataPointNumber,componentNumber,value, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,interpolationType
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateLocalDataPointIntg",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    IF(.NOT.fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
      localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
        & " does not correspond to the integer data type of the given value."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ComponentInterpolationGet(fieldVariable,componentNumber,interpolationType,err,error,*999)

    SELECT CASE(interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      IF(dataPointNumber<1.OR.dataPointNumber>fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
        & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS) THEN
        localError="The specified data point number of "//TRIM(NumberToVString(dataPointNumber,"*",err,error))// &
          & " is invalid. The data point number must be >= 1 and <= "// &
          & TRIM(NumberToVString(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
          & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(.NOT.ALLOCATED(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS)) &
        CALL FlagError("Data points is not allocated for the field variable component data point param 2 dof map.",err,error,*999)
      dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(dataPointNumber)
      CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,VALUE,err,error,*999)
    CASE DEFAULT
      localError="The field component interpolation type of "//TRIM(NumberToVString(interpolationType,"*",err,error))// &
        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetUpdateLocalDataPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointIntg

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified local data point of a field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointSP(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,interpolationType
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateLocalDataPointSP",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    IF(.NOT.fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
      localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
        & " does not correspond to the single precision real data type of the given value."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ComponentInterpolationGet(fieldVariable,componentNumber,interpolationType,err,error,*999)

    SELECT CASE(interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      IF(dataPointNumber<1.OR.dataPointNumber>fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
        & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS) THEN
        localError="The specified data point number of "//TRIM(NumberToVString(dataPointNumber,"*",err,error))// &
          & " is invalid. The data point number must be >= 1 and <= "// &
          & TRIM(NumberToVString(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
          & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(.NOT.ALLOCATED(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS)) &
        CALL FlagError("Data points is not allocated for the field variable component data point param 2 dof map.",err,error,*999)
      dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(dataPointNumber)
      CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,VALUE,err,error,*999)
    CASE DEFAULT
      localError="The field component interpolation type of "//TRIM(NumberToVString(interpolationType,"*",err,error))// &
        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetUpdateLocalDataPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointSP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified local data point of a field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointDP(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,interpolationType
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateLocalDataPointDP",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    IF(.NOT.fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
      localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
        & " does not correspond to the double precision real data type of the given value."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ComponentInterpolationGet(fieldVariable,componentNumber,interpolationType,err,error,*999)

    SELECT CASE(interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      IF(dataPointNumber<1.OR.dataPointNumber>fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
        & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS) THEN
        localError="The specified data point number of "//TRIM(NumberToVString(dataPointNumber,"*",err,error))// &
          & " is invalid. The data point number must be >= 1 and <= "// &
          & TRIM(NumberToVString(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
          & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(.NOT.ALLOCATED(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS)) &
        CALL FlagError("Data points is not allocated for the field variable component data point param 2 dof map.",err,error,*999)
      dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(dataPointNumber)
      CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,VALUE,err,error,*999)
    CASE DEFAULT
      localError="The field component interpolation type of "//TRIM(NumberToVString(interpolationType,"*",err,error))// &
        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetUpdateLocalDataPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointDP

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified local data point of a field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalDataPointL(field,variableType,fieldSetType,dataPointNumber,componentNumber,VALUE, &
      & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The local data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,interpolationType
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateLocalDataPointL",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) CALL FlagError("Field is not associated.",err,error,*999)
    IF(.NOT.field%FIELD_FINISHED) THEN
      localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(fieldVariable)
    CALL Field_VariableGet(field,variableType,fieldVariable,err,error,*999)
    IF(.NOT.fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
      localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
        & " does not correspond to the logical data type of the given value."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    NULLIFY(parameterSet)
    CALL FieldVariable_ParameterSetGet(fieldVariable,fieldSetType,parameterSet,err,error,*999)
    CALL FieldVariable_ComponentInterpolationGet(fieldVariable,componentNumber,interpolationType,err,error,*999)

    SELECT CASE(interpolationType)
    CASE(FIELD_CONSTANT_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
      !!!!!
      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
      !!!!!
    CASE(FIELD_NODE_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
      localError="Can not Update by data point for component number "// &
        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
      CALL FlagError(localError,err,error,*999)
    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
      IF(dataPointNumber<1.OR.dataPointNumber>fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
        & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS) THEN
        localError="The specified data point number of "//TRIM(NumberToVString(dataPointNumber,"*",err,error))// &
          & " is invalid. The data point number must be >= 1 and <= "// &
          & TRIM(NumberToVString(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
          & DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
      IF(.NOT.ALLOCATED(fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS)) &
        CALL FlagError("Data points is not allocated for the field variable component data point param 2 dof map.",err,error,*999)
      dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(dataPointNumber)
      CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,VALUE,err,error,*999)
    CASE DEFAULT
      localError="The field component interpolation type of "//TRIM(NumberToVString(interpolationType,"*",err,error))// &
        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END SELECT

    EXITS("Field_ParameterSetUpdateLocalDataPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalDataPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalDataPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NumberToVString(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision values for all local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    REAL(DP), INTENT(IN) :: VALUES(:) !<The values to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !\todo: Allow to specify a global number and then have it all update accordingly???
                  IF(SIZE(VALUES)==FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    !\todo: set the vector values directly without looping
                    DO dof=1,FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL
                      CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof,VALUES(dof),ERR,ERROR,*999)
                    ENDDO
                  ELSE
                    LOCAL_ERROR="The size of the parameter vector ("//TRIM(NumberToVString(SIZE(VALUES),"*",ERR,ERROR))// &
                      & ") does not match the number of dofs for this field ("// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & ".)"
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user element of the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &

                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user element of the field variable component.  \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user element of the field variable component.  \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user element of the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local element of the field variable component.
  SUBROUTINE Field_ParameterSetUpdateLocalElementIntg(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER, &
    & COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_ParameterSetUpdateLocalElementIntg",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."

                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateLocalElementIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalElementIntg",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalElementIntg

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NumberToVString(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateFinish
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

     !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finish the update for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_FINISH",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
              PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
              IF(ASSOCIATED(PARAMETER_SET)) THEN
                CALL DistributedVector_UpdateFinish(PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
                IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE.AND.FIELD_SET_TYPE==FIELD_VALUES_SET_TYPE) THEN
                  !Geometric field values have changed so update the geometric parameters (e.g., lines etc.)
                  CALL FIELD_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_FINISH")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_FINISH",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FINISH

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a face with specified user number and xi direction for the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FACE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,versionNumber,derivativeNumber, &
    & userElementNumber,userXiDir,componentNumber,value,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The face derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The face derivative number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number that the face is on
    INTEGER(INTG), INTENT(IN) :: userXiDir !<the xi_direction of the face
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof, globalDof
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_FACE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_INTERPOLATION is not applicable for set faces",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      CALL FIELD_COMPONENT_DOF_GET_USER_FACE(FIELD,VARIABLE_TYPE,versionNumber,derivativeNumber, &
                        & userElementNumber, userXiDir,componentNumber,localDof,globalDof,ERR,ERROR,*999)

                      CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,value,ERR,ERROR,*999)
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not applicable for set face",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not applicable for set face",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &

                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_FACE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_FACE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FACE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a line with specified user number and xi direction for the field variable component. \see cmfe_Field_ParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LINE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,versionNumber,derivativeNumber, &
    & userElementNumber,userXiDir,componentNumber,value,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The line derivative version number to add
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The line derivative number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number that the line is on
    INTEGER(INTG), INTENT(IN) :: userXiDir !<the xi_direction of the line
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: localDof, globalDof
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LINE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_INTERPOLATION is not applicable for set lines",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not applicable for set line",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not applicable for set line",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)

                      CALL FIELD_COMPONENT_DOF_GET_USER_LINE(FIELD,VARIABLE_TYPE,versionNumber,derivativeNumber, &
                        & userElementNumber, userXiDir,componentNumber,localDof,globalDof,ERR,ERROR,*999)

                      CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,localDof,value,ERR,ERROR,*999)

                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &

                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LINE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LINE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LINE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user node, derivative and version of the field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NumberToVString(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NumberToVString(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_NODE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DistributedVector_ValuesSet(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NumberToVString(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NumberToVString(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NumberToVString(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NumberToVString(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NumberToVString(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NumberToVString(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NumberToVString(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NumberToVString(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointIntg",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateGaussPointIntg")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointIntg",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointIntg

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateGaussPointSP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointSP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointSP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointDP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateGaussPointL",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateGaussPointL")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateGaussPointL",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateGaussPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component using the local element index.  \see cmfe_Field__ParameterSetUpdateGaussPoint
  SUBROUTINE Field_ParameterSetUpdateLocalGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,localElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    ENTERS("Field_ParameterSetUpdateLocalGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_FACE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION)
                      !!!!!
                      CALL FlagError("FIELD_ELEMENT_AND_EXT_LINE_BASED_INTERPOLATION is not yet implemented here",ERR,ERROR,*999)
                      !!!!!
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          IF(ASSOCIATED(decompositionTopology%elements)) THEN
                            IF(localElementNumber>=1.AND. &
                              & localElementNumber<=decompositionTopology%elements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              !!TODO: check for actual # of gp?
                              IF(gaussPointNumber >= 1 .AND. gaussPointNumber <= SIZE(fieldVariable% &
                                & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                                dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                                CALL DistributedVector_ValuesSet(parameterSet%parameters,dofIdx,value,err,error,*999)
                              ELSE
                                localError="The specified gauss point number "// &
                                  & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                  & " is not within the expected range."
                                CALL FlagError(localError,err,error,*999)
                              ENDIF
                            ELSE
                              localError="Local element number "//TRIM(NumberToVString(localElementNumber,"*",err,error))// &
                                & " is invalid. The local element number must be >=1 and <= "// &
                                & TRIM(NumberToVString(decompositionTopology%elements%TOTAL_NUMBER_OF_ELEMENTS,"*",err,error))//"."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FlagError("Decomposition topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FlagError("Decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by local Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("Field_ParameterSetUpdateLocalGaussPointDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetUpdateLocalGaussPointDP",err,error)
    RETURN 1

  END SUBROUTINE Field_ParameterSetUpdateLocalGaussPointDP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_FieldParameterSetInterpolateXI
  SUBROUTINE Field_ParameterSetInterpolateSingleXiDP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,XI,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: XI(:) !<The set of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_ParameterSetInterpolateSingleXiDP",ERR,ERROR,*999)

    NULLIFY(INTERPOLATED_PARAMETERS)
    NULLIFY(INTERPOLATED_POINT)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  IF(USER_ELEMENT_NUMBER>0.AND.USER_ELEMENT_NUMBER<=DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,USER_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    IF(SIZE(VALUES)==numberOfComponents) THEN
                      IF(SIZE(XI)==DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI) THEN
                        CALL FIELD_INTERPOLATE_XI(DERIVATIVE_NUMBER,XI(:),INTERPOLATED_POINT(VARIABLE_TYPE)%PTR, &
                          & ERR,ERROR,*999)
                        VALUES(1:numberOfComponents)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                          & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                      ELSE
                        LOCAL_ERROR="The specified xi to interpolate the field at are invalid. "// &
                          & "The supplied size is "// &
                          & TRIM(NumberToVString(SIZE(XI),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NumberToVString(DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI,"*", &
                          & ERR,ERROR))//" for this field."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                        & "The supplied size is "//TRIM(NumberToVString(SIZE(VALUES),"*",ERR,ERROR))//" and should be "// &
                        & TRIM(NumberToVString(numberOfComponents,"*", &
                        & ERR,ERROR))//" for this field."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified element number of "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The element number must be between 1 and "// &
                      & TRIM(NumberToVString(DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetInterpolateSingleXiDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateSingleXiDP",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateSingleXiDP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_FieldParameterSetInterpolateXI
  SUBROUTINE Field_ParameterSetInterpolateMultipleXiDP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,XI,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: XI(:,:) !<The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:,:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    INTEGER(INTG) :: xi_set
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_ParameterSetInterpolateMultipleXiDP",ERR,ERROR,*999)

    NULLIFY(INTERPOLATED_PARAMETERS)
    NULLIFY(INTERPOLATED_POINT)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  IF(USER_ELEMENT_NUMBER>0.AND.USER_ELEMENT_NUMBER<=DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,USER_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    IF(SIZE(VALUES,1)==numberOfComponents) THEN
                      IF(SIZE(XI,1)==DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI) THEN
                        IF(SIZE(VALUES,2)==SIZE(XI,2)) THEN
                          DO xi_set=1,SIZE(XI,2)
                            CALL FIELD_INTERPOLATE_XI(DERIVATIVE_NUMBER,XI(:,xi_set),INTERPOLATED_POINT(VARIABLE_TYPE)%PTR, &
                              & ERR,ERROR,*999)
                            VALUES(1:numberOfComponents,xi_set)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                              & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                          ENDDO
                        ELSE
                          LOCAL_ERROR="The number of xi sets in the field interpolated values output array is "// &
                            & "not the same as the number to be interpolated."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The specified xi values to interpolate the field at are invalid. "// &
                          & "The supplied size is "// &
                          & TRIM(NumberToVString(SIZE(XI,1),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NumberToVString(DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI,"*", &
                          & ERR,ERROR))//" for this field."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                        & "The supplied size is "//TRIM(NumberToVString(SIZE(VALUES,1),"*",ERR,ERROR))//" and should be "// &
                        & TRIM(NumberToVString(numberOfComponents,"*",ERR,ERROR))//" for this field."
                      CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified element number of "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The element number must be between 1 and "// &
                      & TRIM(NumberToVString(DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetInterpolateMultipleXiDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateMultipleXiDP",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateMultipleXiDP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values. \see OpenCMISS::Iron::cmfe_FieldParameterSetInterpolateGauss
  SUBROUTINE Field_ParameterSetInterpolateSingleGaussDP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,SCHEME,GAUSS_POINT,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: SCHEME !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: QUADRATURE_SCHEME
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_ParameterSetInterpolateSingleGaussDP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  IF(USER_ELEMENT_NUMBER>0.AND.USER_ELEMENT_NUMBER<=DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,USER_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    QUADRATURE_SCHEME=>DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%QUADRATURE% &
                      & QUADRATURE_SCHEME_MAP(SCHEME)%PTR
                    IF(ASSOCIATED(QUADRATURE_SCHEME)) THEN
                      IF(SIZE(VALUES)==numberOfComponents) THEN
                        IF(GAUSS_POINT>0.AND.GAUSS_POINT<=QUADRATURE_SCHEME%NUMBER_OF_GAUSS) THEN
                          CALL FIELD_INTERPOLATE_GAUSS(DERIVATIVE_NUMBER,SCHEME,GAUSS_POINT, &
                            & INTERPOLATED_POINT(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                          VALUES(1:numberOfComponents)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                            & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                        ELSE
                          LOCAL_ERROR="The specified Gauss point number of "// &
                            & TRIM(NumberToVString(GAUSS_POINT,"*",ERR,ERROR))//"is invalid for "// &
                            & "the specified quadrature scheme of the specified element for this field which has "// &
                            & TRIM(NumberToVString(QUADRATURE_SCHEME%NUMBER_OF_GAUSS,"*",ERR,ERROR))//" Gauss points."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                          & "The supplied size is "//TRIM(NumberToVString(SIZE(VALUES),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NumberToVString(numberOfComponents,"*",ERR,ERROR))//" for this field."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("The specified quadrature scheme is not associated the specified element's basis.", &
                        & ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified element number of "//TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The element number must be between 1 and "// &
                      & TRIM(NumberToVString(DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetInterpolateSingleGaussDP")
    RETURN
999 ERRORSEXITS("Field_ParameterSetInterpolateSingleGaussDP",ERR,ERROR)
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateSingleGaussDP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values. If no Gauss points are specified then all Gauss points are interpolated. \see OpenCMISS::Iron::cmfe_FieldParameterSetInterpolateGauss
  SUBROUTINE Field_ParameterSetInterpolateMultipleGaussDP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,SCHEME,GAUSS_POINTS,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: SCHEME !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINTS(:) !<The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:,:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    INTEGER(INTG) :: Gauss_point
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: QUADRATURE_SCHEME
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("Field_ParameterSetInterpolateMultipleGaussDP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                  CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                    & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                  IF(USER_ELEMENT_EXISTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,DECOMPOSITION_LOCAL_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    QUADRATURE_SCHEME=>DOMAIN_ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)%BASIS%QUADRATURE% &
                      & QUADRATURE_SCHEME_MAP(SCHEME)%PTR
                    IF(ASSOCIATED(QUADRATURE_SCHEME)) THEN
                      IF(SIZE(VALUES,1)==numberOfComponents) THEN
                        IF(SIZE(GAUSS_POINTS)==0) THEN !Interpolate all Gauss points.
                          IF(SIZE(VALUES,2)==QUADRATURE_SCHEME%NUMBER_OF_GAUSS) THEN
                            DO Gauss_point=1,QUADRATURE_SCHEME%NUMBER_OF_GAUSS
                              CALL FIELD_INTERPOLATE_GAUSS(DERIVATIVE_NUMBER,SCHEME,Gauss_point, &
                                & INTERPOLATED_POINT(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                              VALUES(1:numberOfComponents,Gauss_point)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                                & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                            ENDDO
                          ELSE
                            LOCAL_ERROR="The number of Gauss points in the field interpolated values output array is "// &
                              & "invalid. For returning the interpolated field values at all element Gauss points, the "//&
                              & "output array is required to be allocated for "// &
                              & TRIM(NumberToVString(QUADRATURE_SCHEME%NUMBER_OF_GAUSS,"*",ERR,ERROR))// &
                              & " Gauss points for the specified quadrature scheme."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE !Interpolate only at the specified Gauss points.
                          IF(SIZE(VALUES,2)==SIZE(GAUSS_POINTS)) THEN
                            DO Gauss_point=1,SIZE(GAUSS_POINTS)
                              IF(GAUSS_POINTS(Gauss_point)>0.AND.GAUSS_POINTS(Gauss_point)<=QUADRATURE_SCHEME% &
                                & NUMBER_OF_GAUSS) THEN
                                CALL FIELD_INTERPOLATE_GAUSS(DERIVATIVE_NUMBER,SCHEME,GAUSS_POINTS(Gauss_point), &
                                  & INTERPOLATED_POINT(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                VALUES(:,Gauss_point)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR%VALUES(:,DERIVATIVE_NUMBER)
                              ELSE
                                LOCAL_ERROR="The specified Gauss point number of "// &
                                  & TRIM(NumberToVString(GAUSS_POINTS(Gauss_point),"*",ERR,ERROR))//"is invalid for "// &
                                  & "the specified quadrature scheme of the specified element for this field which has "// &
                                  & TRIM(NumberToVString(QUADRATURE_SCHEME%NUMBER_OF_GAUSS,"*",ERR,ERROR))//" Gauss points."
                                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDDO
                          ELSE
                            LOCAL_ERROR="The number of Gauss points in the field interpolated values output array is "// &
                              & "not the same as the number to be interpolated."
                            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                          & "The supplied size is "//TRIM(NumberToVString(SIZE(VALUES,1),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NumberToVString(numberOfComponents,"*",ERR,ERROR))//" for this field."
                        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FlagError("The specified quadrature scheme is not associated the specified element's basis.", &
                        & ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified user element number of "// &
                      & TRIM(NumberToVString(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " does not exist in the decomposition for field variable type "// &
                      & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                      & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NumberToVString(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FlagError("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("Field_ParameterSetInterpolateMultipleGaussDP")
    RETURN
999 ERRORS("Field_ParameterSetInterpolateMultipleGaussDP",ERR,ERROR)
    EXITS("Field_ParameterSetInterpolateMultipleGaussDP")
    RETURN 1

  END SUBROUTINE Field_ParameterSetInterpolateMultipleGaussDP

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_FieldParameterSetUpdateStart
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_START(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to start the update for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to update
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_UPDATE_START",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
            PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
            IF(ASSOCIATED(PARAMETER_SET)) THEN
              CALL DistributedVector_UpdateStart(PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_UPDATE_START")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_UPDATE_START",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_START

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set distributed vector.
  SUBROUTINE FIELD_PARAMETER_SET_VECTOR_GET(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DISTRIBUTED_VECTOR,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set vector from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    TYPE(DistributedVectorType), POINTER :: DISTRIBUTED_VECTOR !<On return, a pointer to the field parameter set distributed vector. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_PARAMETER_SET_VECTOR_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(DISTRIBUTED_VECTOR)) THEN
        CALL FlagError("Distributed vector is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(DISTRIBUTED_VECTOR)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  DISTRIBUTED_VECTOR=>PARAMETER_SET%PARAMETERS
                  IF(.NOT.ASSOCIATED(DISTRIBUTED_VECTOR)) &
                    & CALL FlagError("Call parameter set distributed vector is not associated.",ERR,ERROR,*999)
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NumberToVString(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_PARAMETER_SET_VECTOR_GET")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_VECTOR_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_VECTOR_GET

  !
  !================================================================================================================================
  !

  !>Finalises the parameter sets for a field and deallocates all memory.
  SUBROUTINE FIELD_PARAMETER_SETS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE) :: FIELD_VARIABLE !<A pointer to the field variable to finalise the parameter sets for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: parameter_set_idx

    ENTERS("FIELD_PARAMETER_SETS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE)) DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE)
    IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)) THEN
      DO parameter_set_idx=1,SIZE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS,1)
        CALL FIELD_PARAMETER_SET_FINALISE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR,ERR,ERROR,*999)
      ENDDO !parameter_set_idx
      DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)
    ENDIF
    FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=0

    EXITS("FIELD_PARAMETER_SETS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SETS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the parameter sets for a field.
  SUBROUTINE FIELD_PARAMETER_SETS_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the variable parameter sets for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,parameter_set_idx,variable_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    ENTERS("FIELD_PARAMETER_SETS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%FIELD_VARIABLE=>FIELD%VARIABLES(variable_idx)
        FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=0
        NULLIFY(FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%PARAMETER_SETS)
        ALLOCATE(FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%SET_TYPE(FIELD_NUMBER_OF_SET_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate field parameter sets set types.",ERR,ERROR,*999)
        DO parameter_set_idx=1,FIELD_NUMBER_OF_SET_TYPES
          NULLIFY(FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%SET_TYPE(parameter_set_idx)%PTR)
        ENDDO !parameter_set_idx
        !Create a field values parameter set
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,ERR,ERROR,*999)
      ENDDO !variable_idx
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_PARAMETER_SETS_INITIALISE")
    RETURN
999 DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      IF(ASSOCIATED(FIELD%VARIABLE_TYPE_MAP(variable_idx)%PTR)) &
        & CALL FIELD_PARAMETER_SETS_FINALISE(FIELD%VARIABLE_TYPE_MAP(variable_idx)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
    ENDDO !variable_idx
998 ERRORSEXITS("FIELD_PARAMETER_SETS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the scaling for a field scaling index and deallocates all memory.
  SUBROUTINE FIELD_SCALING_FINALISE(FIELD,SCALING_INDEX,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(IN) :: SCALING_INDEX !<The scaling index to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALING_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(SCALING_INDEX>0.AND.SCALING_INDEX<=FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
        !IF(ALLOCATED(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS))  &
        !  & DEALLOCATE(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS)
        IF(ASSOCIATED(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS)) &
          & CALL DistributedVector_Destroy(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="The scaling index of "//TRIM(NumberToVString(SCALING_INDEX,"*",ERR,ERROR))// &
          & " is invalid for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " which has "//TRIM(NumberToVString(FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",ERR,ERROR))// &
          & " scaling indices."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALING_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the scalings for a field scaling index corresponding to a mesh component index.
  SUBROUTINE FIELD_SCALING_INITIALISE(FIELD,SCALING_INDEX,MESH_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the scaling for
    INTEGER(INTG), INTENT(IN) :: SCALING_INDEX !<The scaling index to initialise
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT_NUMBER !<The mesh component number to initialise for the scaling
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALING_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(SCALING_INDEX>0.AND.SCALING_INDEX<=FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
        IF(MESH_COMPONENT_NUMBER>0.AND.MESH_COMPONENT_NUMBER<=FIELD%DECOMPOSITION%MESH%NUMBER_OF_COMPONENTS) THEN
          FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%MESH_COMPONENT_NUMBER=MESH_COMPONENT_NUMBER
          FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%MAX_NUMBER_OF_ELEMENT_PARAMETERS=FIELD%DECOMPOSITION% &
            & DOMAIN(MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS%MAXIMUM_NUMBER_OF_ELEMENT_PARAMETERS
          FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%MAX_NUMBER_OF_DERIVATIVES=FIELD%DECOMPOSITION% &
            & DOMAIN(MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%NODES%MAXIMUM_NUMBER_OF_DERIVATIVES
          NULLIFY(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS)
          SELECT CASE(FIELD%SCALINGS%SCALING_TYPE)
          CASE(FIELD_NO_SCALING)
            !Do nothing
          CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            !ALLOCATE(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)% &
            !  & MAX_NUMBER_OF_DERIVATIVES,FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
            !  & NODES%TOTAL_NUMBER_OF_NODES),STAT=ERR)
            !IF(ERR/=0) CALL FlagError("Could not allocate scale factors",ERR,ERROR,*999)
            !FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS=1.0_DP
            CALL DistributedVector_CreateStart(FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR%MAPPINGS%DOFS, &
              & FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,ERR,ERROR,*999)
            CALL DistributedVector_DataTypeSet(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS, &
              & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
            CALL DistributedVector_CreateFinish(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,ERR,ERROR,*999)
            IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
              !Initialise the scalings to 1.0 for a geometric field. Other field types will be setup in FIELD_SCALINGS_CALCULATE
              CALL DistributedVector_AllValuesSet(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,1.0_DP,ERR,ERROR,*999)
            ENDIF
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " is invalid for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          LOCAL_ERROR="The mesh component number of "//TRIM(NumberToVString(SCALING_INDEX,"*",ERR,ERROR))// &
            & " is invalid for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " which is associated with a mesh which has "//TRIM(NumberToVString(FIELD%DECOMPOSITION% &
            & MESH%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" mesh components."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The scaling index of "//TRIM(NumberToVString(SCALING_INDEX,"*",ERR,ERROR))// &
          & " is invalid for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " which has "//TRIM(NumberToVString(FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",ERR,ERROR))// &
          & " scaling indices."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALING_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the scale factors from the geometric field associated with the field.
  SUBROUTINE FIELD_SCALINGS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the scalings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: MESH_COMPONENT_NUMBER,xi_direction,ni1,ni2,version_idx,derivative_idx,nk2,local_node_line_idx, &
      & adjacent_local_node_line_idx,node_line_idx,node_idx,partial_derivative_idx,nu1,nu2,dof_idx,ny1,ny2,ny3,scaling_idx
    REAL(DP) :: LENGTH1,LENGTH2,MEAN_LENGTH,TEMP,NUMBER_OF_LINE_VERSIONS1,NUMBER_OF_LINE_VERSIONS2,VALUE
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    LOGICAL :: FOUND
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DECOMPOSITION_LINES
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_LINES_TYPE), POINTER :: DOMAIN_LINES
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(FIELD_SCALING_TYPE), POINTER :: FIELD_SCALING
    TYPE(FIELD_SCALINGS_TYPE), POINTER :: FIELD_SCALINGS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALINGS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELD_SCALINGS=>FIELD%SCALINGS
      IF(ASSOCIATED(FIELD_SCALINGS)) THEN
        GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          SELECT CASE(FIELD_SCALINGS%SCALING_TYPE)
          CASE(FIELD_NO_SCALING)
            !Do nothing
            NULLIFY(DOMAIN)
          CASE(FIELD_UNIT_SCALING)
            DO scaling_idx=1,FIELD_SCALINGS%NUMBER_OF_SCALING_INDICES
              FIELD_SCALING=>FIELD_SCALINGS%SCALINGS(scaling_idx)
              MESH_COMPONENT_NUMBER=FIELD_SCALING%MESH_COMPONENT_NUMBER
              DOMAIN=>FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR
              CALL DistributedVector_AllValuesSet(FIELD_SCALING%SCALE_FACTORS,1.0_DP,ERR,ERROR,*999)
              CALL DistributedVector_UpdateStart(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
              CALL DistributedVector_UpdateFinish(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
            ENDDO !scaling_idx
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FlagError("Not implemented.",ERR,ERROR,*999)

          CASE(FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            DO scaling_idx=1,FIELD_SCALINGS%NUMBER_OF_SCALING_INDICES
              FIELD_SCALING=>FIELD_SCALINGS%SCALINGS(scaling_idx)
              MESH_COMPONENT_NUMBER=FIELD_SCALING%MESH_COMPONENT_NUMBER
              DOMAIN=>FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR
              DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
              IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
                DOMAIN_LINES=>DOMAIN%TOPOLOGY%LINES
                DECOMPOSITION_LINES=>FIELD%DECOMPOSITION%TOPOLOGY%LINES
              ENDIF
              NULLIFY(SCALE_FACTORS)
              CALL DistributedVector_DataGet(FIELD_SCALING%SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO node_idx=1,DOMAIN_NODES%NUMBER_OF_NODES
                DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                  partial_derivative_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                  SELECT CASE(partial_derivative_idx)
                  CASE(NO_PART_DERIV)
                    DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                      CALL DistributedVector_ValuesSet(FIELD_SCALING%SCALE_FACTORS,dof_idx,1.0_DP,ERR,ERROR,*999)
                    ENDDO
                  CASE(PART_DERIV_S1,PART_DERIV_S2,PART_DERIV_S3)
                    IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
                      IF(partial_derivative_idx==PART_DERIV_S1) THEN
                        xi_direction=1
                      ELSE IF(partial_derivative_idx==PART_DERIV_S2) THEN
                        xi_direction=2
                      ELSE
                        xi_direction=3
                      ENDIF
                      LENGTH1 = 0.0_DP
                      LENGTH2 = 0.0_DP
                      NUMBER_OF_LINE_VERSIONS1 = 0.0_DP
                      NUMBER_OF_LINE_VERSIONS2 = 0.0_DP
                      DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                        !Find a line of the correct Xi direction going through this node
                        FOUND=.FALSE.
                        DO node_line_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_NODE_LINES
                          !Node lines should include ghosts: Changes made in mesh_routines.
                          !DECOMPOSITION_LINES%LINES is allocated as TOTAL_NUMBER_OF_LOCAL,
                          !then it makes sense.
                          local_node_line_idx=DOMAIN_NODES%NODES(node_idx)%NODE_LINES(node_line_idx)
                          IF(DECOMPOSITION_LINES%LINES(local_node_line_idx)%XI_DIRECTION==xi_direction) THEN
                            FOUND=.TRUE.
                            EXIT
                          ENDIF
                        ENDDO !node_line_idx
                        IF(FOUND) THEN
                          IF(DOMAIN_LINES%LINES(local_node_line_idx)%NODES_IN_LINE(1)==node_idx) THEN !Current node at the beginning of the line
                            adjacent_local_node_line_idx=DECOMPOSITION_LINES%LINES(local_node_line_idx)%ADJACENT_LINES(0)
                          ELSE !Current node at the end of the line
                            adjacent_local_node_line_idx=DECOMPOSITION_LINES%LINES(local_node_line_idx)%ADJACENT_LINES(1)
                          ENDIF
                          !Average line lengths for the different versions (division by the number of lines is done after all the line lengths are added together)
                          LENGTH1=LENGTH1+GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(local_node_line_idx)
                          NUMBER_OF_LINE_VERSIONS1=NUMBER_OF_LINE_VERSIONS1+1
                          IF(adjacent_local_node_line_idx/=0) THEN !Adjacent node and therefore lines exist
                            LENGTH2=LENGTH2+GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(adjacent_local_node_line_idx)
                            NUMBER_OF_LINE_VERSIONS2=NUMBER_OF_LINE_VERSIONS2+1
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Could not find a line in the Xi "//TRIM(NumberToVString(xi_direction,"*",ERR,ERROR))// &
                            & " direction going through node number "//TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ENDDO !version_idx
                      !Division by the numer of version for this node derivative, completing the calculation for the average line lengths
                      LENGTH1 = LENGTH1/NUMBER_OF_LINE_VERSIONS1
                      IF(adjacent_local_node_line_idx==0) THEN !No adjacent node ie end of mesh
                        MEAN_LENGTH=LENGTH1
                      ELSE !Adjacent node and therefore lines exist
                        LENGTH2 = LENGTH2/NUMBER_OF_LINE_VERSIONS2
                        SELECT CASE(FIELD_SCALINGS%SCALING_TYPE)
                        CASE(FIELD_ARITHMETIC_MEAN_SCALING)
                          MEAN_LENGTH=(LENGTH1+LENGTH2)/2.0_DP
                        CASE(FIELD_GEOMETRIC_MEAN_SCALING)
                          MEAN_LENGTH=sqrt(LENGTH1*LENGTH2)
                        CASE(FIELD_HARMONIC_MEAN_SCALING)
                          TEMP=LENGTH1*LENGTH2
                          IF(ABS(TEMP)>ZERO_TOLERANCE) THEN
                            MEAN_LENGTH=2.0_DP*TEMP/(LENGTH1+LENGTH2)
                          ELSE
                            MEAN_LENGTH=0.0_DP
                          ENDIF
                        CASE DEFAULT
                          LOCAL_ERROR="The scaling type of "// &
                            & TRIM(NumberToVString(FIELD_SCALINGS%SCALING_TYPE,"*",ERR,ERROR))//" is invalid."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        END SELECT
                      ENDIF
                      DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                        dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                        CALL DistributedVector_ValuesSet(FIELD_SCALING%SCALE_FACTORS,dof_idx,MEAN_LENGTH,ERR,ERROR,*999)
                      ENDDO !version_idx
                    ENDIF
                  CASE(PART_DERIV_S1_S2,PART_DERIV_S1_S3,PART_DERIV_S2_S3,PART_DERIV_S1_S2_S3)
                    DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                      IF(partial_derivative_idx==PART_DERIV_S1_S2) THEN
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=2
                        nu2=PART_DERIV_S2
                      ELSE IF(partial_derivative_idx==PART_DERIV_S1_S3) THEN
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=3
                        nu2=PART_DERIV_S3
                      ELSE IF(partial_derivative_idx==PART_DERIV_S2_S3) THEN
                        ni1=2
                        nu1=PART_DERIV_S2
                        ni2=3
                        nu2=PART_DERIV_S3
                      ELSE
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=2
                        nu2=PART_DERIV_S2
                      ENDIF
  !!TODO: Shouldn't have to search for the derivative_idx directions. Store them somewhere.
                      !Find the first direction derivative_idx
                      FOUND=.FALSE.
                      DO nk2=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                        IF(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%PARTIAL_DERIVATIVE_INDEX==nu1) THEN
                          ny1=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%DOF_INDEX(version_idx)
                          FOUND=.TRUE.
                          EXIT
                        ENDIF
                      ENDDO !nk2
                      IF(FOUND) THEN
                        !Find the second direction derivative_idx
                        FOUND=.FALSE.
                        DO nk2=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                          IF(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%PARTIAL_DERIVATIVE_INDEX==nu2) THEN
                            ny2=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%DOF_INDEX(version_idx)
                            FOUND=.TRUE.
                            EXIT
                          ENDIF
                        ENDDO !nk2
                        IF(FOUND) THEN
                          IF(partial_derivative_idx==PART_DERIV_S1_S2_S3) THEN
                            !Find the third direction derivative_idx
                            FOUND=.FALSE.
                            DO nk2=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                              IF(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%PARTIAL_DERIVATIVE_INDEX==PART_DERIV_S3) THEN
                                ny3=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%DOF_INDEX(version_idx)
                                FOUND=.TRUE.
                                EXIT
                              ENDIF
                            ENDDO !nk2
                            IF(FOUND) THEN
                              CALL DistributedVector_ValuesSet(FIELD_SCALING%SCALE_FACTORS,dof_idx, &
                                SCALE_FACTORS(ny1)*SCALE_FACTORS(ny2)*SCALE_FACTORS(ny3),ERR,ERROR,*999)
                            ELSE
                              LOCAL_ERROR="Could not find the first partial derivative in the s3 direction index for "//&
                                & "local node number "//TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//"."
                              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL DistributedVector_ValuesSet(FIELD_SCALING%SCALE_FACTORS,dof_idx,SCALE_FACTORS(ny1)* &
                              & SCALE_FACTORS(ny2),ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Could not find the first partial derivative in the s"// &
                            & TRIM(NumberToVString(ni2,"*",ERR,ERROR))//" direction index for "//&
                            & "local node number "//TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//"."
                          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Could not find the first partial derivative in the s"// &
                          & TRIM(NumberToVString(ni1,"*",ERR,ERROR))//" direction index for "//&
                          & "local node number "//TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//"."
                      ENDIF
                    ENDDO !version_idx
                  CASE DEFAULT
                    LOCAL_ERROR="The partial derivative index of "//TRIM(NumberToVString(partial_derivative_idx,"*", &
                      & ERR,ERROR))//" for derivative number "//TRIM(NumberToVString(derivative_idx,"*",ERR,ERROR))// &
                      & " of local node number "//TRIM(NumberToVString(node_idx,"*",ERR,ERROR))//" is invalid."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                ENDDO !derivative_idx
              ENDDO !node_idx
              CALL DistributedVector_UpdateStart(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
              CALL DistributedVector_UpdateFinish(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
            ENDDO !scaling_idx
          CASE DEFAULT
            LOCAL_ERROR="The scaling type of "//TRIM(NumberToVString(FIELD_SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FlagError("Field geometric field is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FlagError("Field scalings is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      IF(FIELD_SCALINGS%SCALING_TYPE /= FIELD_NO_SCALING) THEN
        IF(ASSOCIATED(DOMAIN))THEN
          DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
          CALL WriteString(DIAGNOSTIC_OUTPUT_TYPE,"Scale Factors for nodes in the domain:",ERR,ERROR,*999)
          DO node_idx=1,DOMAIN_NODES%NUMBER_OF_NODES
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"Node : ",node_idx,ERR,ERROR,*999)
            CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Derivatives = ", &
              & DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES,ERR,ERROR,*999)
            DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"  Derivative : ",derivative_idx,ERR,ERROR,*999)
              CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Number of Versions = ", &
                & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions,ERR,ERROR,*999)
              DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"    Version : ",version_idx,ERR,ERROR,*999)
                dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                CALL DistributedVector_ValuesGet(FIELD_SCALING%SCALE_FACTORS,dof_idx,VALUE,ERR,ERROR,*999)
                CALL WriteStringValue(DIAGNOSTIC_OUTPUT_TYPE,"      Scale Factor : ",VALUE,ERR,ERROR,*999)
              ENDDO !version_idx
            ENDDO !derivative_idx
          ENDDO !node_idx
        ENDIF
      ENDIF
    ENDIF

    EXITS("FIELD_SCALINGS_CALCULATE")
    RETURN
999 ERRORSEXITS("FIELD_SCALINGS_CALCULATE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the scalings for a field and deallocates all memory.
  SUBROUTINE FIELD_SCALINGS_FINALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: scaling_idx

    ENTERS("FIELD_SCALINGS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      DO scaling_idx=1,FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES
        CALL FIELD_SCALING_FINALISE(FIELD,scaling_idx,ERR,ERROR,*999)
      ENDDO !scaling_idx
      IF(ALLOCATED(FIELD%SCALINGS%SCALINGS)) DEALLOCATE(FIELD%SCALINGS%SCALINGS)
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALINGS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_SCALINGS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the scaling parameters sets for a field.
  SUBROUTINE FIELD_SCALINGS_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the scalings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,NUMBER_OF_MESH_COMPONENTS,scaling_idx,variable_idx
    INTEGER(INTG), ALLOCATABLE :: MESH_COMPONENTS(:),MESH_COMPONENTS_MAP(:)
    TYPE(LIST_TYPE), POINTER :: MESH_COMPONENTS_LIST
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    NULLIFY(MESH_COMPONENTS_LIST)

    ENTERS("FIELD_SCALINGS_INITIALISE",ERR,ERROR,*997)

    IF(ASSOCIATED(FIELD)) THEN
      !Calculate the mesh component numbers involved in the field
      CALL LIST_CREATE_START(MESH_COMPONENTS_LIST,ERR,ERROR,*999)
      CALL LIST_DATA_TYPE_SET(MESH_COMPONENTS_LIST,LIST_INTG_TYPE,ERR,ERROR,*999)
      CALL LIST_INITIAL_SIZE_SET(MESH_COMPONENTS_LIST,FIELD%DECOMPOSITION%MESH%NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      CALL LIST_CREATE_FINISH(MESH_COMPONENTS_LIST,ERR,ERROR,*999)
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
          CALL LIST_ITEM_ADD(MESH_COMPONENTS_LIST,FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%MESH_COMPONENT_NUMBER, &
            & ERR,ERROR,*999)
        ENDDO !component_idx
      ENDDO !variable_idx
      CALL LIST_REMOVE_DUPLICATES(MESH_COMPONENTS_LIST,ERR,ERROR,*999)
      CALL LIST_DETACH_AND_DESTROY(MESH_COMPONENTS_LIST,NUMBER_OF_MESH_COMPONENTS,MESH_COMPONENTS,ERR,ERROR,*999)
      ALLOCATE(MESH_COMPONENTS_MAP(FIELD%DECOMPOSITION%MESH%NUMBER_OF_COMPONENTS),STAT=ERR)
      IF(ERR/=0) CALL FlagError("Could not allocate mesh components map.",ERR,ERROR,*999)
      MESH_COMPONENTS_MAP=0
      DO component_idx=1,NUMBER_OF_MESH_COMPONENTS
        MESH_COMPONENTS_MAP(MESH_COMPONENTS(component_idx))=component_idx
      ENDDO !component_idx
      !Allocate the scaling indices and initialise them
      FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES=NUMBER_OF_MESH_COMPONENTS
      ALLOCATE(FIELD%SCALINGS%SCALINGS(FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES),STAT=ERR)
      IF(ERR/=0) CALL FlagError("Could not allocate field scalings.",ERR,ERROR,*999)
      DO scaling_idx=1,FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES
        CALL FIELD_SCALING_INITIALISE(FIELD,scaling_idx,MESH_COMPONENTS(scaling_idx),ERR,ERROR,*999)
      ENDDO !scaling_idx
      !Set the scaling index for all the field variable components
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
          FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%SCALING_INDEX= &
            & MESH_COMPONENTS_MAP(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%MESH_COMPONENT_NUMBER)
        ENDDO !component_idx
      ENDDO !variable_idx
      DEALLOCATE(MESH_COMPONENTS)
      IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) CALL FIELD_SCALINGS_CALCULATE(FIELD,ERR,ERROR,*999)
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*997)
    ENDIF

    EXITS("FIELD_SCALINGS_INITIALISE")
    RETURN
999 IF(ALLOCATED(MESH_COMPONENTS)) DEALLOCATE(MESH_COMPONENTS)
    IF(ASSOCIATED(MESH_COMPONENTS_LIST)) CALL LIST_DESTROY(MESH_COMPONENTS_LIST,ERR,ERROR,*998)
998 CALL FIELD_SCALINGS_FINALISE(FIELD,DUMMY_ERR,DUMMY_ERROR,*997)
997 ERRORSEXITS("FIELD_SCALINGS_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Checks the scaling type for a field.
  SUBROUTINE FIELD_SCALING_TYPE_CHECK(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the scaling type for
    INTEGER(INTG), INTENT(IN) :: SCALING_TYPE !<The scaling type for the specified field to check \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALING_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SELECT CASE(SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_NO_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not no scaling."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_UNIT_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_UNIT_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not unit scaling."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_ARC_LENGTH_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not arc length scaling."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_ARITHMETIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_ARITHMETIC_MEAN_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &

              & " which is not arithmetic mean scaling."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_GEOMETRIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_GEOMETRIC_MEAN_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &

              & " which is not geometric mean scaling."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_HARMONIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_HARMONIC_MEAN_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not harmonic mean scaling."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The specified scaling type of "//TRIM(NumberToVString(SCALING_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the scaling type for a field. \see OpenCMISS::Iron::cmfe_FieldScalingTypeGet
  SUBROUTINE FIELD_SCALING_TYPE_GET(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
     TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the scaling type for
    INTEGER(INTG), INTENT(OUT) :: SCALING_TYPE !<On return, the scaling type for the specified field to get \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALING_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SCALING_TYPE=FIELD%SCALINGS%SCALING_TYPE
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field. \see OpenCMISS::Iron::cmfe_FieldScalingTypeSet
  SUBROUTINE FIELD_SCALING_TYPE_SET(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: SCALING_TYPE !<The scaling type to set \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALING_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%SCALING_TYPE_LOCKED) THEN
            LOCAL_ERROR="The field scaling type has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            SELECT CASE(SCALING_TYPE)
            CASE(FIELD_NO_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_NO_SCALING
            CASE(FIELD_UNIT_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_UNIT_SCALING
            CASE(FIELD_ARC_LENGTH_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_ARC_LENGTH_SCALING
            CASE(FIELD_ARITHMETIC_MEAN_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_ARITHMETIC_MEAN_SCALING
            CASE(FIELD_GEOMETRIC_MEAN_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_GEOMETRIC_MEAN_SCALING
            CASE(FIELD_HARMONIC_MEAN_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_HARMONIC_MEAN_SCALING
            CASE DEFAULT
              LOCAL_ERROR="The specified scaling type of "//TRIM(NumberToVString(SCALING_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_SCALING_TYPE_SET_AND_LOCK(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: SCALING_TYPE !<The scaling type to set \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_SCALING_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_SCALING_TYPE_SET(FIELD,SCALING_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%SCALING_TYPE_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_SCALING_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_SCALING_TYPE_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the field type for a field.
  SUBROUTINE FIELD_TYPE_CHECK(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to check \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SELECT CASE(TYPE)
        CASE(FIELD_GEOMETRIC_TYPE)
          IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a geometric field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_FIBRE_TYPE)
          IF(FIELD%TYPE/=FIELD_FIBRE_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a fibre field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_GENERAL_TYPE)
          IF(FIELD%TYPE/=FIELD_GENERAL_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a general field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_MATERIAL_TYPE)
          IF(FIELD%TYPE/=FIELD_MATERIAL_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a material field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
          IF(FIELD%TYPE/=FIELD_GEOMETRIC_GENERAL_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NumberToVString(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a geometric general field."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The specified field type of "//TRIM(NumberToVString(TYPE,"*",ERR,ERROR))//" is invalid."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field type for a field. \see OpenCMISS::Iron::cmfe_FieldTypeGet
  SUBROUTINE FIELD_TYPE_GET(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the type for
    INTEGER(INTG), INTENT(OUT) :: TYPE !<On return, the field type for the specified field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        TYPE=FIELD%TYPE
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_TYPE_GET")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field. \see OpenCMISS::Iron::cmfe_FieldTypeSet
  SUBROUTINE FIELD_TYPE_SET(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%TYPE_LOCKED) THEN
            LOCAL_ERROR="The field type has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            SELECT CASE(TYPE)
            CASE(FIELD_GEOMETRIC_TYPE)
              FIELD%TYPE=FIELD_GEOMETRIC_TYPE
              FIELD%GEOMETRIC_FIELD=>FIELD
            CASE(FIELD_FIBRE_TYPE)
              FIELD%TYPE=FIELD_FIBRE_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE(FIELD_GENERAL_TYPE)
              FIELD%TYPE=FIELD_GENERAL_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE(FIELD_MATERIAL_TYPE)
              FIELD%TYPE=FIELD_MATERIAL_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
              FIELD%TYPE=FIELD_GEOMETRIC_GENERAL_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE DEFAULT
              LOCAL_ERROR="The specified field type of "//TRIM(NumberToVString(TYPE,"*",ERR,ERROR))//" is invalid."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_TYPE_SET")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_TYPE_SET_AND_LOCK(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_TYPE_SET(FIELD,TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%TYPE_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_TYPE_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_TYPE_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Finalises a field variable and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_FINALISE(FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE) :: FIELD_VARIABLE !<The field variable to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELD_VARIABLE_FINALISE",ERR,ERROR,*999)

    FIELD_VARIABLE%VARIABLE_LABEL=""
    CALL FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
      CALL DOMAIN_MAPPINGS_MAPPING_FINALISE(FIELD_VARIABLE%DOMAIN_MAPPING,ERR,ERROR,*999)
    ENDIF
    CALL FIELD_DOF_TO_PARAM_MAP_FINALISE(FIELD_VARIABLE%DOF_TO_PARAM_MAP,ERR,ERROR,*999)
    CALL FIELD_PARAMETER_SETS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*999)


    EXITS("FIELD_VARIABLE_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field variable.
  SUBROUTINE FIELD_VARIABLE_INITIALISE(FIELD,VARIABLE_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the variable for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_NUMBER !<The variable number of the field to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,variable_type
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        IF(VARIABLE_NUMBER>=1.AND.VARIABLE_NUMBER<=FIELD%NUMBER_OF_VARIABLES) THEN
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%FIELD)
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%REGION)
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%DOMAIN_MAPPING)
          !!TODO this should be done via a field_parameter_sets_initialise call
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%PARAMETER_SETS%SET_TYPE)
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%PARAMETER_SETS%PARAMETER_SETS)
          FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_NUMBER=VARIABLE_NUMBER
          variable_type=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(VARIABLE_NUMBER)
          IF(variable_type>=1.AND.variable_type<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_TYPE=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(VARIABLE_NUMBER)
          ELSE
            LOCAL_ERROR="A field variable type of "//TRIM(NumberToVString(variable_type,"*",ERR,ERROR))// &
              & " for variable number "//TRIM(NumberToVString(VARIABLE_NUMBER,"*",ERR,ERROR))// &
              & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*998)
          ENDIF
          FIELD%VARIABLE_TYPE_MAP(FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_TYPE)%PTR=>FIELD%VARIABLES(VARIABLE_NUMBER)
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_TYPE)%PTR
          FIELD_VARIABLE%VARIABLE_LABEL=""
          FIELD_VARIABLE%VARIABLE_LABEL=FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)
          FIELD_VARIABLE%FIELD=>FIELD
          FIELD_VARIABLE%REGION=>FIELD%REGION
          FIELD_VARIABLE%DIMENSION=FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)
          FIELD_VARIABLE%DATA_TYPE=FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)
          FIELD_VARIABLE%DOF_ORDER_TYPE=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)
          IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)>0) THEN
            FIELD_VARIABLE%NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)
            CALL FIELD_VARIABLE_COMPONENTS_INITIALISE(FIELD,variable_type,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="The number of components of "// &
              & TRIM(NumberToVString(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type),"*",ERR,ERROR))// &
              & " for variable type "//TRIM(NumberToVString(variable_type,"*",ERR,ERROR))// &
              & " of field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be > 0."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
          FIELD_VARIABLE%maxNumberElementInterpolationParameters=-1
          FIELD_VARIABLE%maxNumberNodeInterpolationParameters=-1
          DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            IF(FIELD_VARIABLE%COMPONENTS(component_idx)%maxNumberElementInterpolationParameters> &
              & FIELD_VARIABLE%maxNumberElementInterpolationParameters) FIELD_VARIABLE% &
              & maxNumberElementInterpolationParameters=FIELD_VARIABLE%COMPONENTS(component_idx)% &
              & maxNumberElementInterpolationParameters
            IF(FIELD_VARIABLE%COMPONENTS(component_idx)%maxNumberNodeInterpolationParameters> &
              & FIELD_VARIABLE%maxNumberNodeInterpolationParameters) FIELD_VARIABLE% &
              & maxNumberNodeInterpolationParameters=FIELD_VARIABLE%COMPONENTS(component_idx)% &
              & maxNumberNodeInterpolationParameters
          ENDDO !component_idx
          FIELD_VARIABLE%NUMBER_OF_DOFS=0
          FIELD_VARIABLE%TOTAL_NUMBER_OF_DOFS=0
          FIELD_VARIABLE%NUMBER_OF_GLOBAL_DOFS=0
          ALLOCATE(FIELD_VARIABLE%DOMAIN_MAPPING,STAT=ERR)
          IF(ERR/=0) CALL FlagError("Could not allocate field variable domain mapping.",ERR,ERROR,*999)
          CALL DOMAIN_MAPPINGS_MAPPING_INITIALISE(FIELD_VARIABLE%DOMAIN_MAPPING, &
            & FIELD%DECOMPOSITION%NUMBER_OF_DOMAINS,ERR,ERROR,*999)
          CALL FIELD_DOF_TO_PARAM_MAP_INITIALISE(FIELD_VARIABLE%DOF_TO_PARAM_MAP,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="Variable number "//TRIM(NumberToVString(VARIABLE_NUMBER,"*",ERR,ERROR))// &
            & " is invalid for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
            & TRIM(NumberToVString(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//" variables."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FlagError("Field create values cache is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    EXITS("FIELD_VARIABLE_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_FINALISE(FIELD_VARIABLE,DUMMY_ERR,DUMMY_ERROR,*998)
998 ERRORSEXITS("FIELD_VARIABLE_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable for character labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelGet
  SUBROUTINE FIELD_VARIABLE_LABEL_GET_C(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER :: C_LENGTH,VS_LENGTH
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_LABEL_GET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            C_LENGTH=LEN(LABEL)
            VS_LENGTH=LEN_TRIM(FIELD_VARIABLE%VARIABLE_LABEL)
            IF(C_LENGTH>VS_LENGTH) THEN
              LABEL=CHAR(LEN_TRIM(FIELD_VARIABLE%VARIABLE_LABEL))
            ELSE
              LABEL=CHAR(FIELD_VARIABLE%VARIABLE_LABEL,C_LENGTH)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_GET_C")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_GET_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable for varying string labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelGet
  SUBROUTINE FIELD_VARIABLE_LABEL_GET_VS(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_LABEL_GET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            LABEL=FIELD_VARIABLE%VARIABLE_LABEL
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_GET_VS")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_GET_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelSet
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_C(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_LABEL_SET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The field variable label has been locked for for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(VARIABLE_TYPE)=LABEL
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &

              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_C")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels. \see OpenCMISS::Iron::cmfe_FieldVariableLabelSet
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_VS(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_LABEL_SET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The field variable label has been locked for for variable type "// &
                  & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(VARIABLE_TYPE)=LABEL
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_VS")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C",ERR,ERROR,*999)

    CALL FIELD_VARIABLE_LABEL_SET(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS",ERR,ERROR,*999)

    CALL FIELD_VARIABLE_LABEL_SET(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Checks the field variable types for a field.
  SUBROUTINE FIELD_VARIABLE_TYPES_CHECK(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the variable types for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to check
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_TYPES_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(SIZE(VARIABLE_TYPES,1)>=FIELD%NUMBER_OF_VARIABLES) THEN
          DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
            IF(VARIABLE_TYPES(variable_idx)>=1.AND.VARIABLE_TYPES(variable_idx)<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
              IF(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE/=VARIABLE_TYPES(variable_idx)) THEN
                LOCAL_ERROR="Invalid variable type. The variable type for variable index number "// &
                  & TRIM(NumberToVString(variable_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NumberToVString(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " which is does correspond to the specified variable_type of "// &
                  & TRIM(NumberToVString(VARIABLE_TYPES(variable_idx),"*",ERR,ERROR))//"."
                CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(VARIABLE_TYPES(variable_idx),"*",ERR,ERROR))// &
                & " at position number "//TRIM(NumberToVString(variable_idx,"*",ERR,ERROR))// &
                & " is invalid. The variable type must be between 1 and "// &
                & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDDO !variable_idx
        ELSE
          LOCAL_ERROR="Invalid variable types. The size of the specified variable types array is "// &
            & TRIM(NumberToVString(SIZE(VARIABLE_TYPES,1),"*",ERR,ERROR))//" and it must be >= "// &
            & TRIM(NumberToVString(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPES_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_CHECK

  !
  !================================================================================================================================
  !

  !>Checks the field contains the given field variable type.
  SUBROUTINE FIELD_VARIABLE_TYPE_CHECK(FIELD,VARIABLE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the variable type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    LOGICAL :: VARIABLE_FOUND
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_TYPE_CHECK",ERR,ERROR,*999)

    VARIABLE_FOUND=.FALSE.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          IF(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE==VARIABLE_TYPE) THEN
            VARIABLE_FOUND=.TRUE.
            CYCLE
          END IF
        ENDDO !variable_idx
        IF(.NOT.VARIABLE_FOUND) THEN
          CALL FlagError("Field does not have a variable type of "// &
            & TRIM(NumberToVString(VARIABLE_TYPE,"*",ERR,ERROR))//".",ERR,ERROR,*999)
        END IF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      END IF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPE_CHECK")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPE_CHECK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field variable types for a field. \see OpenCMISS::Iron::cmfe_FieldVariableTypesGet
  SUBROUTINE FIELD_VARIABLE_TYPES_GET(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the variable types for
    INTEGER(INTG), INTENT(OUT) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). On return, the field variable type variable_idx'th field variable
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_TYPES_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(SIZE(VARIABLE_TYPES,1)>=FIELD%NUMBER_OF_VARIABLES) THEN
          VARIABLE_TYPES=0
          DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
            VARIABLE_TYPES(variable_idx)=FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE
          ENDDO !variable_idx
        ELSE
          LOCAL_ERROR="Invalid variable types. The size of the specified variable types array is "// &
            & TRIM(NumberToVString(SIZE(VARIABLE_TYPES,1),"*",ERR,ERROR))//" and it must be >= "// &
            & TRIM(NumberToVString(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_GET")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPES_GET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field. \see OpenCMISS::Iron::cmfe_FieldVariableTypesSet
  SUBROUTINE FIELD_VARIABLE_TYPES_SET(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_COMPONENTS,old_variable_type,variable_idx,variable_idx2,variable_type
    INTEGER(INTG) :: OLD_DIMENSION(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_DATA_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & OLD_DOF_ORDER_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_NUMBER_OF_COMPONENTS(FIELD_NUMBER_OF_VARIABLE_TYPES)
    INTEGER(INTG), ALLOCATABLE :: OLD_VARIABLE_TYPES(:),OLD_INTERPOLATION_TYPE(:,:),OLD_MESH_COMPONENT_NUMBER(:,:)
    LOGICAL :: OLD_DIMENSION_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_DATA_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & OLD_DOF_ORDER_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & OLD_NUMBER_OF_COMPONENTS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_LABELS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES)
    LOGICAL, ALLOCATABLE :: OLD_INTERPOLATION_TYPE_LOCKED(:,:),OLD_MESH_COMPONENT_NUMBER_LOCKED(:,:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR,OLD_LABELS(FIELD_NUMBER_OF_VARIABLE_TYPES)

    ENTERS("FIELD_VARIABLE_TYPES_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES_LOCKED) THEN
            LOCAL_ERROR="The field variable types has been locked for field number "// &
              & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(SIZE(VARIABLE_TYPES,1)==FIELD%NUMBER_OF_VARIABLES) THEN
              DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
                variable_type=VARIABLE_TYPES(variable_idx)
                !Check that the variable type is in range
                IF(variable_type<1.OR.VARIABLE_TYPE>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                  LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(variable_type,"*",ERR,ERROR))// &
                    & " at position number "//TRIM(NumberToVString(variable_idx,"*",ERR,ERROR))// &
                    & " is invalid. The variable type must be between 1 and "// &
                    & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
                  CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
                !Check that the variable type is not repeated
                DO variable_idx2=variable_idx+1,FIELD%NUMBER_OF_VARIABLES
                  IF(VARIABLE_TYPES(variable_idx2)==variable_type) THEN
                    LOCAL_ERROR="The specified variable type of "//TRIM(NumberToVString(variable_type,"*",ERR,ERROR))// &
                      & " occurs at position number "//TRIM(NumberToVString(variable_idx,"*",ERR,ERROR))// &
                      & " and position number "//TRIM(NumberToVString(variable_idx2,"*",ERR,ERROR))// &
                      & ". The variable types must be unique."
                    CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ENDDO !variable_idx2
              ENDDO !variable_idx
              NUMBER_OF_COMPONENTS=SIZE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE,1)
              ALLOCATE(OLD_VARIABLE_TYPES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate old variable types.",ERR,ERROR,*999)
              ALLOCATE(OLD_INTERPOLATION_TYPE(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate old interpolation type.",ERR,ERROR,*999)
              ALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate old interpolation type locked.",ERR,ERROR,*999)
              ALLOCATE(OLD_MESH_COMPONENT_NUMBER(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate old mesh component number.",ERR,ERROR,*999)
              ALLOCATE(OLD_MESH_COMPONENT_NUMBER_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FlagError("Could not allocate old mesh component number locked.",ERR,ERROR,*999)
              OLD_VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)
              OLD_LABELS=FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS
              OLD_LABELS_LOCKED=FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED
              OLD_DIMENSION=FIELD%CREATE_VALUES_CACHE%DIMENSION
              OLD_DIMENSION_LOCKED=FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED
              OLD_DATA_TYPES=FIELD%CREATE_VALUES_CACHE%DATA_TYPES
              OLD_DATA_TYPES_LOCKED=FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED
              OLD_DOF_ORDER_TYPES=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES
              OLD_DOF_ORDER_TYPES_LOCKED=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED
              OLD_NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS
              OLD_NUMBER_OF_COMPONENTS_LOCKED=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED
              OLD_INTERPOLATION_TYPE(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_INTERPOLATION_TYPE_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_MESH_COMPONENT_NUMBER(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_MESH_COMPONENT_NUMBER_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES=0
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS=""
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%DIMENSION=0
              FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%DATA_TYPES=0
              FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES=0
              FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS=0
              FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE=0
              FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER=0
              FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED=.FALSE.
              DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
                variable_type=VARIABLE_TYPES(variable_idx)
                old_variable_type=OLD_VARIABLE_TYPES(variable_idx)
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)=OLD_LABELS(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(variable_type)=OLD_LABELS_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)=OLD_DIMENSION(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(variable_type)=OLD_DIMENSION_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)=OLD_DATA_TYPES(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(variable_type)=OLD_DATA_TYPES_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)=OLD_DOF_ORDER_TYPES(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(variable_type)=OLD_DOF_ORDER_TYPES_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)=OLD_NUMBER_OF_COMPONENTS(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(variable_type)=OLD_NUMBER_OF_COMPONENTS_LOCKED( &
                  & old_variable_type)
                FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(:,variable_type)=OLD_INTERPOLATION_TYPE(:,old_variable_type)
                FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(:,variable_type)=OLD_INTERPOLATION_TYPE_LOCKED(:, &
                  & old_variable_type)
                FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(:,variable_type)=OLD_MESH_COMPONENT_NUMBER(:,old_variable_type)
                FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(:,variable_type)=OLD_MESH_COMPONENT_NUMBER_LOCKED(:, &
                  & old_variable_type)
              ENDDO !variable_idx
              FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:SIZE(VARIABLE_TYPES,1))=VARIABLE_TYPES(1:SIZE(VARIABLE_TYPES,1))
              DEALLOCATE(OLD_VARIABLE_TYPES)
              DEALLOCATE(OLD_INTERPOLATION_TYPE)
              DEALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED)
              DEALLOCATE(OLD_MESH_COMPONENT_NUMBER)
              DEALLOCATE(OLD_MESH_COMPONENT_NUMBER_LOCKED)
            ELSE
              LOCAL_ERROR="Invalid variable types. The size of the specified variable types array is "// &
                & TRIM(NumberToVString(SIZE(VARIABLE_TYPES,1),"*",ERR,ERROR))// &
                & " and the number of variables for field number "//TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                & " is "//TRIM(NumberToVString(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
              CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_SET")
    RETURN
999 IF(ALLOCATED(OLD_VARIABLE_TYPES)) DEALLOCATE(OLD_VARIABLE_TYPES)
    IF(ALLOCATED(OLD_INTERPOLATION_TYPE)) DEALLOCATE(OLD_INTERPOLATION_TYPE)
    IF(ALLOCATED(OLD_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(OLD_MESH_COMPONENT_NUMBER)) DEALLOCATE(OLD_MESH_COMPONENT_NUMBER)
    IF(ALLOCATED(OLD_MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(OLD_MESH_COMPONENT_NUMBER_LOCKED)
    ERRORSEXITS("FIELD_VARIABLE_TYPES_SET",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_TYPES_SET_AND_LOCK(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("FIELD_VARIABLE_TYPES_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_VARIABLE_TYPES_SET(FIELD,VARIABLE_TYPES,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FlagError(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLE_TYPES_SET_AND_LOCK")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLE_TYPES_SET_AND_LOCK",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks for a valid setup of the field variables
  SUBROUTINE FieldVariablesCheck(field,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to check the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx,variableIdx2,variableType,variableType2
    LOGICAL :: duplicates
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariablesCheck",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(ASSOCIATED(field%CREATE_VALUES_CACHE)) THEN
        !Check the number of field variables
        IF(field%NUMBER_OF_VARIABLES>0) THEN
          !Check that the variable types are unique. Just do an exhaustive check. It is expensive but the list should be short.
          duplicates=.FALSE.
          firstVariable: DO variableIdx=1,field%NUMBER_OF_VARIABLES
            variableType=field%CREATE_VALUES_CACHE%VARIABLE_TYPES(variableIdx)
            secondVariable: DO variableIdx2=variableIdx+1,field%NUMBER_OF_VARIABLES
              variableType2=field%CREATE_VALUES_CACHE%VARIABLE_TYPES(variableIdx2)
              IF(variableType==variableType2) THEN
                duplicates=.TRUE.
                EXIT firstVariable
              ENDIF
            ENDDO secondVariable !variableIdx2
          ENDDO firstVariable !variableIdx
          IF(duplicates) THEN
            localError="Invalid variable types. Two or more variables have variable type "// &
              & TRIM(NumberToVString(variableType,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Invalid field setup. The field has "//TRIM(NumberToVString(field%NUMBER_OF_VARIABLES,"*",err,error))// &
            & " variables and should have > 0 variables."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Field create values cache is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    EXITS("FieldVariablesCheck")
    RETURN
999 ERRORSEXITS("FieldVariablesCheck",err,error)
    RETURN 1

  END SUBROUTINE FieldVariablesCheck

  !
  !================================================================================================================================
  !

  !>Finalises the field variables for a field and deallocates all memory.
  SUBROUTINE FIELD_VARIABLES_FINALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise the variables for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx

    ENTERS("FIELD_VARIABLES_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ALLOCATED(FIELD%VARIABLES)) THEN
        DO variable_idx=1,SIZE(FIELD%VARIABLES,1)
          CALL FIELD_VARIABLE_FINALISE(FIELD%VARIABLES(variable_idx),ERR,ERROR,*999)
        ENDDO !variable_idx
        DEALLOCATE(FIELD%VARIABLES)
      ENDIF
      FIELD%NUMBER_OF_VARIABLES=0
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLES_FINALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLES_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLES_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the field variables.
  SUBROUTINE FIELD_VARIABLES_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the variables for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx

    ENTERS("FIELD_VARIABLES_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ALLOCATED(FIELD%VARIABLES)) THEN
        CALL FlagError("Field already has associated variables.",ERR,ERROR,*999)
      ELSE
        ALLOCATE(FIELD%VARIABLES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
        IF(ERR/=0) CALL FlagError("Could not allocate new field variables.",ERR,ERROR,*999)
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          CALL FIELD_VARIABLE_INITIALISE(FIELD,variable_idx,ERR,ERROR,*999)
        ENDDO !variable_idx
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELD_VARIABLES_INITIALISE")
    RETURN
999 ERRORSEXITS("FIELD_VARIABLES_INITIALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_VARIABLES_INITIALISE

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type for a field variable
  SUBROUTINE FieldVariable_ParameterSetsCopy(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable !<A pointer to the field variable to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: fromParameterSet,toParameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsCopy",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(parameterFromSetType<=0.OR.parameterFromSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(parameterToSetType<=0.OR.parameterToSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    fromParameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(parameterFromSetType)%ptr
    IF(ASSOCIATED(fromParameterSet)) THEN
      toParameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(parameterToSetType)%ptr
      IF(ASSOCIATED(toParameterSet)) THEN
        !Do not need to do an update here as each rank already has the values.
        CALL DistributedVector_Copy(fromParameterSet%parameters,toParameterSet%parameters,alpha,err,error,*999)
      ELSE
        field=>fieldVariable%field
        IF(.NOT.ASSOCIATED(field)) THEN
          localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
            & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%VARIABLE_TYPE,"",err,error))// &
            & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
        ELSE
          localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
            & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%VARIABLE_TYPE,"",err,error))//"."
        ENDIF
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      field=>fieldVariable%field
      IF(.NOT.ASSOCIATED(field)) THEN
        localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
          & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%VARIABLE_TYPE,"",err,error))// &
          & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
      ELSE
        localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
          & " has not been created on variable type "//TRIM(NumberToVString(fieldVariable%VARIABLE_TYPE,"",err,error))//"."
      ENDIF
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("FieldVariable_ParameterSetsCopy")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsCopy",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsCopy

  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type if they exist for a field variable
  SUBROUTINE FieldVariable_ParameterSetsCopyIfExists(fieldVariable,parameterFromSetType,parameterToSetType,alpha,err,error,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable !<A pointer to the field variable to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: parameterFromSetType !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: parameterToSetType !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: alpha !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: fromParameterSet,toParameterSet
    TYPE(VARYING_STRING) :: localError

    ENTERS("FieldVariable_ParameterSetsCopyIfExists",err,error,*999)

    IF(.NOT.ASSOCIATED(fieldVariable)) CALL FlagError("Field variable is not associated.",err,error,*999)
    IF(parameterFromSetType<=0.OR.parameterFromSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The from parameter set type of "//TRIM(NumberToVString(parameterFromSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    IF(parameterToSetType<=0.OR.parameterToSetType>FIELD_NUMBER_OF_SET_TYPES) THEN
      localError="The to parameter set type of "//TRIM(NumberToVString(parameterToSetType,"*",err,error))// &
        & " is invalid. The parameter set type must be between 1 and "// &
        & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    fromParameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(parameterFromSetType)%ptr
    IF(ASSOCIATED(fromParameterSet)) THEN
      toParameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(parameterToSetType)%ptr
      IF(ASSOCIATED(toParameterSet)) THEN
        !Do not need to do an update here as each rank already has the values.
        CALL DistributedVector_Copy(fromParameterSet%parameters,toParameterSet%parameters,alpha,err,error,*999)
      ENDIF
    ENDIF

    EXITS("FieldVariable_ParameterSetsCopyIfExists")
    RETURN
999 ERRORSEXITS("FieldVariable_ParameterSetsCopyIfExists",err,error)
    RETURN 1

  END SUBROUTINE FieldVariable_ParameterSetsCopyIfExists

  !
  !================================================================================================================================
  !

  !>Finalises the fields and deallocates all memory.
  SUBROUTINE FIELDS_FINALISE(FIELDS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<A pointer to the fields to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_TYPE), POINTER :: FIELD

    ENTERS("FIELDS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELDS)) THEN
      DO WHILE(FIELDS%NUMBER_OF_FIELDS>0)
        FIELD=>FIELDS%FIELDS(1)%PTR
        CALL FIELD_DESTROY(FIELD,ERR,ERROR,*999)
      ENDDO !field_idx
      DEALLOCATE(FIELDS)
    ENDIF

    EXITS("FIELDS_FINALISE")
    RETURN
999 ERRORSEXITS("FIELDS_FINALISE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELDS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the fields.
  SUBROUTINE FIELDS_INITIALISE_GENERIC(FIELDS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<A pointer to the fields to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELDS_INITIALISE_GENERIC",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELDS)) THEN
      NULLIFY(FIELDS%REGION)
      NULLIFY(FIELDS%INTERFACE)
      FIELDS%NUMBER_OF_FIELDS=0
      NULLIFY(FIELDS%FIELDS)
    ELSE
      CALL FlagError("Fields is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELDS_INITIALISE_GENERIC")
    RETURN
999 ERRORSEXITS("FIELDS_INITIALISE_GENERIC",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_GENERIC

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given interface.
  SUBROUTINE FIELDS_INITIALISE_INTERFACE(INTERFACE,ERR,ERROR,*)

    !Argument variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE !<A pointer to the interface to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELDS_INITIALISE_INTERFACE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(INTERFACE%FIELDS)) THEN
        CALL FlagError("Interface already has fields associated.",ERR,ERROR,*999)
      ELSE
        ALLOCATE(INTERFACE%FIELDS,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Interface fields could not be allocated.",ERR,ERROR,*999)
        CALL FIELDS_INITIALISE_GENERIC(INTERFACE%FIELDS,ERR,ERROR,*999)
        INTERFACE%FIELDS%INTERFACE=>INTERFACE
      ENDIF
    ELSE
      CALL FlagError("Interface is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELDS_INITIALISE_INTERFACE")
    RETURN
999 ERRORSEXITS("FIELDS_INITIALISE_INTERFACE",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_INTERFACE

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given region.
  SUBROUTINE FIELDS_INITIALISE_REGION(REGION,ERR,ERROR,*)

    !Argument variables
    TYPE(REGION_TYPE), POINTER :: REGION !<A pointer to the region to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    ENTERS("FIELDS_INITIALISE_REGION",ERR,ERROR,*999)

    IF(ASSOCIATED(REGION)) THEN
      IF(ASSOCIATED(REGION%FIELDS)) THEN
        CALL FlagError("Region already has fields associated.",ERR,ERROR,*999)
      ELSE
        ALLOCATE(REGION%FIELDS,STAT=ERR)
        IF(ERR/=0) CALL FlagError("Region fields could not be allocated.",ERR,ERROR,*999)
        CALL FIELDS_INITIALISE_GENERIC(REGION%FIELDS,ERR,ERROR,*999)
        REGION%FIELDS%REGION=>REGION
      ENDIF
    ELSE
      CALL FlagError("Region is not associated.",ERR,ERROR,*999)
    ENDIF

    EXITS("FIELDS_INITIALISE_REGION")
    RETURN
999 ERRORSEXITS("FIELDS_INITIALISE_REGION",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_REGION

  !
  !================================================================================================================================
  !

  !> Interpolates data from one field/mesh to another
  SUBROUTINE MESH_EMBEDDING_PUSH_DATA(MESH_EMBEDDING,PARENT_FIELD,PARENT_COMPONENT,CHILD_FIELD,CHILD_COMPONENT,ERR,ERROR,*)
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
    INTEGER(INTG), INTENT(OUT) :: ERR              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR     !<The error string
    TYPE(FIELD_TYPE), POINTER :: PARENT_FIELD      !<Field for the parent nodes
    TYPE(FIELD_TYPE), POINTER :: CHILD_FIELD       !<Field for the child nodes
    INTEGER(INTG), INTENT(IN) :: PARENT_COMPONENT  !<Component of the parent field, must be nodally based
    INTEGER(INTG), INTENT(IN) ::  CHILD_COMPONENT  !<Component of the child  field, must be nodally based

    !Local variables
    TYPE(MESH_ELEMENT_TYPE), POINTER :: ELEMENT
    TYPE(BASIS_TYPE), POINTER :: BASIS
    INTEGER(INTG) :: E,I,B,version
    REAL(DP) :: INTERP_VAL, WT
    REAL(DP),ALLOCATABLE :: PARENT_VALUES(:)

    ENTERS("MESH_EMBEDDING_PUSH_DATA",ERR,ERROR,*999)

    version=1
    DO E=1,MESH_EMBEDDING%PARENT_MESH%NUMBER_OF_ELEMENTS
      ELEMENT=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%PTR%ELEMENTS%ELEMENTS(E)
      BASIS=>ELEMENT%BASIS
      ALLOCATE(PARENT_VALUES(BASIS%NUMBER_OF_NODES))

      DO B=1,BASIS%NUMBER_OF_NODES
        ! Version variable added and initialized above
        CALL FIELD_PARAMETER_SET_GET_NODE(PARENT_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
        &  ELEMENT%GLOBAL_ELEMENT_NODES(B),PARENT_COMPONENT,PARENT_VALUES(B),ERR,ERROR,*999)   ! global no?
      ENDDO


      DO I=1,MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%NUMBER_OF_NODES
        INTERP_VAL = 0.0
        DO B=1,BASIS%NUMBER_OF_NODES
          WT = BASIS_EVALUATE_XI(BASIS,B,NO_PART_DERIV,MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%XI_COORDS(:,I),ERR,ERROR)
          INTERP_VAL = INTERP_VAL + WT * PARENT_VALUES(B)
        ENDDO

        ! store in field
        ! Version variable added and initialized above
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(CHILD_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
        &  MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%NODE_NUMBERS(I),CHILD_COMPONENT,INTERP_VAL,ERR,ERROR,*999)
      ENDDO
      DEALLOCATE(PARENT_VALUES)
    ENDDO

    EXITS("MESH_EMBEDDING_PUSH_DATA")
    RETURN
999 ERRORSEXITS("MESH_EMBEDDING_PUSH_DATA",ERR,ERROR)
    RETURN 1

  END SUBROUTINE MESH_EMBEDDING_PUSH_DATA

  !
  !================================================================================================================================
  !

  SUBROUTINE MESH_EMBEDDING_PULL_GAUSS_POINT_DATA(MESH_EMBEDDING,PARENT_FIELD,PARENT_COMPONENT,CHILD_FIELD,CHILD_COMPONENT,&
    & ERR,ERROR,*)

    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
    INTEGER(INTG), INTENT(OUT) :: ERR              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR     !<The error string
    TYPE(FIELD_TYPE), POINTER :: PARENT_FIELD      !<Field for the parent nodes
    TYPE(FIELD_TYPE), POINTER :: CHILD_FIELD       !<Field for the child nodes
    INTEGER(INTG), INTENT(IN) :: PARENT_COMPONENT  !<Component of the parent field, must be nodally based
    INTEGER(INTG), INTENT(IN) ::  CHILD_COMPONENT  !<Component of the child  field, must be nodally based

    !Local variables
    TYPE(MeshElementsType), POINTER :: ELEMENTS
    TYPE(MESH_ELEMENT_TYPE), POINTER :: ELEMENT
    TYPE(BASIS_TYPE), POINTER :: BASIS
    INTEGER(INTG) :: E,GP,B, NGP,version
    REAL(DP) :: INTERP_VAL, WT, VAL

    ENTERS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA",ERR,ERROR,*999)

    ELEMENTS=>MESH_EMBEDDING%CHILD_MESH%TOPOLOGY(1)%PTR%ELEMENTS

    BASIS=>MESH_EMBEDDING%CHILD_MESH%TOPOLOGY(1)%PTR%ELEMENTS%ELEMENTS(1)%BASIS
    version = 1
    DO E=1,MESH_EMBEDDING%PARENT_MESH%NUMBER_OF_ELEMENTS
      NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
      DO GP=1,NGP
        ELEMENT=>ELEMENTS%ELEMENTS(MESH_EMBEDDING%GAUSS_POINT_XI_POSITION(GP,E)%ELEMENT_NUMBER)
        BASIS=>ELEMENT%BASIS
        DO B=1,BASIS%NUMBER_OF_NODES
          ! Version variable added and initialized above
          CALL FIELD_PARAMETER_SET_GET_NODE(CHILD_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
          &  ELEMENT%GLOBAL_ELEMENT_NODES(B),CHILD_COMPONENT,VAL ,ERR,ERROR,*999)   ! global no?
          WT = BASIS_EVALUATE_XI(BASIS,B,NO_PART_DERIV,MESH_EMBEDDING%GAUSS_POINT_XI_POSITION(GP,E)%CHILD_XI_COORD,ERR,ERROR)
          INTERP_VAL = INTERP_VAL + WT * VAL
        ENDDO
         ! store in gauss point parent field
        CALL FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT(PARENT_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,GP,E,& ! TODO: var type/par set from input
          &  PARENT_COMPONENT, INTERP_VAL,ERR,ERROR,*999)
      ENDDO
    ENDDO

    EXITS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA")
    RETURN
999 ERRORSEXITS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA",ERR,ERROR)
    RETURN 1
  END SUBROUTINE MESH_EMBEDDING_PULL_GAUSS_POINT_DATA

  !
  !================================================================================================================================
  !

 !>Returns from the given parameter set a double precision value for the specified gauss point of a field variable component. \see OpenCMISS::Iron::cmfe_FieldParameterSetGetGaussPoint
  SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD(MESH_EMBEDDING,COMPONENT_NUMBER,NGP,COORD_VALUE, &
    & ERR,ERROR,*)

    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER  !<Component
    INTEGER(INTG), INTENT(OUT) :: NGP
    REAL(DP), INTENT(OUT) :: COORD_VALUE(:)
    INTEGER(INTG), INTENT(OUT) :: ERR              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR     !<The error string

    !Local variables
    TYPE(MeshElementsType), POINTER :: ELEMENTS
    TYPE(BASIS_TYPE), POINTER :: BASIS
    INTEGER(INTG) :: GP

    ENTERS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD",ERR,ERROR,*999)

    ELEMENTS=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%PTR%ELEMENTS

    BASIS=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%PTR%ELEMENTS%ELEMENTS(1)%BASIS
    NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS

    DO GP = 1,NGP
    COORD_VALUE(GP) = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%&
       &GAUSS_POSITIONS(COMPONENT_NUMBER,GP)
    ENDDO

    EXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD")
    RETURN
999 ERRORSEXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD",ERR,ERROR)
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD

  !
  !================================================================================================================================
  !

END MODULE FIELD_ROUTINES
